
/* # line 2 "ascParse.y" */
/*
 *  Ascend Grammar file
 *  by Tom Epperly
 *  Version: $Revision: 1.10 $
 *  Version control file: $RCSfile: ascParse.c.no.yacc,v $
 *  Date last modified: $Date: 1998/05/18 17:55:56 $
 *  Last modified by: $Author: mthomas $
 *
 *  Generated by 'yacc -d ascParse.y' on baker.edrc.cmu.edu
 *  ascParse.y CVS info:
 *  Version: Revision: 1.22 
 *  Version control file: RCSfile: ascParse.y,v 
 *  Date last modified: Date: 98/05/18 16:36:42 
 *  Last modified by: Author: ballan 
 *
 *  This file is part of the Ascend Language Interpreter.
 *
 *  Copyright (C) 1990, 1993, 1994 Thomas Guthrie Epperly
 *  Copyright (C) 1997 Benjamin Andrew Allan & Vicente Rico-Ramirez
 *  Copyright (C) 1998 Carnegie Mellon University
 *
 *  The Ascend Language Interpreter is free software; you can redistribute
 *  it and/or modify it under the terms of the GNU General Public License as
 *  published by the Free Software Foundation; either version 2 of the
 *  License, or (at your option) any later version.
 *
 *  The Ascend Language Interpreter is distributed in hope that it will be
 *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with the program; if not, write to the Free Software Foundation,
 *  Inc., 675 Mass Ave, Cambridge, MA 02139 USA.  Check the file named
 *  COPYING.
 *
 */
#include<stdio.h>
#include<limits.h>		/* need DBL_MAX and LONG_MAX */
#include<float.h>		/* on a NeXT they are in here */
#include"utilities/ascConfig.h"
#include"utilities/ascMalloc.h"
#include"general/list.h"
#include"general/dstring.h"
#include"compiler/compiler.h"
#include"compiler/scanner.h"
#include"compiler/symtab.h"		/* the global string/symbol table */
#include"compiler/notate.h"		/* notes database wrapper */
#include"compiler/braced.h"
#include"compiler/fractions.h"
#include"compiler/dimen.h"
#include"compiler/functype.h"
#include"compiler/func.h"
#include"compiler/types.h"
#include"compiler/name.h"
#include"compiler/nameio.h"
#include"compiler/instance_enum.h"
#include"compiler/extfunc.h"
#include"compiler/packages.h"
#include"compiler/sets.h"
#include"compiler/exprs.h"
#include"compiler/exprio.h"
#include"compiler/vlist.h"
#include"compiler/vlistio.h"		/* for debugging only */
#include"compiler/stattypes.h"
#include"compiler/slist.h"
#include"compiler/statement.h"
#include"compiler/statio.h"
#include"compiler/units.h"
#include"compiler/when.h"
#include"compiler/select.h"
#include"compiler/switch.h"
#include"compiler/proc.h"
#include"compiler/watchpt.h"
#include"compiler/module.h"
#include"compiler/child.h"
#include"compiler/type_desc.h"
#include"compiler/type_descio.h"
#include"compiler/typedef.h"
#include"compiler/library.h"
#include"compiler/syntax.h"
/* 1 ==> expr can find missing , w/o  shift/reduce conflicts */
#define COMMAEXPR_NOTBUGGY 0 
#if COMMAEXPR_NOTBUGGY
#include "compiler/exprio.h"
#endif /* for CommaExpr if working. */

#ifndef lint
static CONST char ParserID[] = "$Id: ascParse.c.no.yacc,v 1.10 1998/05/18 17:55:56 mthomas Exp $";
#endif

int g_compiler_warnings = 1;		/* level of whine to allow */

FILE *g_ascend_errors = stderr;		/* error file */
FILE *g_ascend_warnings = stderr;	/* whine file */
FILE *g_ascend_information = stderr;	/* note file */
#ifndef ASCERR
#define ASCERR g_ascend_errors
#define ASCWAR g_ascend_warnings
#define ASCINF g_ascend_information
#endif

extern int zz_error(char *);
/*  provided at the end of this file.
 *  it increments g_untrapped_error, the global defined below
 */

static unsigned long g_header_linenum = 0;
static unsigned int g_untrapped_error = 0;
/* if g_untrapped_error is set to 1, the current definition
 * should be abandoned even if nothing else detectable by
 * typedef.c exists. basically any syntax error should cause a type
 * to be abandoned, but not all cause the parser to barf.
 */

/* the last seen method name while processing a method */
static symchar *g_proc_name=NULL;

/* the last seen ATOM/MODEL/constant type and refinement base */
static symchar *g_type_name=NULL;
static symchar *g_refines_name=NULL;
/*********************************************************************\
 * g_type_name is used by the scanner when closing a module to check if
 * the parser is in the middle of parsing a MODEL or ATOM type
 * definition.
 *      g_type_name == NULL implies that the parser is in between
 *                          definitions. This depends on proper
 *                          resets to NULL at END of type productions.
 *      g_type_name != NULL implies that the parser is in the middle
 *                          of a type definition and gives the name
 *                          of that type.
\*********************************************************************/

static symchar *g_end_identifier = NULL;
/*  This variable gets reset every time we see an ``END_T''.  If the
 *  token after END_T is missing (i.e., ``END;'') or if it is recognized
 *  (e.g., FOR_T), set this variable to NULL.  When we see an
 *  ``END_T IDENTIFIER_T'', set this variable to the pointer into the
 *  symbol table returned by the scanner.
 */

static struct StatementList *g_model_parameters=NULL;
/* this is the statementlist of the parameterized type
 */

static struct StatementList *g_parameter_wheres=NULL;
/* this is the where list of a parameterized type. restrictions on args
 */

static struct StatementList *g_parameter_reduction=NULL;
/* this is the statementlist of the REFINES clause
 * at present both might be null, which is bad.
 */

static struct Set *g_typeargs=NULL;
/* optional args to a typename in part declaration.
 * it is set in the production type_identifier. in
 * contexts where args are not allowed, use IDENTIFIER_T instead of the
 * type_identifier production.
 */

static struct Set *g_callargs=NULL;
/* optional args to a user defined method.
 * it is set in the production call_identifier. in
 * contexts where args are not allowed, use IDENTIFIER_T instead of the
 * type_identifier production.
 */

static struct gl_list_t *g_notelist = NULL;
/*
 * Notes accumulator until a type commits or destroys it.
 */

static int g_defaulted;			/* used for atoms,constants */

static CONST dim_type *g_dim_ptr;	  /* dim of last units parsed, or so */
static CONST dim_type *g_atom_dim_ptr;	  /* dim of DIMENSION decl */
static CONST dim_type *g_default_dim_ptr; /* dim of default value parsed */

static double g_default_double;
static long g_default_long;
symchar *g_default_symbol;
#define DOUBLECONSTANT 0
#define LONGCONSTANT 1
#define BOOLEANCONSTANT 2
#define SYMBOLCONSTANT 3
static int g_constant_type = DOUBLECONSTANT;
static CONST struct Units *g_units_ptr;

int g_parse_relns = 1;
/*  Should we parse relations?
 *      0 indicates don't parse relations
 *      1 indicates process them
 */

/*  Forward declaration of error message reporting
 *  functions provided at the end of this file.
 */
static void ErrMsg_Generic(CONST char *);
static void ErrMsg_CommaName(CONST char *, struct Name *);
#if COMMAEXPR_NOTBUGGY
static void ErrMsg_CommaExpr(CONST char *, struct Expr *);
#endif /* COMMAEXPR_NOTBUGGY */
static void ErrMsg_NullDefPointer(CONST char *);
static void ErrMsg_ProcTypeMissing(CONST char *, CONST char *);
static void ErrMsg_ProcsRejected(CONST char *, CONST char *);
static void ErrMsg_DuplicateProc(struct InitProcedure *);
static void ErrMsg_ParensBrackets(CONST char *);
static void WarnMsg_MismatchEnd(CONST char *, CONST char *,
                                unsigned long, CONST char *);
static CONST char *TokenAsString(unsigned long);

/*
 *  NOTES  Explanations  NOTES  Explanations  NOTES  Explanations  NOTES
 *
 *  Mark Thomas  Thursday, 13 March 1997
 *
 *  The parser will now parse a NOTES block as well as in-lined NOTES.  As
 *  a matter of fact, the parser would probably parse FORTRAN now since it
 *  is very lenient.  For the in-lined NOTES, I accept any "doubly-quoted"
 *  string after an `fname'.  I am currently dropping the NOTE on the
 *  floor.  Ideally, we should only accept an inline NOTE when we are
 *  creating a new thing, like in an IS_A statement or a labeled relation.
 *  That means either adding the optional_note to fname and whining at the
 *  user when he/she uses the in-lined notes incorrectly, or coming up
 *  with a fvarnotelist and fnamenote that accepts fnames and
 *  optional_notes in a list or a stand-alone form.
 *
 *  For the block NOTES statement, the symtax is
 *
 *      NOTES ( SYMBOL_T ( fvarlist BRACEDTEXT_T )+ )+ END NOTES ';'
 *
 *  Here I am using () as part of the meta-language to describe the syntax
 *  to you, they are not part of the formal grammer.  An example is
 *
 *      NOTES
 *          'text'  a,b,c  { Here is some text }
 *                  d      { Here is more text }
 *          'html'  SELF   { <bold>html sucks</bold> }
 *      END NOTES;
 *
 *  Note that the only punctuation is the `,' between the members of the
 *  fvarlist and the closing `;'.  Right now, the term `SELF' would be
 *  eaten in the fvarlist production.  I'm not sure if this is what we
 *  should do (which requires having the notes processing do something
 *  special when it sees SELF in the fvarlist), or if we should create
 *  a SELF_T token.  The latter is certainly easier to implement from
 *  the parser's perspective, which is why I did it that way.
 *
 *  The block NOTES statement doesn't do anything with its stuff either,
 *  the symbols and {bracedText} get dropped on the floor and I destroy
 *  the fvarlist, but that all that happens.
 *
 *  The `notes_body' and `noteslist' productions return `notes_ptr', which
 *  right now is a `void*' until we can decide what type of data structure
 *  we want to handle NOTES.
 *
 *  As an amusing side note, the parser will currently eat the following:
 *
 *      NOTES
 *          'fun' name  "put some text here"  {put more text here}
 *      END NOTES;
 *
 *  Like I said, this is so the parser will eat them; it's not being real
 *  smart about what it does with them.
 *
 *  For debugging the NOTES stuff, set the DEBUG_NOTES macro to the
 *  following:
 *
 *  #define DEBUG_NOTES(s) FPRINTF(stderr,"****DISCARDED NOTES:\n%s****\n",(s))
 *
 *  To completely ignore the NOTES, set DEBUG_NOTES to the following:
 *
 *  #define DEBUG_NOTES(s) 0
 *
 *  Note that if you do the latter, you'll get `statement with no effect'
 *  warnings from gcc -Wall.
 */
#define DEBUG_NOTES(s) 0

/*
 * Because the ascend types and notes are not tightly bound to each other,
 * what with notes being stored in a database,
 * We collect notes locally until the type associated with a batch of notes
 * is approved by typedef and other error checks. Then we process the
 * collected notes, commiting them to the database.
 *
 * NOTES made via ADD NOTES do not require a type check first and the
 * type may not even exist yet in the library.
 *
 * ProcessNotes(keep); Clear up collected list, commit them if keep != 0.
 * CollectNote(note); Add a note to the collected list.
 */
static void ProcessNotes(int);
static void CollectNote(struct Note *);

/* For 'inline' notes, note on DQUOTE_T from scanner.l:
 * Remember that DQUOTE_T is a string value which is local to the
 * production that finds it. It must be copied if you want to
 * keep it.
 */

/* # line 298 "ascParse.y" */
typedef union  {
  double real_value;
  long   int_value;
  struct fraction frac_value;
  symchar *id_ptr;
  CONST char *braced_ptr;	/* pointer for units, explanations, tables */
  symchar *sym_ptr;		/* pointer for symbols */
  CONST char *dquote_ptr;       /* for text in "double quotes" */
  struct Name *nptr;
  struct Expr *eptr;
  struct Set *sptr;
  struct VariableList *lptr;
  struct Statement *statptr;
  struct StatementList *slptr;
  struct SelectList *septr;
  struct SwitchList *swptr;
  struct WhenList *wptr;
  struct NoteTmp *notesptr;	/* change this once struct Notes is defined */
  struct gl_list_t *listp;
  struct InitProcedure *procptr;
  CONST dim_type *dimp;
  struct TypeDescription *tptr;
  struct UnitDefinition *udefptr;
  dim_type dimen;
  enum ForOrder order;
  enum ForKind fkind;
} ZZ_STYPE;
#ifdef __cplusplus
#  include <stdio.h>
#  include <yacc.h>
#endif	/* __cplusplus */ 
# define ADD_T 257
# define ALIASES_T 258
# define AND_T 259
# define ANY_T 260
# define AREALIKE_T 261
# define ARETHESAME_T 262
# define ARRAY_T 263
# define ATOM_T 264
# define BEQ_T 265
# define BNE_T 266
# define BREAK_T 267
# define CALL_T 268
# define CARD_T 269
# define CASE_T 270
# define CHOICE_T 271
# define CHECK_T 272
# define CONDITIONAL_T 273
# define CONSTANT_T 274
# define CONTINUE_T 275
# define CREATE_T 276
# define DATA_T 277
# define DECREASING_T 278
# define DEFAULT_T 279
# define DEFINITION_T 280
# define DIMENSION_T 281
# define DIMENSIONLESS_T 282
# define DO_T 283
# define ELSE_T 284
# define END_T 285
# define EXPECT_T 286
# define EXTERNAL_T 287
# define FALSE_T 288
# define FALLTHRU_T 289
# define FOR_T 290
# define FROM_T 291
# define GLOBAL_T 292
# define IF_T 293
# define IMPORT_T 294
# define IN_T 295
# define INPUT_T 296
# define INCREASING_T 297
# define INTERACTIVE_T 298
# define INTERSECTION_T 299
# define ISA_T 300
# define _IS_T 301
# define ISREFINEDTO_T 302
# define MAXIMIZE_T 303
# define MAXINTEGER_T 304
# define MAXREAL_T 305
# define METHODS_T 306
# define METHOD_T 307
# define MINIMIZE_T 308
# define MODEL_T 309
# define NOT_T 310
# define NOTES_T 311
# define OF_T 312
# define OR_T 313
# define OTHERWISE_T 314
# define OUTPUT_T 315
# define PATCH_T 316
# define PROD_T 317
# define PROVIDE_T 318
# define REFINES_T 319
# define REPLACE_T 320
# define REQUIRE_T 321
# define RETURN_T 322
# define RUN_T 323
# define SATISFIED_T 324
# define SELECT_T 325
# define SIZE_T 326
# define STOP_T 327
# define SUCHTHAT_T 328
# define SUM_T 329
# define SWITCH_T 330
# define THEN_T 331
# define TRUE_T 332
# define UNION_T 333
# define UNITS_T 334
# define UNIVERSAL_T 335
# define WHEN_T 336
# define WHERE_T 337
# define WHILE_T 338
# define WILLBE_T 339
# define WILLBETHESAME_T 340
# define WILLNOTBETHESAME_T 341
# define ASSIGN_T 342
# define CASSIGN_T 343
# define DBLCOLON_T 344
# define USE_T 345
# define LEQ_T 346
# define GEQ_T 347
# define NEQ_T 348
# define DOTDOT_T 349
# define WITH_T 350
# define VALUE_T 351
# define WITH_VALUE_T 352
# define REAL_T 353
# define INTEGER_T 354
# define IDENTIFIER_T 355
# define BRACEDTEXT_T 356
# define SYMBOL_T 357
# define DQUOTE_T 358
# define UMINUS_T 359
# define UPLUS_T 360
#define zz_clearin zz_char = -1
#define zz_errok zz_errflag = 0
extern int zz_char;
#ifndef ZZ_MAXDEPTH
#define ZZ_MAXDEPTH 150
#endif

/* __ZZ_SCLASS defines the scoping/storage class for global objects
 * that are NOT renamed by the -p option.  By default these names
 * are going to be 'static' so that multi-definition errors
 * will not occur with multiple parsers.
 * If you want (unsupported) access to internal names you need
 * to define this to be null so it implies 'extern' scope.
 * This should not be used in conjunction with -p.
 */
#ifndef __ZZ_SCLASS
# define __ZZ_SCLASS static
#endif
ZZ_STYPE zz_lval;
__ZZ_SCLASS ZZ_STYPE zz_val;
typedef int zz_tabelem;
# define ZZ_ERRCODE 256

/* # line 2657 "ascParse.y" */

/*
 * We really need to do something about freeing up the productions
 * that invoke this so we don't leak memory like a seive.
 * for example  z[i IN [1..2]][j IN [process[i]] IS_A mass; eats a ton.
 */
int
zz_error(char *s)
{
  g_untrapped_error++;
  FPRINTF(ASCERR,"%s",s);
  if (Asc_CurrentModule() != NULL) {
    FPRINTF(ASCERR," %s:%lu.\n",
            Asc_ModuleBestName(Asc_CurrentModule()),LineNum());
  } else {
    FPRINTF(ASCERR," at end of input.\n");
  }
  return 0;
}

/*
 *  See the header file scanner.h for a description of this function.
 */
void
Asc_ErrMsgTypeDefnEOF(void)
{
  /*  Check g_type_name to see if we're in the middle of a type
   *  definition.  If NULL no, otherwise yes.
   */
  if ( g_type_name ) {
    FPRINTF(ASCERR,
            "%sEnd of file reached in a type definition.\n"
            "\tIncomplete definition for %s on line %s:%lu\n",
            StatioLabel(3),
            SCP(g_type_name),
            (Asc_CurrentModule()
             ? Asc_ModuleBestName(Asc_CurrentModule())
             : "<UNKNOWN>"),
            LineNum());
  }
}


/*
 *  void ErrMsg_*(void)
 *
 *  The following print error and warning messages to the filehandles
 *  ASCERR and ASCWARN, respectively.
 *  The type of error/warning that will be printed is indicated by the
 *  functions name and the arguments to fprintf.
 */
static void
ErrMsg_Generic(CONST char *string)
{
  struct module_t *mod;

  /* the module may have be already closed */
  mod = Asc_CurrentModule();
  FPRINTF(ASCERR,
          "%s%son line %s:%lu\n",
          StatioLabel(3),string,
          (mod ? Asc_ModuleBestName(mod) : "<UNKNOWN>"),
          LineNum());
  if (g_type_name != NULL) {
    FPRINTF(ASCERR,"    type %s",SCP(g_type_name));
  }
  if (g_proc_name != NULL) {
    FPRINTF(ASCERR,"    METHOD %s",SCP(g_proc_name));
  }
  if (g_type_name != NULL || g_proc_name != NULL) {
    FPRINTF(ASCERR,"\n");
  }
}

static void ErrMsg_CommaName(CONST char *what, struct Name *name)
{
  struct module_t *mod;

  /* the module may have be already closed */
  mod = Asc_CurrentModule();
  FPRINTF(ASCERR, "ASC-Error: Missing comma or operator before %s ",what);
  WriteName(ASCERR,name);
  FPRINTF(ASCERR,
          " on line %s:%lu\n",
          (mod ? Asc_ModuleBestName(mod) : "<UNKNOWN>"),
          LineNum());
}

#if COMMAEXPR_NOTBUGGY
static void ErrMsg_CommaExpr(CONST char *what, struct Expr *eptr)
{
  struct module_t *mod;

  /* the module may have be already closed */
  mod = Asc_CurrentModule();
  FPRINTF(ASCERR, "ASC-Error: Missing comma before %s ",what);
  WriteExpr(ASCERR,eptr);
  FPRINTF(ASCERR,
          " on line %s:%lu\n",
          (mod ? Asc_ModuleBestName(mod) : "<UNKNOWN>"),
          LineNum());
}
#endif /* COMMAEXPR_NOTBUGGY. delete if can't fix */

static void
ErrMsg_NullDefPointer(CONST char *object)
{
  FPRINTF(ASCERR,
          "%sRejected \"%s\" at line %s:%lu.\n\n",
          StatioLabel(3),
          object,
          Asc_ModuleBestName(Asc_CurrentModule()),
          LineNum());
}

static void
ErrMsg_ProcTypeMissing(CONST char *AorR, CONST char *type)
{
  FPRINTF(ASCERR,
	  "%s: %s METHODS called with undefined type (%s) at %s:%d.\n",
	  StatioLabel(3), AorR, type,
	  Asc_ModuleBestName(Asc_CurrentModule()),
          (int)LineNum());
}

static void
ErrMsg_ProcsRejected(CONST char *AorR, CONST char *type)
{
  FPRINTF(ASCERR,
	  "%s: %s METHODS failed for type %s at %s:%d.\n",
	  StatioLabel(3), AorR, type,
	  Asc_ModuleBestName(Asc_CurrentModule()),
          (int)LineNum());
}

static void
ErrMsg_DuplicateProc(struct InitProcedure *p)
{
  FPRINTF(ASCERR,
	  "%s: Duplicate METHOD %s rejected at %s:%d.\n",
	  StatioLabel(2),
	  SCP(ProcName(p)),
	  Asc_ModuleBestName(Asc_CurrentModule()),
          (int)LineNum());
}

static void
ErrMsg_ParensBrackets(CONST char *operation)
{
  FPRINTF(ASCERR,
          "  You should be using %s[] not %s()\nat line %s:%lu.\n",
          operation,
          operation,
          Asc_ModuleBestName(Asc_CurrentModule()),
          LineNum());
}


/*
 *  WarnMsg_MismatchEnd(statement, opt_name, end_token, expecting);
 *      const char *statement;
 *      const char *opt_name;
 *      unsigned long end_token;
 *      const char *expecting;
 *
 *  Print a warning message that the token after the END keyword did not
 *  match what we were expecting for the current statement.
 *  Arguments:
 *      statement --the current statement, e.g. ATOM, METHOD, FOR, IF, CASE
 *      opt_name  --the name of the thing we were defining for ATOMs, METHODs,
 *                  etc, or NULL anonymous statements (FOR, IF, CASE, etc)
 *      end_token --the TOKEN_T that we were received instead.  We use the
 *                  TokenAsString to produce a string given a TOKEN_T
 *      expecting --the keyword we were expecting to see after the END; if
 *                  NULL, we were expecting the string given in statement
 */
static void
WarnMsg_MismatchEnd(CONST char *statement, CONST char *opt_name,
		    unsigned long end_token, CONST char *expecting)
{
  FPRINTF(ASCWAR,
          "%s %s %s terminated with\n"
          "  END %s;     ---expecting:  END %s;\n"
          "  at %s:%lu.\n",
          StatioLabel(2),
          statement,
          ((opt_name != NULL) ? opt_name : "statement"),
          TokenAsString(end_token),
          ((expecting != NULL) ? expecting : statement),
          Asc_ModuleBestName(Asc_CurrentModule()),
          LineNum());
}


/*
 *  CONST char *TokenAsString(token);
 *      unsigned long token;
 *
 *  Takes a TOKEN_T (e.g., FOR_T, MODEL_T, END_T, IDENTIFIER_T) and returns
 *  a string representation of it:
 *      e.g.:  TokenAsString(FOR_T) ==> "FOR"
 *
 *  Since this function is only used inside WarnMsg_MismatchEnd, we do a
 *  couple of things specific to that function:  If token is END_T, we
 *  return an empty string, and if it is IDENTIFIER_T, we return the
 *  current value of g_end_identifier, or UNKNOWN if g_end_identifier is
 *  NULL.
 */
static CONST char *
TokenAsString(unsigned long token)
{
  switch( token ) {
  case ATOM_T:
    return "ATOM";
  case CONDITIONAL_T:
    return "CONDITIONAL";
  case FOR_T:
    return "FOR";
  case IF_T:
    return "IF";
  case INTERACTIVE_T:
    return "INTERACTIVE";
  case METHOD_T:
    return "METHOD";
  case METHODS_T:
    return "METHODS";
  case MODEL_T:
    return "MODEL";
  case NOTES_T:
    return "NOTES";
  case PATCH_T:
    return "PATCH";
  case SELECT_T:
    return "SELECT";
  case SWITCH_T:
    return "SWITCH";
  case UNITS_T:
    return "UNITS";
  case WHEN_T:
    return "WHEN";
  case END_T:
    return "";
  case IDENTIFIER_T:
  default:
    if( g_end_identifier != NULL ) {
      return SCP(g_end_identifier);
    } else {
      return "UNKNOWN";
    }
  }
}

/* need a refcount game on the text field of the note. must keep
 * original note to avoid losing the varlist.
 */
static void ProcessNotes(int keep)
{
  int c,len;
  if (g_notelist == NULL) {
    return;
  }
  if (keep) {
    len = gl_length(g_notelist);
    for (c=1;c <= len;c++) {
      CommitNote(LibraryNote(),gl_fetch(g_notelist,c));
    }
  } else {
    gl_iterate(g_notelist,(void (*) (VOIDPTR))DestroyNote);
  }
  gl_destroy(g_notelist);
  g_notelist = NULL;
}

static void CollectNote(struct Note *n)
{
  if (g_notelist == NULL) {
    g_notelist = gl_create(50L);
  }
  if (g_notelist == NULL) {
    DestroyNote(n);
    return;
  }
  gl_append_ptr(g_notelist,(VOIDPTR)n);
}
__ZZ_SCLASS zz_tabelem zz_exca[] ={
-1, 1,
	0, -1,
	264, 60,
	274, 60,
	309, 60,
	-2, 0,
-1, 54,
	270, 77,
	284, 77,
	285, 77,
	306, 77,
	314, 77,
	41, 77,
	-2, 0,
-1, 124,
	258, 197,
	261, 197,
	262, 197,
	300, 197,
	301, 197,
	302, 197,
	339, 197,
	340, 197,
	341, 197,
	355, 197,
	44, 197,
	-2, 259,
-1, 489,
	355, 197,
	44, 197,
	59, 197,
	58, 197,
	-2, 259,
	};
# define ZZ_NPROD 300
# define ZZ_LAST 1291
__ZZ_SCLASS zz_tabelem zz_act[]={

   178,   149,   518,   339,   466,   349,   206,   344,   481,   207,
   470,   403,   471,   181,    44,    72,    71,   470,    66,   471,
   272,   393,   406,   251,   249,    53,   250,    36,   252,    36,
    37,   307,    34,   299,   418,   292,   297,   242,   325,   246,
   244,   262,   261,   263,   406,   239,   402,   203,   597,    72,
    36,    55,   586,   563,   204,    80,   167,   519,    82,    76,
    77,   167,   516,    67,   483,   459,   408,   322,   124,   184,
   326,    84,   314,    85,   300,   253,   295,   234,   233,   232,
   174,   210,   198,   169,   182,   592,   185,    78,   193,   186,
   177,    91,    82,    82,   187,   205,    90,    87,   251,   249,
    62,   250,   188,   252,    61,   259,    39,   189,   298,   215,
   123,   296,   577,   571,   600,   214,   262,   261,   263,   176,
   482,   190,   230,   336,   477,   535,   191,   213,   211,   410,
   192,   315,   194,    86,   195,   202,   589,   341,   351,   346,
   438,   593,   311,   235,   411,   432,    82,   240,   391,   426,
   253,   196,    59,    82,    82,   221,   273,    58,   224,   225,
    51,   389,   387,    75,    93,    60,   578,   247,   570,   591,
    49,   443,   251,   249,    72,   250,   335,   252,   172,   171,
   259,   342,   352,   347,   439,   293,   294,   170,   238,   433,
   262,   261,   263,   427,    70,   243,   245,   219,   222,   223,
   173,   498,   312,   313,   400,    52,   544,   598,   474,   125,
   542,   251,   249,   253,   250,    82,   252,   545,   308,    40,
   543,   321,   457,   306,   253,   309,   310,    43,   455,   262,
   261,   263,   453,   451,   449,   324,   220,   226,   227,   447,
   254,    42,   369,   525,   473,   473,   267,   268,   302,   472,
   472,   251,   301,    82,   259,   529,   252,   202,    82,   496,
    82,    79,   467,   253,   354,   355,   251,   249,   288,   250,
   580,   252,   537,   538,   564,   286,   258,   536,   495,   371,
   372,   373,   374,   375,   376,   377,   378,   379,   380,   381,
   382,   370,   531,   284,   255,   343,   474,   474,   465,   528,
   348,   464,   353,   253,   462,   461,   468,   460,   458,   260,
   398,   282,    66,   397,   392,   254,   390,   280,   253,   289,
   278,   267,   268,   396,   530,    69,   287,   264,   265,   266,
   207,   469,    66,   388,   419,   385,   405,   404,    92,    82,
   201,   384,   428,   409,   285,    65,    82,   434,    82,    36,
   422,   258,   440,    36,    36,    36,   425,    67,   405,   404,
    36,   431,   283,   423,   424,    36,   437,   562,   281,   255,
   248,   279,   319,   305,   218,   217,   200,    67,   199,   197,
   183,   414,    68,    64,   260,    57,    56,   594,   417,   254,
   420,   316,   581,   556,   168,   267,   268,   552,   548,   512,
   511,   507,   264,   265,   266,   463,   228,   229,   506,   502,
   501,   441,   435,   484,   180,   429,    26,   585,   475,   303,
   603,   490,   485,   208,   209,   258,   470,   500,   471,   596,
   489,   587,    82,   505,   504,   445,   320,   582,   444,   510,
   330,   499,   323,   255,   509,   327,   515,   566,   514,   560,
   540,   534,   493,   413,   492,   503,   415,   407,   260,   486,
   480,   508,   456,   454,   452,   450,   448,   513,   520,   143,
   446,   122,   488,   442,   491,   436,   264,   265,   266,   524,
   430,   318,   527,   526,   521,   522,   601,   479,   416,   412,
   334,   333,   317,   277,   271,    89,   166,   216,    25,   157,
    83,   158,    47,   476,    46,   532,    45,   539,    22,    14,
    13,    12,    11,    10,   546,   264,   265,   266,    35,    38,
     9,   551,     8,     7,   547,     6,   555,   549,   550,   520,
   565,   559,   553,   554,     5,     4,     3,   557,   558,    16,
    28,     2,    24,    74,   572,   236,   237,   155,    48,    82,
    82,    50,   175,    21,    20,   494,   401,    73,    63,   269,
   270,    54,    41,    31,   340,   350,   345,   573,   212,   478,
    88,   274,   275,   276,   574,    27,   497,    19,   575,    15,
   119,   290,   576,   114,   117,   121,   120,   118,   116,   583,
   584,   567,   569,   115,   588,   166,   113,   112,   157,    32,
   158,    18,   602,    29,    17,   595,   111,   110,   109,   108,
   107,   106,   105,   104,   103,   102,   101,    33,    30,   100,
    99,    98,    97,    96,    94,    81,   568,   487,   599,   251,
   249,   179,   250,   257,   252,   256,   590,   166,   579,   241,
   157,   231,   158,   328,   329,   143,   155,   262,   261,   263,
   386,   561,   523,   541,    23,   291,   399,     1,     0,     0,
     0,     0,     0,     0,   356,   357,   358,   359,   360,   361,
   362,   363,   364,   365,   366,   367,     0,     0,     0,     0,
     0,   253,     0,     0,     0,     0,   368,     0,   155,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   259,    95,     0,     0,     0,   153,     0,   394,   395,
     0,     0,     0,   134,   126,   164,     0,   165,     0,   141,
     0,   135,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   127,   152,   136,   128,     0,     0,   130,
   421,     0,     0,     0,     0,   163,     0,     0,     0,   145,
   148,   150,     0,     0,   144,     0,   156,   142,     0,     0,
     0,     0,     0,   161,     0,     0,     0,     0,   137,   129,
   159,   139,     0,   138,     0,   160,   140,     0,   151,   162,
    33,     0,   132,     0,   131,     0,     0,     0,   383,   251,
   249,   133,   250,     0,   252,     0,     0,     0,     0,   167,
   147,   146,     0,   154,     0,   153,     0,   262,   261,   263,
     0,     0,   251,   249,   164,   250,   165,   252,     0,     0,
     0,   368,     0,     0,     0,     0,     0,     0,     0,     0,
   262,   261,   263,   152,     0,     0,   254,     0,     0,     0,
     0,   253,   267,   268,   163,     0,     0,   153,   145,   148,
   150,     0,     0,   144,     0,   156,   164,     0,   165,     0,
     0,     0,   161,     0,   253,     0,     0,     0,   517,   159,
     0,   259,   258,     0,   160,   152,     0,   151,   162,     0,
     0,   332,     0,     0,     0,     0,   163,   533,     0,     0,
   255,   148,   150,     0,   259,     0,     0,   156,   167,   147,
   331,     0,   154,     0,   161,   260,     0,     0,     0,   251,
   249,   159,   250,     0,   252,     0,   160,     0,     0,   151,
   162,     0,     0,   264,   265,   266,   304,   262,   261,   263,
     0,     0,   251,   249,     0,   250,     0,   252,     0,     0,
   167,   147,   146,     0,   154,     0,     0,     0,     0,     0,
   262,   261,   263,   251,   249,     0,   250,     0,   252,     0,
     0,   253,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   262,   261,   263,   251,   249,     0,   250,     0,   252,
     0,     0,     0,     0,   253,     0,     0,     0,     0,     0,
     0,   259,   262,   261,   263,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   253,   254,     0,     0,     0,
     0,     0,   267,   268,   259,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   253,     0,     0,   254,
     0,     0,     0,     0,     0,   267,   268,     0,     0,     0,
     0,     0,   258,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   338,     0,     0,     0,     0,     0,     0,
   255,     0,     0,     0,     0,   258,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   260,     0,     0,     0,     0,
     0,     0,     0,   255,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   264,   265,   266,     0,     0,   260,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   264,   265,   266,     0,
     0,     0,     0,     0,     0,     0,   254,     0,     0,     0,
     0,     0,   267,   268,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   254,
     0,     0,     0,     0,     0,   267,   268,     0,     0,     0,
     0,     0,   258,     0,     0,     0,     0,     0,     0,     0,
   254,     0,     0,     0,     0,     0,   267,   268,     0,     0,
   255,     0,     0,     0,     0,   258,     0,     0,     0,     0,
     0,   254,     0,     0,     0,   260,     0,     0,   337,     0,
     0,     0,     0,   255,     0,     0,   258,     0,     0,     0,
     0,     0,     0,   264,   265,   266,     0,     0,   260,     0,
     0,     0,     0,     0,   255,     0,     0,   258,     0,     0,
     0,     0,     0,     0,     0,     0,   264,   265,   266,     0,
     0,     0,     0,     0,     0,   255,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   264,   265,   266,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   264,   265,
   266 };
__ZZ_SCLASS zz_tabelem zz_pact[]={

 -3000,   283, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000,
 -3000, -3000, -3000, -3000, -3000, -3000, -3000,  -326,  -328,  -249,
 -3000, -3000,  -343,  -104, -3000, -3000,   327,   326,  -154,  -141,
 -3000,  -251,  -255, -3000,   324,   286, -3000,   323,   266,   -97,
  -111,  -144,  -111,  -270,  -305, -3000, -3000, -3000,  -186,  -258,
   455,  -259,  -264,  -142,   456,  -142, -3000, -3000,  -108,  -116,
  -117, -3000,   -90,  -236, -3000, -3000,  -265,   597, -3000, -3000,
  -271,   321,  -204, -3000,   320,  -273,   319,   317,  -305,  -305,
  -309,    10, -3000,   -28,  -142,  -142,  -274,  -191,  -210, -3000,
 -3000, -3000,  -111, -3000,   316,   315, -3000, -3000, -3000, -3000,
 -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000,
 -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000,
 -3000, -3000, -3000,  -103,    64, -3000,  -276,  -277,  -278,  -305,
   597,   597,     5,  -305, -3000, -3000, -3000, -3000,  -319,     0,
    -1, -3000,  -343,   900,   597,   597,   454,  -336, -3000, -3000,
 -3000, -3000, -3000, -3000, -3000,   597,   597,   597,   597,   453,
   280,   277,   271,   253,   235,   228,   597,  -321,  -111,  -111,
  -279,  -244,  -247,  -281, -3000, -3000,   191, -3000,   155,   375,
   587, -3000,   314, -3000, -3000, -3000, -3000, -3000, -3000, -3000,
 -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000,
 -3000,  -305,  -325, -3000,  -305, -3000, -3000, -3000,  -111,  -111,
   -79,  -283,    72,   452,   440,   313, -3000, -3000, -3000,  -288,
  -288,    -2,  -285,  -288, -3000, -3000, -3000, -3000,   597,   597,
   555, -3000,   451,   450,  -119,  -221,   877,   780,  -133,  -305,
 -3000, -3000, -3000,  -131,  -305,  -132,  -305,  -111,  -270,   597,
   597,   597,   597,   597,   597,   597,   597,   597,   597,   597,
   597, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000,   900,
   900,   597, -3000,   149, -3000,   119,   119,  -305,   597,   597,
   597,   597,   597,   597,   597,   597,   597,   597,   597,   597,
   757, -3000, -3000,   282,   276,  -145,   274,  -148,   257,  -161,
   255,  -335, -3000,   597,   597, -3000,  -111, -3000, -3000,   254,
   251,   -75,     4, -3000,   -79, -3000,  -289, -3000, -3000, -3000,
 -3000,  -168,   449,  -168, -3000,  -305,  -168, -3000,   900,   900,
 -3000,   448,    -6,   597,  -305,   597,  -305, -3000, -3000,  -111,
  -121,   597,   357,   439,  -111,  -125,   597,   354,   434,  -111,
  -130,   597,   353,   432, -3000, -3000,   209,   209,   119,   119,
   119,   169,   169,   224,   942,   169,   921,   921,   130, -3000,
   394,   429,   146,   425,   141,   424,   140,   423,   139,   422,
   135,   421,   129, -3000, -3000, -3000,   249,  -290, -3000,   248,
 -3000,   246, -3000,   245,    56,   900,   242, -3000, -3000,   239,
   -26, -3000, -3000,   203, -3000, -3000,   -18,  -219,   447,   419,
  -232,  -291,   597,  -232,   418, -3000,   597,  -133,  -305,   413,
   411,   -19, -3000,   -83,  -111, -3000,   597,   352,   351, -3000,
  -133, -3000,   597,   350,   343, -3000,  -131, -3000,   597,   342,
   341, -3000,  -132, -3000,  -292, -3000, -3000, -3000, -3000, -3000,
 -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000,
 -3000, -3000, -3000,   597, -3000, -3000,  -297, -3000, -3000, -3000,
 -3000, -3000,   -18,   -18,   383,   202,  -349,   -33,   233, -3000,
 -3000, -3000,   597, -3000,   410, -3000,  -212,   218,   214, -3000,
  -111,   409, -3000, -3000,   -66, -3000, -3000,  -111, -3000, -3000,
   340, -3000, -3000, -3000,  -111,   339, -3000, -3000, -3000,  -111,
   335, -3000, -3000, -3000,  -111,   408,  -336,   900, -3000,  -336,
 -3000,   114,   114, -3000,    13, -3000,   215,  -297, -3000, -3000,
 -3000, -3000,   406,   900, -3000,  -305,  -305,  -128,  -241, -3000,
  -133, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000,
 -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000,
 -3000, -3000, -3000,  -242, -3000, -3000, -3000,  -134,   211,   334,
 -3000,   396,  -111,  -111, -3000, -3000, -3000,   370,  -303,   390,
  -305,  -179,  -126, -3000, -3000,  -269,  -171, -3000,   329, -3000,
 -3000,  -305,   388,  -307,   -70, -3000, -3000,  -238, -3000, -3000,
   446,   597,   379, -3000 };
__ZZ_SCLASS zz_tabelem zz_pgo[]={

     0,   657,   656,     2,     1,   655,    16,     4,   654,   653,
   652,   651,   129,   650,   221,   641,     6,   639,   638,    13,
   500,   636,   209,   414,   635,   633,     8,     0,   631,   628,
    55,   627,   626,   625,   624,   623,   622,   621,   620,   619,
   616,   615,   614,   613,   612,   611,   610,   609,   608,   416,
   607,   606,   597,   596,   593,   588,   587,   586,   585,   584,
   583,   580,    25,   579,   576,   570,   569,   568,     7,   566,
     5,   565,     3,   564,   227,   261,   338,   219,   562,   561,
   558,   557,   142,   556,    11,   555,   554,   553,   552,   551,
   548,   543,   542,   541,   536,   535,   534,   525,   523,   522,
   520,   513,   512,   511,   510,   509,   508,   506,   504,   503,
   502,   498,   497 };
__ZZ_SCLASS zz_tabelem zz_r1[]={

     0,     1,     1,    93,    93,    93,    93,    93,    93,    93,
    93,    93,    93,    93,    93,    93,    93,    63,    94,    94,
    94,    95,    95,    95,    96,    99,   106,    97,    86,    86,
    98,    87,    87,   101,   107,    90,     2,     2,     2,     2,
     2,   100,   108,   109,   109,   109,   109,   109,   102,   110,
   110,    89,    65,    65,    67,    67,    66,    66,   104,   111,
     8,     8,   103,    92,   105,    49,    80,    80,    88,    76,
   112,    76,    77,    78,    78,    81,    91,    62,    79,    79,
    79,    34,    34,    34,    34,    34,    34,    34,    34,    34,
    34,    34,    34,    34,    34,    34,    34,    34,    34,    34,
    34,    34,    34,    34,    34,    34,    34,    34,    35,    36,
    37,    37,    29,    29,    38,    39,    15,    15,    14,    14,
    13,    13,    12,    12,    26,    26,    40,    41,    42,    43,
    44,    44,    45,    45,    22,    22,    22,    47,    31,    32,
    18,    18,    46,    21,    21,    51,    85,    85,    85,     9,
     9,     9,     9,    52,    52,    50,    48,    53,    60,    64,
    64,    54,    54,    54,    54,    72,    73,    73,    73,    73,
    59,    59,    59,    59,    59,    55,    56,    56,    68,    69,
    69,    69,    69,    61,    61,    70,    71,    71,    71,    71,
    57,    58,    74,    74,    75,    75,    30,    33,    33,    33,
    19,    20,    20,    20,     6,     6,     6,     6,     6,     6,
     6,     6,     6,     6,     6,     6,     6,     6,    17,    17,
    16,    16,    27,    27,    28,    28,    28,    28,     3,     3,
     4,     4,     5,     5,    82,    82,    82,    83,    83,    84,
    84,    84,    84,    84,    84,    10,    11,    11,     7,     7,
     7,    23,    23,    23,    23,    23,    23,    23,    23,    23,
    23,    23,    23,    23,    23,    23,    23,    23,    23,    23,
    23,    23,    23,    23,    23,    23,    23,    23,    23,    23,
    23,    23,    23,    23,    23,    23,    23,    23,    23,    23,
    23,    23,    24,    24,    24,    24,    24,    24,    25,    25 };
__ZZ_SCLASS zz_tabelem zz_r2[]={

     0,     0,     4,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     3,    11,     7,     7,
     5,     7,     7,     5,    11,     9,    13,     9,    11,    13,
     9,    11,    13,    13,    13,     5,     1,     7,     5,     5,
     5,     5,    17,     1,     7,     5,     5,     5,    13,     9,
    15,     5,     1,     7,     1,     9,     1,     7,    11,    11,
     1,     3,    11,     5,     5,     7,     1,     5,     9,     1,
     1,     7,     3,     1,     5,    11,     5,     3,     1,     7,
     7,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,    11,    11,
     7,    25,     1,     9,     9,     7,     3,     9,     3,     9,
     1,     5,     1,     5,     1,     5,     5,     5,     5,     5,
     7,     7,     3,     7,     3,     5,     5,    19,     7,     7,
     1,     9,    19,     1,     5,    17,     1,     3,     3,     3,
     3,     3,     3,     5,     9,    11,     5,    13,    11,     1,
     5,     9,    13,    13,    17,     3,     9,     7,    11,     9,
     3,     3,     3,     3,     5,     5,     9,    13,     3,     9,
     7,    11,     9,     9,    13,     3,     9,     7,    11,     9,
     7,     7,     5,     7,     5,     7,     3,     3,     7,     5,
     5,     3,     7,     9,     5,     5,     5,     5,     5,     5,
     5,     5,     5,     5,     5,     5,     5,     3,     1,     3,
     1,     3,     3,     1,     3,     7,     7,    11,     3,     3,
     5,     5,     1,     3,     5,     3,     1,     3,     3,     3,
     3,     7,     7,     7,     7,     5,     3,    11,     1,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     7,     7,     7,     7,     7,     7,     7,     7,     5,     7,
     7,     7,     7,     7,     5,     5,    13,     9,     9,     9,
     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,
     9,     7,     3,     3,     3,     3,     3,     3,     3,     3 };
__ZZ_SCLASS zz_tabelem zz_chk[]={

 -3000,    -1,   -93,   -94,   -95,   -96,   -97,   -98,   -99,  -100,
  -101,  -102,  -103,  -104,  -105,   -63,   256,   321,   318,   294,
   -86,   -87,  -106,    -8,   -92,  -111,   -49,   292,   257,   320,
   335,   280,   316,   334,   358,   -20,   355,   358,   -20,   355,
   -77,   -78,   -77,   -74,   357,  -107,  -108,  -110,   -90,   274,
   -89,   264,   309,   -62,   -79,   -62,    59,    59,   311,   306,
   306,   355,   355,   -80,    59,    59,    46,    91,    59,    59,
   291,    -6,   285,   -81,   -91,   307,    -6,    -6,   357,   -75,
   -30,   -33,   -19,   -20,   -62,   -62,   319,   355,   -65,    40,
   355,   355,   -76,   306,   -34,   256,   -35,   -36,   -37,   -38,
   -39,   -40,   -41,   -42,   -43,   -44,   -45,   -46,   -47,   -48,
   -50,   -51,   -52,   -53,   -60,   -54,   -55,   -59,   -56,   -61,
   -57,   -58,   -49,   -30,   -19,   -22,   268,   287,   290,   323,
   293,   338,   336,   345,   267,   275,   289,   322,   327,   325,
   330,   273,   311,   -23,   308,   303,   355,   354,   304,    -4,
   305,   332,   288,   260,   357,    91,   310,    43,    45,   324,
   329,   317,   333,   299,   269,   271,    40,   353,   -76,   -62,
   295,   295,   295,   290,    -6,   -88,   355,   355,   -27,   -28,
   -23,   -19,   355,    59,   273,   290,   293,   298,   306,   311,
   325,   330,   334,   292,   336,   338,   355,    59,   355,    59,
    59,   -75,   -30,   356,    44,   -19,   -16,   358,   -76,   -76,
   355,   319,   -67,   337,   -62,    -6,  -112,    59,    59,   300,
   339,   258,   301,   302,   261,   262,   340,   341,   342,   343,
    58,   -15,   355,   355,   355,   -19,   -23,   -23,   -30,    40,
   -19,   -17,   356,   -30,    40,   -30,    40,   -62,   -74,    43,
    45,    42,    47,    94,   259,   313,   -24,   -25,   295,   124,
   328,    61,    60,    62,   346,   347,   348,   265,   266,   -23,
   -23,    40,   356,   -27,   -23,   -23,   -23,    40,    40,    91,
    40,    91,    40,    91,    40,    91,    40,    91,    40,    91,
   -23,    -5,   356,    -6,    -6,   355,   355,   280,   355,   280,
   355,    61,    93,    44,   349,    59,   -62,   356,   -19,    -6,
    -6,   -82,   281,   282,   355,    59,   319,    40,    41,    59,
   -77,   -14,   355,   -14,   -19,    40,   355,   -14,   -23,   -23,
   -22,   355,   336,    40,    40,   295,   344,   331,   283,   -72,
   -73,   270,   314,   -30,   -68,   -69,   270,   314,   -30,   -70,
   -71,   270,   314,   -30,    -6,    -6,   -23,   -23,   -23,   -23,
   -23,   -23,   -23,   -23,   -23,   -23,   -23,   -23,   -23,    93,
   -19,   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,
   -27,   -27,   -27,    41,    59,    59,   -13,   307,    59,   309,
    59,   309,    59,   356,   -23,   -23,    -6,    59,    59,    -2,
   279,   -83,    42,   -84,   355,   354,    40,   -82,   355,   -62,
   -12,   312,    40,   -12,   -30,   -12,    40,   -30,    40,   -27,
   -30,   -23,   -19,   -62,   -62,    -6,   270,   314,   -27,    58,
    41,    -6,   270,   314,   -27,    58,    41,    -6,   270,   314,
   -27,    58,    41,    41,    44,    41,    41,    93,    41,    93,
    41,    93,    41,    93,    41,    93,    41,    93,    59,   355,
    59,    59,    59,   349,    59,    59,    -7,   288,   332,   357,
    43,    45,    47,    42,    94,   -84,  -109,   343,   -66,    40,
    41,   -26,   352,   355,   -27,   -26,    41,   -31,   -30,   -19,
   -72,   -30,    41,    41,   -85,   297,   278,   -64,   284,    -6,
   -27,    58,    58,   -62,   -72,   -27,    58,    58,   -62,   -68,
   -27,    58,    58,   -62,   -70,    -4,   354,   -23,    -3,   354,
    -4,   -84,   -84,   -10,    -7,    41,   -16,    -7,   332,   288,
   357,    59,   -62,   -23,    41,   337,    59,    58,    59,    -6,
    41,    -9,   276,   286,   272,   283,    -6,   -62,    58,   -62,
   -62,    -6,    58,   -62,   -62,    -6,    58,   -62,   -62,    -6,
    41,   -11,   354,    40,    59,    -3,    41,   -30,   -32,   -30,
   296,   354,   -72,   -62,   -62,   -62,   -62,   354,   300,   -18,
    59,    58,    41,    -6,    -6,    47,   355,    41,   -19,   315,
   -21,   295,   354,   312,    58,   -19,    41,   355,   277,   -29,
   352,    40,   -27,    41 };
__ZZ_SCLASS zz_tabelem zz_def[]={

     1,    -2,     2,     3,     4,     5,     6,     7,     8,     9,
    10,    11,    12,    13,    14,    15,    16,     0,     0,     0,
    73,    73,     0,     0,    78,    78,     0,     0,     0,     0,
    61,     0,     0,    66,     0,    20,   201,     0,    23,     0,
     0,    72,     0,     0,     0,    78,    41,    78,     0,     0,
    52,     0,     0,    69,    -2,    69,    64,    78,     0,     0,
     0,    63,     0,     0,    18,    19,     0,   223,    21,    22,
     0,     0,   217,    74,     0,     0,     0,     0,     0,   192,
     0,   196,   197,   220,    69,    69,     0,     0,    54,    78,
    35,    51,     0,    70,     0,     0,    81,    82,    83,    84,
    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
    95,    96,    97,    98,    99,   100,   101,   102,   103,   104,
   105,   106,   107,     0,    -2,   132,     0,     0,     0,     0,
     0,     0,     0,     0,   170,   171,   172,   173,   218,     0,
     0,    78,     0,   134,     0,     0,   201,   251,   252,   253,
   254,   255,   256,   257,   258,   223,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   232,     0,     0,
     0,     0,     0,     0,    65,    67,     0,   202,     0,   222,
   224,   259,     0,    27,   204,   205,   206,   207,   208,   209,
   210,   211,   212,   213,   214,   215,   216,    78,    76,    30,
    25,   193,     0,   194,     0,   199,   200,   221,     0,     0,
   236,     0,     0,     0,     0,     0,    73,    79,    80,     0,
     0,     0,     0,     0,   126,   127,   128,   129,     0,     0,
     0,   156,   116,     0,     0,   153,     0,     0,     0,     0,
   175,   174,   219,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   292,   293,   294,   295,   296,   297,   298,   299,   135,
   136,     0,   231,     0,   268,   274,   275,     0,   223,   223,
   223,   223,   223,   223,   223,   223,   223,   223,   223,   223,
     0,   230,   233,     0,     0,   120,     0,     0,     0,     0,
     0,     0,   203,     0,     0,    24,     0,   195,   198,     0,
     0,    36,     0,   235,   236,    49,     0,    78,    53,    62,
    71,   122,   118,   122,   110,     0,   122,   115,   130,   131,
   133,   201,     0,   223,     0,     0,     0,    78,    78,     0,
   165,   223,     0,     0,     0,   178,   223,     0,     0,     0,
   185,   223,     0,     0,   190,   191,   261,   262,   263,   264,
   265,   266,   267,   269,   270,   271,   272,   273,     0,   260,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   291,    58,    17,     0,     0,    28,     0,
    31,     0,    59,     0,   226,   225,     0,    33,    48,     0,
   248,   234,   237,   238,   239,   240,     0,    43,    56,     0,
   124,     0,   223,   124,     0,   114,     0,     0,     0,     0,
     0,   146,   154,   159,     0,   161,   223,     0,     0,    78,
     0,   176,   223,     0,     0,    78,     0,   183,   223,     0,
     0,    78,     0,   290,     0,   277,   278,   279,   280,   281,
   282,   283,   284,   285,   286,   287,   288,   289,    26,   121,
    29,    32,    68,     0,    75,    34,     0,    38,    39,    40,
   249,   250,     0,     0,   248,     0,   220,   248,     0,    78,
    55,   108,     0,   123,     0,   109,     0,     0,     0,    -2,
     0,     0,   117,   155,     0,   147,   148,     0,    78,   158,
     0,    78,    78,   167,     0,     0,    78,    78,   180,     0,
     0,    78,    78,   187,     0,     0,     0,   227,    37,   228,
   229,   241,   242,   243,     0,   244,     0,     0,    45,    46,
    47,    50,     0,   125,   119,     0,     0,     0,     0,   162,
     0,    78,   149,   150,   151,   152,   157,   160,    78,   169,
   166,   163,    78,   182,   179,   177,    78,   189,   186,   184,
   276,   245,   246,     0,    42,    44,    57,     0,   140,     0,
   138,     0,     0,     0,   168,   181,   188,     0,     0,     0,
     0,     0,   143,   164,   145,     0,     0,   137,     0,   139,
   142,     0,     0,     0,     0,   144,   247,   112,   141,   111,
     0,   223,     0,   113 };
typedef struct { char *t_name; int t_val; } zz_toktype;
#ifndef ZZ_DEBUG
#	define ZZ_DEBUG	0	/* don't allow debugging */
#endif

#if ZZ_DEBUG

__ZZ_SCLASS zz_toktype zz_toks[] =
{
	"ADD_T",	257,
	"ALIASES_T",	258,
	"AND_T",	259,
	"ANY_T",	260,
	"AREALIKE_T",	261,
	"ARETHESAME_T",	262,
	"ARRAY_T",	263,
	"ATOM_T",	264,
	"BEQ_T",	265,
	"BNE_T",	266,
	"BREAK_T",	267,
	"CALL_T",	268,
	"CARD_T",	269,
	"CASE_T",	270,
	"CHOICE_T",	271,
	"CHECK_T",	272,
	"CONDITIONAL_T",	273,
	"CONSTANT_T",	274,
	"CONTINUE_T",	275,
	"CREATE_T",	276,
	"DATA_T",	277,
	"DECREASING_T",	278,
	"DEFAULT_T",	279,
	"DEFINITION_T",	280,
	"DIMENSION_T",	281,
	"DIMENSIONLESS_T",	282,
	"DO_T",	283,
	"ELSE_T",	284,
	"END_T",	285,
	"EXPECT_T",	286,
	"EXTERNAL_T",	287,
	"FALSE_T",	288,
	"FALLTHRU_T",	289,
	"FOR_T",	290,
	"FROM_T",	291,
	"GLOBAL_T",	292,
	"IF_T",	293,
	"IMPORT_T",	294,
	"IN_T",	295,
	"INPUT_T",	296,
	"INCREASING_T",	297,
	"INTERACTIVE_T",	298,
	"INTERSECTION_T",	299,
	"ISA_T",	300,
	"_IS_T",	301,
	"ISREFINEDTO_T",	302,
	"MAXIMIZE_T",	303,
	"MAXINTEGER_T",	304,
	"MAXREAL_T",	305,
	"METHODS_T",	306,
	"METHOD_T",	307,
	"MINIMIZE_T",	308,
	"MODEL_T",	309,
	"NOT_T",	310,
	"NOTES_T",	311,
	"OF_T",	312,
	"OR_T",	313,
	"OTHERWISE_T",	314,
	"OUTPUT_T",	315,
	"PATCH_T",	316,
	"PROD_T",	317,
	"PROVIDE_T",	318,
	"REFINES_T",	319,
	"REPLACE_T",	320,
	"REQUIRE_T",	321,
	"RETURN_T",	322,
	"RUN_T",	323,
	"SATISFIED_T",	324,
	"SELECT_T",	325,
	"SIZE_T",	326,
	"STOP_T",	327,
	"SUCHTHAT_T",	328,
	"SUM_T",	329,
	"SWITCH_T",	330,
	"THEN_T",	331,
	"TRUE_T",	332,
	"UNION_T",	333,
	"UNITS_T",	334,
	"UNIVERSAL_T",	335,
	"WHEN_T",	336,
	"WHERE_T",	337,
	"WHILE_T",	338,
	"WILLBE_T",	339,
	"WILLBETHESAME_T",	340,
	"WILLNOTBETHESAME_T",	341,
	"ASSIGN_T",	342,
	"CASSIGN_T",	343,
	"DBLCOLON_T",	344,
	"USE_T",	345,
	"LEQ_T",	346,
	"GEQ_T",	347,
	"NEQ_T",	348,
	"DOTDOT_T",	349,
	"WITH_T",	350,
	"VALUE_T",	351,
	"WITH_VALUE_T",	352,
	"REAL_T",	353,
	"INTEGER_T",	354,
	"IDENTIFIER_T",	355,
	"BRACEDTEXT_T",	356,
	"SYMBOL_T",	357,
	"DQUOTE_T",	358,
	",",	44,
	"|",	124,
	"<",	60,
	"=",	61,
	">",	62,
	"+",	43,
	"-",	45,
	"/",	47,
	"*",	42,
	"UMINUS_T",	359,
	"UPLUS_T",	360,
	"^",	94,
	"-unknown-",	-1	/* ends search */
};

__ZZ_SCLASS char * zz_reds[] =
{
	"-no such reduction-",
	"definitions : /* empty */",
	"definitions : definitions definition",
	"definition : require_file",
	"definition : provide_module",
	"definition : import",
	"definition : add_method_def",
	"definition : replace_method_def",
	"definition : add_notes_def",
	"definition : constant_def",
	"definition : atom_def",
	"definition : model_def",
	"definition : definition_def",
	"definition : patch_def",
	"definition : units_def",
	"definition : global_def",
	"definition : error",
	"global_def : GLOBAL_T ';' fstatements end ';'",
	"require_file : REQUIRE_T DQUOTE_T ';'",
	"require_file : REQUIRE_T name ';'",
	"require_file : REQUIRE_T name",
	"provide_module : PROVIDE_T DQUOTE_T ';'",
	"provide_module : PROVIDE_T name ';'",
	"provide_module : PROVIDE_T name",
	"import : IMPORT_T IDENTIFIER_T FROM_T IDENTIFIER_T ';'",
	"add_notes_def : add_notes_head notes_body end ';'",
	"add_notes_head : ADD_T NOTES_T IN_T IDENTIFIER_T optional_method ';'",
	"add_method_def : add_method_head proclist end ';'",
	"add_method_head : ADD_T METHODS_T IN_T IDENTIFIER_T ';'",
	"add_method_head : ADD_T METHODS_T IN_T DEFINITION_T MODEL_T ';'",
	"replace_method_def : replace_method_head proclist end ';'",
	"replace_method_head : REPLACE_T METHODS_T IN_T IDENTIFIER_T ';'",
	"replace_method_head : REPLACE_T METHODS_T IN_T DEFINITION_T MODEL_T ';'",
	"atom_def : universal atom_head fstatements methods end ';'",
	"atom_head : atom_id REFINES_T IDENTIFIER_T dims default_val ';'",
	"atom_id : ATOM_T IDENTIFIER_T",
	"default_val : /* empty */",
	"default_val : DEFAULT_T optional_sign number",
	"default_val : DEFAULT_T FALSE_T",
	"default_val : DEFAULT_T TRUE_T",
	"default_val : DEFAULT_T SYMBOL_T",
	"constant_def : universal constant_head",
	"constant_head : CONSTANT_T IDENTIFIER_T REFINES_T IDENTIFIER_T dims constant_val optional_notes ';'",
	"constant_val : /* empty */",
	"constant_val : CASSIGN_T optional_sign number",
	"constant_val : CASSIGN_T TRUE_T",
	"constant_val : CASSIGN_T FALSE_T",
	"constant_val : CASSIGN_T SYMBOL_T",
	"model_def : universal model_head fstatements methods end ';'",
	"model_head : model_id optional_model_parameters optional_parameter_wheres ';'",
	"model_head : model_id optional_model_parameters optional_parameter_wheres REFINES_T IDENTIFIER_T optional_parameter_reduction ';'",
	"model_id : MODEL_T IDENTIFIER_T",
	"optional_model_parameters : /* empty */",
	"optional_model_parameters : '(' fstatements ')'",
	"optional_parameter_wheres : /* empty */",
	"optional_parameter_wheres : WHERE_T '(' fstatements ')'",
	"optional_parameter_reduction : /* empty */",
	"optional_parameter_reduction : '(' fstatements ')'",
	"patch_def : patch_head fstatements methods end ';'",
	"patch_head : PATCH_T IDENTIFIER_T FOR_T IDENTIFIER_T ';'",
	"universal : /* empty */",
	"universal : UNIVERSAL_T",
	"definition_def : definition_id fstatements methods end ';'",
	"definition_id : DEFINITION_T IDENTIFIER_T",
	"units_def : units_statement ';'",
	"units_statement : UNITS_T unitdeflist end",
	"unitdeflist : /* empty */",
	"unitdeflist : unitdeflist unitdef",
	"unitdef : IDENTIFIER_T '=' BRACEDTEXT_T ';'",
	"methods : /* empty */",
	"methods : METHODS_T",
	"methods : METHODS_T proclist",
	"proclist : proclistf",
	"proclistf : /* empty */",
	"proclistf : proclistf procedure",
	"procedure : procedure_id ';' fstatements end ';'",
	"procedure_id : METHOD_T IDENTIFIER_T",
	"fstatements : statements",
	"statements : /* empty */",
	"statements : statements statement ';'",
	"statements : statements error ';'",
	"statement : isa_statement",
	"statement : willbe_statement",
	"statement : aliases_statement",
	"statement : is_statement",
	"statement : isrefinedto_statement",
	"statement : arealike_statement",
	"statement : arethesame_statement",
	"statement : willbethesame_statement",
	"statement : willnotbethesame_statement",
	"statement : assignment_statement",
	"statement : relation_statement",
	"statement : glassbox_statement",
	"statement : blackbox_statement",
	"statement : call_statement",
	"statement : external_statement",
	"statement : for_statement",
	"statement : run_statement",
	"statement : if_statement",
	"statement : while_statement",
	"statement : when_statement",
	"statement : use_statement",
	"statement : flow_statement",
	"statement : select_statement",
	"statement : switch_statement",
	"statement : conditional_statement",
	"statement : notes_statement",
	"statement : units_statement",
	"isa_statement : fvarlist ISA_T type_identifier optional_of optional_with_value",
	"willbe_statement : fvarlist WILLBE_T type_identifier optional_of optional_with_value",
	"aliases_statement : fvarlist ALIASES_T fname",
	"aliases_statement : fvarlist ALIASES_T '(' fvarlist ')' WHERE_T fvarlist ISA_T IDENTIFIER_T OF_T IDENTIFIER_T optional_set_values",
	"optional_set_values : /* empty */",
	"optional_set_values : WITH_VALUE_T '(' set ')'",
	"is_statement : fvarlist _IS_T IDENTIFIER_T optional_of",
	"isrefinedto_statement : fvarlist ISREFINEDTO_T type_identifier",
	"call_identifier : IDENTIFIER_T",
	"call_identifier : IDENTIFIER_T '(' set ')'",
	"type_identifier : IDENTIFIER_T",
	"type_identifier : IDENTIFIER_T '(' set ')'",
	"optional_method : /* empty */",
	"optional_method : METHOD_T IDENTIFIER_T",
	"optional_of : /* empty */",
	"optional_of : OF_T IDENTIFIER_T",
	"optional_with_value : /* empty */",
	"optional_with_value : WITH_VALUE_T expr",
	"arealike_statement : fvarlist AREALIKE_T",
	"arethesame_statement : fvarlist ARETHESAME_T",
	"willbethesame_statement : fvarlist WILLBETHESAME_T",
	"willnotbethesame_statement : fvarlist WILLNOTBETHESAME_T",
	"assignment_statement : fname ASSIGN_T expr",
	"assignment_statement : fname CASSIGN_T expr",
	"relation_statement : relation",
	"relation_statement : fname ':' relation",
	"relation : expr",
	"relation : MINIMIZE_T expr",
	"relation : MAXIMIZE_T expr",
	"blackbox_statement : fname ':' IDENTIFIER_T '(' input_args ';' output_args data_args ')'",
	"input_args : fvarlist ':' INPUT_T",
	"output_args : fvarlist ':' OUTPUT_T",
	"data_args : /* empty */",
	"data_args : ';' fname ':' DATA_T",
	"glassbox_statement : fname ':' IDENTIFIER_T '(' fvarlist ';' INTEGER_T ')' optional_scope",
	"optional_scope : /* empty */",
	"optional_scope : IN_T fname",
	"for_statement : FOR_T IDENTIFIER_T IN_T expr optional_direction forexprend fstatements end",
	"optional_direction : /* empty */",
	"optional_direction : INCREASING_T",
	"optional_direction : DECREASING_T",
	"forexprend : CREATE_T",
	"forexprend : EXPECT_T",
	"forexprend : CHECK_T",
	"forexprend : DO_T",
	"run_statement : RUN_T fname",
	"run_statement : RUN_T fname DBLCOLON_T fname",
	"external_statement : EXTERNAL_T IDENTIFIER_T '(' fvarlist ')'",
	"call_statement : CALL_T call_identifier",
	"if_statement : IF_T expr THEN_T fstatements optional_else end",
	"while_statement : WHILE_T expr DO_T fstatements end",
	"optional_else : /* empty */",
	"optional_else : ELSE_T fstatements",
	"when_statement : WHEN_T fvarlist whenlist end",
	"when_statement : fname ':' WHEN_T fvarlist whenlist end",
	"when_statement : WHEN_T '(' fvarlist ')' whenlist end",
	"when_statement : fname ':' WHEN_T '(' fvarlist ')' whenlist end",
	"whenlist : whenlistf",
	"whenlistf : CASE_T set ':' fstatements",
	"whenlistf : OTHERWISE_T ':' fstatements",
	"whenlistf : whenlistf CASE_T set ':' fstatements",
	"whenlistf : whenlistf OTHERWISE_T ':' fstatements",
	"flow_statement : BREAK_T",
	"flow_statement : CONTINUE_T",
	"flow_statement : FALLTHRU_T",
	"flow_statement : RETURN_T",
	"flow_statement : STOP_T optional_bracedtext",
	"use_statement : USE_T fname",
	"select_statement : SELECT_T fvarlist selectlist end",
	"select_statement : SELECT_T '(' fvarlist ')' selectlist end",
	"selectlist : selectlistf",
	"selectlistf : CASE_T set ':' fstatements",
	"selectlistf : OTHERWISE_T ':' fstatements",
	"selectlistf : selectlistf CASE_T set ':' fstatements",
	"selectlistf : selectlistf OTHERWISE_T ':' fstatements",
	"switch_statement : SWITCH_T fvarlist switchlist end",
	"switch_statement : SWITCH_T '(' fvarlist ')' switchlist end",
	"switchlist : switchlistf",
	"switchlistf : CASE_T set ':' fstatements",
	"switchlistf : OTHERWISE_T ':' fstatements",
	"switchlistf : switchlistf CASE_T set ':' fstatements",
	"switchlistf : switchlistf OTHERWISE_T ':' fstatements",
	"conditional_statement : CONDITIONAL_T fstatements end",
	"notes_statement : NOTES_T notes_body end",
	"notes_body : SYMBOL_T noteslist",
	"notes_body : notes_body SYMBOL_T noteslist",
	"noteslist : fvarlist BRACEDTEXT_T",
	"noteslist : noteslist fvarlist BRACEDTEXT_T",
	"fvarlist : varlist",
	"varlist : fname",
	"varlist : varlist ',' fname",
	"varlist : varlist fname",
	"fname : name optional_notes",
	"name : IDENTIFIER_T",
	"name : name '.' IDENTIFIER_T",
	"name : name '[' set ']'",
	"end : END_T CONDITIONAL_T",
	"end : END_T FOR_T",
	"end : END_T IF_T",
	"end : END_T INTERACTIVE_T",
	"end : END_T METHODS_T",
	"end : END_T NOTES_T",
	"end : END_T SELECT_T",
	"end : END_T SWITCH_T",
	"end : END_T UNITS_T",
	"end : END_T GLOBAL_T",
	"end : END_T WHEN_T",
	"end : END_T WHILE_T",
	"end : END_T IDENTIFIER_T",
	"end : END_T",
	"optional_bracedtext : /* empty */",
	"optional_bracedtext : BRACEDTEXT_T",
	"optional_notes : /* empty */",
	"optional_notes : DQUOTE_T",
	"set : setexprlist",
	"set : /* empty */",
	"setexprlist : expr",
	"setexprlist : expr DOTDOT_T expr",
	"setexprlist : setexprlist ',' expr",
	"setexprlist : setexprlist ',' expr DOTDOT_T expr",
	"number : INTEGER_T",
	"number : realnumber",
	"realnumber : REAL_T opunits",
	"realnumber : INTEGER_T BRACEDTEXT_T",
	"opunits : /* empty */",
	"opunits : BRACEDTEXT_T",
	"dims : DIMENSION_T dimensions",
	"dims : DIMENSIONLESS_T",
	"dims : /* empty */",
	"dimensions : '*'",
	"dimensions : dimexpr",
	"dimexpr : IDENTIFIER_T",
	"dimexpr : INTEGER_T",
	"dimexpr : dimexpr '/' dimexpr",
	"dimexpr : dimexpr '*' dimexpr",
	"dimexpr : dimexpr '^' fraction",
	"dimexpr : '(' dimexpr ')'",
	"fraction : optional_sign fractail",
	"fractail : INTEGER_T",
	"fractail : '(' INTEGER_T '/' INTEGER_T ')'",
	"optional_sign : /* empty */",
	"optional_sign : '+'",
	"optional_sign : '-'",
	"expr : INTEGER_T",
	"expr : MAXINTEGER_T",
	"expr : realnumber",
	"expr : MAXREAL_T",
	"expr : TRUE_T",
	"expr : FALSE_T",
	"expr : ANY_T",
	"expr : SYMBOL_T",
	"expr : fname",
	"expr : '[' set ']'",
	"expr : expr '+' expr",
	"expr : expr '-' expr",
	"expr : expr '*' expr",
	"expr : expr '/' expr",
	"expr : expr '^' expr",
	"expr : expr AND_T expr",
	"expr : expr OR_T expr",
	"expr : NOT_T expr",
	"expr : expr relop expr",
	"expr : expr logrelop expr",
	"expr : expr IN_T expr",
	"expr : expr '|' expr",
	"expr : expr SUCHTHAT_T expr",
	"expr : '+' expr",
	"expr : '-' expr",
	"expr : SATISFIED_T '(' fname ',' realnumber ')'",
	"expr : SATISFIED_T '(' fname ')'",
	"expr : SUM_T '(' set ')'",
	"expr : SUM_T '[' set ']'",
	"expr : PROD_T '(' set ')'",
	"expr : PROD_T '[' set ']'",
	"expr : UNION_T '(' set ')'",
	"expr : UNION_T '[' set ']'",
	"expr : INTERSECTION_T '(' set ')'",
	"expr : INTERSECTION_T '[' set ']'",
	"expr : CARD_T '(' set ')'",
	"expr : CARD_T '[' set ']'",
	"expr : CHOICE_T '(' set ')'",
	"expr : CHOICE_T '[' set ']'",
	"expr : IDENTIFIER_T '(' expr ')'",
	"expr : '(' expr ')'",
	"relop : '='",
	"relop : '<'",
	"relop : '>'",
	"relop : LEQ_T",
	"relop : GEQ_T",
	"relop : NEQ_T",
	"logrelop : BEQ_T",
	"logrelop : BNE_T",
};
#endif /* ZZ_DEBUG */
#define ZZ_FLAG  (-3000)
/* @(#) $Revision: 1.10 $ */    

/*
** Skeleton parser driver for yacc output
*/

#if defined(NLS) && !defined(NL_SETN)
#include <msgbuf.h>
#endif

#ifndef nl_msg
#define nl_msg(i,s) (s)
#endif

/*
** yacc user known macros and defines
*/
#define ZZ_ERROR		goto zz_errlab

#ifndef __RUNTIME_ZZ_MAXDEPTH
#define ZZ_ACCEPT	return(0)
#define ZZ_ABORT		return(1)
#else
#define ZZ_ACCEPT	{free_stacks(); return(0);}
#define ZZ_ABORT		{free_stacks(); return(1);}
#endif

#define ZZ_BACKUP( newtoken, newvalue )\
{\
	if ( zz_char >= 0 || ( zz_r2[ zz_tmp ] >> 1 ) != 1 )\
	{\
		zz_error( (nl_msg(30001,"syntax error - cannot backup")) );\
		goto zz_errlab;\
	}\
	zz_char = newtoken;\
	zz_state = *zz_ps;\
	zz_lval = newvalue;\
	goto zz_newstate;\
}
#define ZZ_RECOVERING()	(!!zz_errflag)
#ifndef ZZ_DEBUG
#	define ZZ_DEBUG	1	/* make debugging available */
#endif

/*
** user known globals
*/
int zz_debug;			/* set to 1 to get debugging */

/*
** driver internal defines
*/
/* define for ZZ_FLAG now generated by yacc program. */
/*#define ZZ_FLAG		(FLAGVAL)*/

/*
** global variables used by the parser
*/
# ifndef __RUNTIME_ZZ_MAXDEPTH
__ZZ_SCLASS ZZ_STYPE zz_v[ ZZ_MAXDEPTH ];	/* value stack */
__ZZ_SCLASS int zz_s[ ZZ_MAXDEPTH ];		/* state stack */
# else
__ZZ_SCLASS ZZ_STYPE *zz_v;			/* pointer to malloc'ed value stack */
__ZZ_SCLASS int *zz_s;			/* pointer to malloc'ed stack stack */

#if defined(__STDC__) || defined (__cplusplus)
#include <stdlib.h>
#else
	extern char *malloc();
	extern char *realloc();
	extern void free();
#endif /* __STDC__ or __cplusplus */


static int allocate_stacks(); 
static void free_stacks();
# ifndef ZZ_INCREMENT
# define ZZ_INCREMENT (ZZ_MAXDEPTH/2) + 10
# endif
# endif	/* __RUNTIME_ZZ_MAXDEPTH */
long  zz_maxdepth = ZZ_MAXDEPTH;

__ZZ_SCLASS ZZ_STYPE *zz_pv;			/* top of value stack */
__ZZ_SCLASS int *zz_ps;			/* top of state stack */

__ZZ_SCLASS int zz_state;			/* current state */
__ZZ_SCLASS int zz_tmp;			/* extra var (lasts between blocks) */

int zz_nerrs;			/* number of errors */
__ZZ_SCLASS int zz_errflag;			/* error recovery flag */
int zz_char;			/* current input token number */



/*
** zz_parse - return 0 if worked, 1 if syntax error not recovered from
*/
int
zz_parse()
{
	register ZZ_STYPE *zz_pvt;	/* top of value stack for $vars */

	/*
	** Initialize externals - zz_parse may be called more than once
	*/
# ifdef __RUNTIME_ZZ_MAXDEPTH
	if (allocate_stacks()) ZZ_ABORT;
# endif
	zz_pv = &zz_v[-1];
	zz_ps = &zz_s[-1];
	zz_state = 0;
	zz_tmp = 0;
	zz_nerrs = 0;
	zz_errflag = 0;
	zz_char = -1;

	goto zz_stack;
	{
		register ZZ_STYPE *zz__pv;	/* top of value stack */
		register int *zz__ps;		/* top of state stack */
		register int zz__state;		/* current state */
		register int  zz__n;		/* internal state number info */

		/*
		** get globals into registers.
		** branch to here only if ZZ_BACKUP was called.
		*/
	zz_newstate:
		zz__pv = zz_pv;
		zz__ps = zz_ps;
		zz__state = zz_state;
		goto zz__newstate;

		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
	zz_stack:
		zz__pv = zz_pv;
		zz__ps = zz_ps;
		zz__state = zz_state;

		/*
		** top of for (;;) loop while no reductions done
		*/
	zz__stack:
		/*
		** put a state and value onto the stacks
		*/
#if ZZ_DEBUG
		/*
		** if debugging, look up token value in list of value vs.
		** name pairs.  0 and negative (-1) are special values.
		** Note: linear search is used since time is not a real
		** consideration while debugging.
		*/
		if ( zz_debug )
		{
			register int zz__i;

			printf( "State %d, token ", zz__state );
			if ( zz_char == 0 )
				printf( "end-of-file\n" );
			else if ( zz_char < 0 )
				printf( "-none-\n" );
			else
			{
				for ( zz__i = 0; zz_toks[zz__i].t_val >= 0;
					zz__i++ )
				{
					if ( zz_toks[zz__i].t_val == zz_char )
						break;
				}
				printf( "%s\n", zz_toks[zz__i].t_name );
			}
		}
#endif /* ZZ_DEBUG */
		if ( ++zz__ps >= &zz_s[ zz_maxdepth ] )	/* room on stack? */
		{
# ifndef __RUNTIME_ZZ_MAXDEPTH
			zz_error( (nl_msg(30002,"yacc stack overflow")) );
			ZZ_ABORT;
# else
			/* save old stack bases to recalculate pointers */
			ZZ_STYPE * zz_v_old = zz_v;
			int * zz_s_old = zz_s;
			zz_maxdepth += ZZ_INCREMENT;
			zz_s = (int *) realloc(zz_s, zz_maxdepth * sizeof(int));
			zz_v = (ZZ_STYPE *) realloc(zz_v, zz_maxdepth * sizeof(ZZ_STYPE));
			if (zz_s==0 || zz_v==0) {
			    zz_error( (nl_msg(30002,"yacc stack overflow")) );
			    ZZ_ABORT;
			    }
			/* Reset pointers into stack */
			zz__ps = (zz__ps - zz_s_old) + zz_s;
			zz_ps = (zz_ps - zz_s_old) + zz_s;
			zz__pv = (zz__pv - zz_v_old) + zz_v;
			zz_pv = (zz_pv - zz_v_old) + zz_v;
# endif

		}
		*zz__ps = zz__state;
		*++zz__pv = zz_val;

		/*
		** we have a new state - find out what to do
		*/
	zz__newstate:
		if ( ( zz__n = zz_pact[ zz__state ] ) <= ZZ_FLAG )
			goto zz_default;		/* simple state */
#if ZZ_DEBUG
		/*
		** if debugging, need to mark whether new token grabbed
		*/
		zz_tmp = zz_char < 0;
#endif
		if ( ( zz_char < 0 ) && ( ( zz_char = zz_lex() ) < 0 ) )
			zz_char = 0;		/* reached EOF */
#if ZZ_DEBUG
		if ( zz_debug && zz_tmp )
		{
			register int zz__i;

			printf( "Received token " );
			if ( zz_char == 0 )
				printf( "end-of-file\n" );
			else if ( zz_char < 0 )
				printf( "-none-\n" );
			else
			{
				for ( zz__i = 0; zz_toks[zz__i].t_val >= 0;
					zz__i++ )
				{
					if ( zz_toks[zz__i].t_val == zz_char )
						break;
				}
				printf( "%s\n", zz_toks[zz__i].t_name );
			}
		}
#endif /* ZZ_DEBUG */
		if ( ( ( zz__n += zz_char ) < 0 ) || ( zz__n >= ZZ_LAST ) )
			goto zz_default;
		if ( zz_chk[ zz__n = zz_act[ zz__n ] ] == zz_char )	/*valid shift*/
		{
			zz_char = -1;
			zz_val = zz_lval;
			zz__state = zz__n;
			if ( zz_errflag > 0 )
				zz_errflag--;
			goto zz__stack;
		}

	zz_default:
		if ( ( zz__n = zz_def[ zz__state ] ) == -2 )
		{
#if ZZ_DEBUG
			zz_tmp = zz_char < 0;
#endif
			if ( ( zz_char < 0 ) && ( ( zz_char = zz_lex() ) < 0 ) )
				zz_char = 0;		/* reached EOF */
#if ZZ_DEBUG
			if ( zz_debug && zz_tmp )
			{
				register int zz__i;

				printf( "Received token " );
				if ( zz_char == 0 )
					printf( "end-of-file\n" );
				else if ( zz_char < 0 )
					printf( "-none-\n" );
				else
				{
					for ( zz__i = 0;
						zz_toks[zz__i].t_val >= 0;
						zz__i++ )
					{
						if ( zz_toks[zz__i].t_val
							== zz_char )
						{
							break;
						}
					}
					printf( "%s\n", zz_toks[zz__i].t_name );
				}
			}
#endif /* ZZ_DEBUG */
			/*
			** look through exception table
			*/
			{
				register int *zz_xi = zz_exca;

				while ( ( *zz_xi != -1 ) ||
					( zz_xi[1] != zz__state ) )
				{
					zz_xi += 2;
				}
				while ( ( *(zz_xi += 2) >= 0 ) &&
					( *zz_xi != zz_char ) )
					;
				if ( ( zz__n = zz_xi[1] ) < 0 )
					ZZ_ACCEPT;
			}
		}

		/*
		** check for syntax error
		*/
		if ( zz__n == 0 )	/* have an error */
		{
			/* no worry about speed here! */
			switch ( zz_errflag )
			{
			case 0:		/* new error */
				zz_error( (nl_msg(30003,"syntax error")) );
				zz_nerrs++;
				goto skip_init;
			zz_errlab:
				/*
				** get globals into registers.
				** we have a user generated syntax type error
				*/
				zz__pv = zz_pv;
				zz__ps = zz_ps;
				zz__state = zz_state;
				zz_nerrs++;
			skip_init:
			case 1:
			case 2:		/* incompletely recovered error */
					/* try again... */
				zz_errflag = 3;
				/*
				** find state where "error" is a legal
				** shift action
				*/
				while ( zz__ps >= zz_s )
				{
					zz__n = zz_pact[ *zz__ps ] + ZZ_ERRCODE;
					if ( zz__n >= 0 && zz__n < ZZ_LAST &&
						zz_chk[zz_act[zz__n]] == ZZ_ERRCODE)					{
						/*
						** simulate shift of "error"
						*/
						zz__state = zz_act[ zz__n ];
						goto zz__stack;
					}
					/*
					** current state has no shift on
					** "error", pop stack
					*/
#if ZZ_DEBUG
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
					if ( zz_debug )
						printf( _POP_, *zz__ps,
							zz__ps[-1] );
#	undef _POP_
#endif
					zz__ps--;
					zz__pv--;
				}
				/*
				** there is no state on stack with "error" as
				** a valid shift.  give up.
				*/
				ZZ_ABORT;
			case 3:		/* no shift yet; eat a token */
#if ZZ_DEBUG
				/*
				** if debugging, look up token in list of
				** pairs.  0 and negative shouldn't occur,
				** but since timing doesn't matter when
				** debugging, it doesn't hurt to leave the
				** tests here.
				*/
				if ( zz_debug )
				{
					register int zz__i;

					printf( "Error recovery discards " );
					if ( zz_char == 0 )
						printf( "token end-of-file\n" );
					else if ( zz_char < 0 )
						printf( "token -none-\n" );
					else
					{
						for ( zz__i = 0;
							zz_toks[zz__i].t_val >= 0;
							zz__i++ )
						{
							if ( zz_toks[zz__i].t_val
								== zz_char )
							{
								break;
							}
						}
						printf( "token %s\n",
							zz_toks[zz__i].t_name );
					}
				}
#endif /* ZZ_DEBUG */
				if ( zz_char == 0 )	/* reached EOF. quit */
					ZZ_ABORT;
				zz_char = -1;
				goto zz__newstate;
			}
		}/* end if ( zz__n == 0 ) */
		/*
		** reduction by production zz__n
		** put stack tops, etc. so things right after switch
		*/
#if ZZ_DEBUG
		/*
		** if debugging, print the string that is the user's
		** specification of the reduction which is just about
		** to be done.
		*/
		if ( zz_debug )
			printf( "Reduce by (%d) \"%s\"\n",
				zz__n, zz_reds[ zz__n ] );
#endif
		zz_tmp = zz__n;			/* value to switch over */
		zz_pvt = zz__pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using zz__state here as temporary
		** register variable, but why not, if it works...
		** If zz_r2[ zz__n ] doesn't have the low order bit
		** set, then there is no action to be done for
		** this reduction.  So, no saving & unsaving of
		** registers done.  The only difference between the
		** code just after the if and the body of the if is
		** the goto zz__stack in the body.  This way the test
		** can be made before the choice of what to do is needed.
		*/
		{
			/* length of production doubled with extra bit */
			register int zz__len = zz_r2[ zz__n ];

			if ( !( zz__len & 01 ) )
			{
				zz__len >>= 1;
				zz_val = ( zz__pv -= zz__len )[1];	/* $$ = $1 */
				zz__state = zz_pgo[ zz__n = zz_r1[ zz__n ] ] +
					*( zz__ps -= zz__len ) + 1;
				if ( zz__state >= ZZ_LAST ||
					zz_chk[ zz__state =
					zz_act[ zz__state ] ] != -zz__n )
				{
					zz__state = zz_act[ zz_pgo[ zz__n ] ];
				}
				goto zz__stack;
			}
			zz__len >>= 1;
			zz_val = ( zz__pv -= zz__len )[1];	/* $$ = $1 */
			zz__state = zz_pgo[ zz__n = zz_r1[ zz__n ] ] +
				*( zz__ps -= zz__len ) + 1;
			if ( zz__state >= ZZ_LAST ||
				zz_chk[ zz__state = zz_act[ zz__state ] ] != -zz__n )
			{
				zz__state = zz_act[ zz_pgo[ zz__n ] ];
			}
		}
					/* save until reenter driver code */
		zz_state = zz__state;
		zz_ps = zz__ps;
		zz_pv = zz__pv;
	}
	/*
	** code supplied by user is placed in this switch
	*/
	switch( zz_tmp )
	{
		
case 16:
/* # line 427 "ascParse.y" */
{
	  ErrMsg_Generic("Error in definition ");
	} break;
case 17:
/* # line 434 "ascParse.y" */
{
          /* the following steps apply to string buffers only, not files */
	  struct gl_list_t *stats;
          int dispose;
	  if (zz_pvt[-2].slptr != NULL) {
	    stats = gl_create(1L);
	    gl_append_ptr(stats,(void *)zz_pvt[-2].slptr);
	    if (g_untrapped_error) {
	      ErrMsg_Generic("Because of a syntax error, the "
               "following statements are being ignored:");
		WriteStatementList(ASCERR,zz_pvt[-2].slptr,4);
	      DestroyStatementList(zz_pvt[-2].slptr);
            } else {
	      dispose = Asc_ModuleAddStatements(Asc_CurrentModule(),stats);
              switch (dispose) {
              case 1: /* appended */
	        if (stats != NULL) {
	          gl_destroy(stats);
	        }
	        break;
              case 0: /* kept */
	        break;
              case -1: /* illegal in file */
	        ErrMsg_Generic("GLOBAL statements can only be made "
                 "interactively. Ignoring ");
	        if (stats != NULL) {
		  WriteStatementList(ASCERR,zz_pvt[-2].slptr,4);
	          gl_iterate(stats,(DestroyFunc)DestroyStatementList);
	          gl_destroy(stats);
	        }
	        break;
              default:
	        break;
              }
            }
	  }
	  /* don't let any bizarreness in string parsing hang around */
	  g_type_name = g_refines_name = g_proc_name = NULL;
	  g_model_parameters =
	    g_parameter_reduction =
	    g_parameter_wheres = NULL;
	  g_untrapped_error = 0;
	} break;
case 18:
/* # line 481 "ascParse.y" */
{
	  Asc_ScannerPushBuffer(zz_pvt[-1].dquote_ptr);
	} break;
case 19:
/* # line 485 "ascParse.y" */
{
	  DestroyName(zz_pvt[-1].nptr);
	  ErrMsg_Generic("REQUIRE statement syntax is "
	                 "``REQUIRE \"filename\";'' ");
	} break;
case 20:
/* # line 491 "ascParse.y" */
{
	  DestroyName(zz_pvt[-0].nptr);
	  ErrMsg_Generic("REQUIRE statement syntax is "
	                 "``REQUIRE \"filename\";'' ");
	} break;
case 21:
/* # line 500 "ascParse.y" */
{
          Asc_ModuleCreateAlias(Asc_CurrentModule(),zz_pvt[-1].dquote_ptr);
        } break;
case 22:
/* # line 504 "ascParse.y" */
{
	  DestroyName(zz_pvt[-1].nptr);
	  ErrMsg_Generic("PROVIDE statement syntax is "
	                 "``PROVIDE \"filename\";'' ");
	} break;
case 23:
/* # line 510 "ascParse.y" */
{
	  DestroyName(zz_pvt[-0].nptr);
	  ErrMsg_Generic("PROVIDE statement syntax is "
	                 "``PROVIDE \"filename\";'' ");
	} break;
case 24:
/* # line 519 "ascParse.y" */
{
	  symchar *path;
	  path = MakeArchiveLibraryName(SCP(zz_pvt[-1].id_ptr));
	  (void)LoadArchiveLibrary(SCP(path),SCP(zz_pvt[-3].id_ptr));
	} break;
case 25:
/* # line 528 "ascParse.y" */
{
	  /*  see comments for notes statement.  */
	  if( zz_pvt[-1].int_value != NOTES_T ) {
	    WarnMsg_MismatchEnd("NOTES", NULL, zz_pvt[-1].int_value, NULL);
	  }
	  if (zz_pvt[-2].notesptr != NULL) {
	    struct NoteTmp *nt;
	    symchar *lang=NULL; /* dummy */
	    nt = zz_pvt[-2].notesptr;
	    while (nt != NULL) {
	      if (nt->lang != NULL) {
	        lang = nt->lang;
	      }
	      /* save exploding vardata to simple entries until we keep */
	      CollectNote(CreateNote(g_type_name, lang, NULL, g_proc_name,
	                             Asc_ModuleBestName(Asc_CurrentModule()),
	                             nt->bt,
	                             nt->line, nt->vardata, nd_vlist));
	      nt = nt->next;
	    }
	    /* now keep them */
	    ProcessNotes(1);
	    DestroyNoteTmpList(zz_pvt[-2].notesptr);
          }
          g_type_name = g_proc_name = NULL;
	  g_untrapped_error = 0;
	} break;
case 26:
/* # line 559 "ascParse.y" */
{
	  g_type_name = zz_pvt[-2].id_ptr;
	  g_proc_name = zz_pvt[-1].id_ptr;
	} break;
case 27:
/* # line 567 "ascParse.y" */
{
	  if (zz_pvt[-3].tptr == NULL) {
	    DestroyProcedureList(zz_pvt[-2].listp);
	  } else {
	    if( zz_pvt[-1].int_value != METHODS_T ) {
	      WarnMsg_MismatchEnd("ADD METHODS", NULL, zz_pvt[-1].int_value, "METHODS");
	    }
	    if (AddMethods(zz_pvt[-3].tptr,zz_pvt[-2].listp,g_untrapped_error) != 0) {
	      if (zz_pvt[-3].tptr != ILLEGAL_DEFINITION) {
                ErrMsg_ProcsRejected("ADD",SCP(GetName(zz_pvt[-3].tptr)));
	        DestroyProcedureList(zz_pvt[-2].listp);
	      } /* else adding in DEFINITION MODEL may have misgone */
	    }
	  }
	  g_untrapped_error = 0;
	} break;
case 28:
/* # line 587 "ascParse.y" */
{
	  struct TypeDescription *tmptype;
	  tmptype = FindType(zz_pvt[-1].id_ptr);
	  if (tmptype == NULL) {
            ErrMsg_ProcTypeMissing("ADD", SCP(zz_pvt[-1].id_ptr));
	  }
	  zz_val.tptr = tmptype; /* parent should check for NULL */
	  g_type_name = zz_pvt[-1].id_ptr; /* scope for notes */
	} break;
case 29:
/* # line 597 "ascParse.y" */
{
	  zz_val.tptr = ILLEGAL_DEFINITION;
	  /* need a bit of global state here to tag base methods */
	} break;
case 30:
/* # line 605 "ascParse.y" */
{
	  if (zz_pvt[-3].tptr == NULL) {
	    DestroyProcedureList(zz_pvt[-2].listp);
	  } else {
	    if( zz_pvt[-1].int_value != METHODS_T ) {
	      WarnMsg_MismatchEnd("REPLACE METHODS", NULL, zz_pvt[-1].int_value, "METHODS");
	    }
	    if (ReplaceMethods(zz_pvt[-3].tptr,zz_pvt[-2].listp,g_untrapped_error) != 0) {
              ErrMsg_ProcsRejected("REPLACE",SCP(GetName(zz_pvt[-3].tptr)));
	      DestroyProcedureList(zz_pvt[-2].listp);
	    }
	  }
	  g_untrapped_error = 0;
	} break;
case 31:
/* # line 623 "ascParse.y" */
{
	  struct TypeDescription *tmptype;
	  tmptype = FindType(zz_pvt[-1].id_ptr);
	  if (tmptype == NULL) {
            ErrMsg_ProcTypeMissing("REPLACE", SCP(zz_pvt[-1].id_ptr));
	  }
	  zz_val.tptr = tmptype; /* parent should check for NULL */
	} break;
case 32:
/* # line 632 "ascParse.y" */
{
	  zz_val.tptr = ILLEGAL_DEFINITION;
	  /* need a bit of global state here to tag base methods */
	} break;
case 33:
/* # line 640 "ascParse.y" */
{
	  struct TypeDescription *def_ptr;
	  int keepnotes = 0;

          if(( zz_pvt[-1].int_value != IDENTIFIER_T ) || ( g_end_identifier != g_type_name )) {
	    /* all identifier_t are from symbol table, so ptr match
	     * is sufficient for equality.
	     */
	    WarnMsg_MismatchEnd("ATOM", SCP(g_type_name),
	                        zz_pvt[-1].int_value, SCP(g_type_name));
	  }
	  g_atom_dim_ptr = CheckDimensionsMatch(g_default_dim_ptr,
	                                        g_atom_dim_ptr);
	  if (g_atom_dim_ptr != NULL) {
	    def_ptr = CreateAtomTypeDef(g_type_name,
	                                g_refines_name,
	                                real_type, /* ignored..really */
	                                Asc_CurrentModule(),
	                                zz_pvt[-5].int_value,
	                                zz_pvt[-3].slptr,
	                                zz_pvt[-2].listp,
	                                g_defaulted,
	                                g_default_double,
	                                g_atom_dim_ptr,
	                                g_default_long,
	                                g_default_symbol,
	                                g_untrapped_error);
	    if (def_ptr != NULL) {
	      keepnotes = AddType(def_ptr);
	    } else {
	      /* CreateAtomTypeDef is responsible for freeing (if needed)
	       * all args sent to it event of failure so we don't have to.
	       * In particular $3 $4 should be killed before returning NULL.
	       */
	      ErrMsg_NullDefPointer(SCP(g_type_name));
	    }
	  } else {
	    FPRINTF(ASCERR,
	            "Atom dimensions don't match in ATOM %s on line %s:%lu.\n",
	            SCP(g_type_name),
	            Asc_ModuleBestName(Asc_CurrentModule()),
	            g_header_linenum);
	    DestroyStatementList(zz_pvt[-3].slptr);
	    DestroyProcedureList(zz_pvt[-2].listp);
	  }
	  ProcessNotes(keepnotes);
	  g_type_name = g_refines_name = g_proc_name = NULL;
	  g_untrapped_error = 0;
	} break;
case 34:
/* # line 693 "ascParse.y" */
{
	  /* g_type_name = $1; */
	  g_refines_name = zz_pvt[-3].id_ptr;
	  g_atom_dim_ptr = zz_pvt[-2].dimp;
	  g_default_double = zz_pvt[-1].real_value;
	  g_header_linenum = LineNum();
	} break;
case 35:
/* # line 704 "ascParse.y" */
{
	  zz_val.id_ptr = zz_pvt[-0].id_ptr;
	  g_type_name = zz_pvt[-0].id_ptr; /* want this set early so parm lists see it */
	} break;
case 36:
/* # line 712 "ascParse.y" */
{
	  zz_val.real_value = 0.0;
	  g_default_dim_ptr = WildDimension();
	  g_defaulted = 0;
	} break;
case 37:
/* # line 718 "ascParse.y" */
{
	  zz_val.real_value = zz_pvt[-1].int_value ? -zz_pvt[-0].real_value : zz_pvt[-0].real_value;
	  g_defaulted = 1;
	} break;
case 38:
/* # line 723 "ascParse.y" */
{
	  zz_val.real_value = 0.0;
	  g_default_dim_ptr = Dimensionless();
	  g_default_long = 0;
	  g_defaulted = 1;
	} break;
case 39:
/* # line 730 "ascParse.y" */
{
	  zz_val.real_value = 0.0;
	  g_default_dim_ptr = Dimensionless();
	  g_default_long = 1;
	  g_defaulted = 1;
	} break;
case 40:
/* # line 737 "ascParse.y" */
{
	  zz_val.real_value = 0.0;
	  g_default_dim_ptr = Dimensionless();
	  g_default_symbol = zz_pvt[-0].sym_ptr;
	  g_defaulted = 0;
	} break;
case 41:
/* # line 747 "ascParse.y" */
{
	  struct TypeDescription *def_ptr;
	  int keepnotes = 0;
	  if (g_defaulted) {
	    g_atom_dim_ptr = CheckDimensionsMatch(g_default_dim_ptr,
	                                          g_atom_dim_ptr);
	  }
	  if (g_atom_dim_ptr != NULL) {
	    def_ptr = CreateConstantTypeDef(g_type_name,
	                                    g_refines_name,
	                                    Asc_CurrentModule(),
	                                    zz_pvt[-1].int_value,
	                                    g_defaulted,
	                                    g_default_double,
	                                    g_default_long,
	                                    g_default_symbol,
	                                    g_atom_dim_ptr,
	                                    g_untrapped_error);
	    if (def_ptr != NULL) {
	      keepnotes = AddType(def_ptr);
	    } else {
	      ErrMsg_NullDefPointer(SCP(g_type_name));
	    }
	  } else {
	    FPRINTF(ASCERR,
	            "Constant dimensions don't match in CONSTANT %s"
	            " on line %s:%lu.\n",
	            SCP(g_type_name),
	            Asc_ModuleBestName(Asc_CurrentModule()),
	            g_header_linenum);
	  }
	  ProcessNotes(keepnotes);
	  g_type_name = g_refines_name = NULL;
	  g_untrapped_error = 0;
	} break;
case 42:
/* # line 787 "ascParse.y" */
{
	  g_type_name = zz_pvt[-6].id_ptr;
	  g_refines_name = zz_pvt[-4].id_ptr;
	  g_atom_dim_ptr = zz_pvt[-3].dimp;
	  switch (g_constant_type) {
	  case DOUBLECONSTANT:
	    g_default_double = zz_pvt[-2].real_value;
	    break;
	  case LONGCONSTANT:
	    g_default_long = zz_pvt[-2].real_value;
	    break;
	  case BOOLEANCONSTANT:
	    g_default_long = zz_pvt[-2].int_value;
	    break;
	  case SYMBOLCONSTANT:
	    g_default_symbol = zz_pvt[-2].sym_ptr;
	    break;
	  default:
	    ErrMsg_Generic("wierd constant type assign encountered ");
	    break; /* better not be reached. */
	  }
	  g_header_linenum = LineNum();
	  if (zz_pvt[-1].dquote_ptr != NULL) {
	    CollectNote(CreateNote(g_type_name,InlineNote(),SelfNote(),NULL,
	                           Asc_ModuleBestName(Asc_CurrentModule()),
	                           AddBraceChar(zz_pvt[-1].dquote_ptr,InlineNote()),
	                           g_header_linenum,NULL,nd_empty));
	  }
	} break;
case 43:
/* # line 820 "ascParse.y" */
{
	  zz_val.real_value = 0.0;
	  g_default_dim_ptr = WildDimension();
	  g_defaulted = 0;
	} break;
case 44:
/* # line 826 "ascParse.y" */
{
	  zz_val.real_value = zz_pvt[-1].int_value ? -zz_pvt[-0].real_value : zz_pvt[-0].real_value;
	  g_defaulted = 1;
	} break;
case 45:
/* # line 831 "ascParse.y" */
{
	  zz_val.int_value = 1;
	  g_defaulted = 1;
	  g_default_dim_ptr = Dimensionless();
	  g_constant_type = BOOLEANCONSTANT;
	} break;
case 46:
/* # line 838 "ascParse.y" */
{
	  zz_val.int_value = 0;
	  g_defaulted = 1;
	  g_default_dim_ptr = Dimensionless();
	  g_constant_type = BOOLEANCONSTANT;
	} break;
case 47:
/* # line 845 "ascParse.y" */
{
	  zz_val.sym_ptr = zz_pvt[-0].sym_ptr;
	  g_defaulted = 1;
	  g_default_dim_ptr = Dimensionless();
	  g_constant_type = SYMBOLCONSTANT;
	} break;
case 48:
/* # line 855 "ascParse.y" */
{
	  struct TypeDescription *def_ptr;
	  int keepnotes = 0;
	  if(( zz_pvt[-1].int_value != IDENTIFIER_T ) || ( g_end_identifier != g_type_name )) {
	    /* all identifier_t are from symbol table, so ptr match
	     * is sufficient for equality.
	     */
	    WarnMsg_MismatchEnd("MODEL", SCP(g_type_name),
	                        zz_pvt[-1].int_value, SCP(g_type_name));
	  }
	  def_ptr = CreateModelTypeDef(g_type_name,
	                               g_refines_name,
	                               Asc_CurrentModule(),
	                               zz_pvt[-5].int_value,
	                               zz_pvt[-3].slptr,
	                               zz_pvt[-2].listp,
	                               g_model_parameters,
	                               g_parameter_reduction,
	                               g_parameter_wheres,
	                               g_untrapped_error);
	  if (def_ptr != NULL) {
	    keepnotes = AddType(def_ptr);
	  } else {
	    /* CreateModelTypeDef is responsible for freeing (if needed)
	     * all args sent to it so we don't have to here.
	     * in particular $3 $4 g_model_parameters, g_parameter_reduction,
	     * and g_parameter_wheres.
	     */
	    ErrMsg_NullDefPointer(SCP(g_type_name));
	  }
	  ProcessNotes(keepnotes);
	  g_type_name = g_refines_name = NULL;
	  g_model_parameters =
	    g_parameter_reduction =
	    g_parameter_wheres = NULL;
	  g_untrapped_error = 0;
	} break;
case 49:
/* # line 897 "ascParse.y" */
{
	  /* g_type_name = $1; */
	  g_model_parameters = zz_pvt[-2].slptr;
	  g_parameter_wheres = zz_pvt[-1].slptr;
	  g_refines_name = NULL;
	  g_header_linenum = LineNum();
	} break;
case 50:
/* # line 906 "ascParse.y" */
{
	  /* g_type_name = $1; */
	  g_model_parameters = zz_pvt[-5].slptr;
	  g_parameter_wheres = zz_pvt[-4].slptr;
	  g_refines_name = zz_pvt[-2].id_ptr;
	  g_parameter_reduction = zz_pvt[-1].slptr;
	  g_header_linenum = LineNum();
	} break;
case 51:
/* # line 918 "ascParse.y" */
{
	  zz_val.id_ptr = zz_pvt[-0].id_ptr;
	  g_type_name = zz_pvt[-0].id_ptr; /* want this set early so parm lists see it */
	} break;
case 52:
/* # line 926 "ascParse.y" */
{
	  zz_val.slptr = NULL;
	} break;
case 53:
/* # line 930 "ascParse.y" */
{
	  zz_val.slptr = zz_pvt[-1].slptr; /* this could be much more sophisticated */
	} break;
case 54:
/* # line 937 "ascParse.y" */
{
	  zz_val.slptr = NULL;
	} break;
case 55:
/* # line 941 "ascParse.y" */
{
	  zz_val.slptr = zz_pvt[-1].slptr; /* this could be much more sophisticated */
	} break;
case 56:
/* # line 948 "ascParse.y" */
{
	  zz_val.slptr = NULL;
	} break;
case 57:
/* # line 952 "ascParse.y" */
{
	  zz_val.slptr = zz_pvt[-1].slptr; /* this could be much more sophisticated */
	} break;
case 58:
/* # line 959 "ascParse.y" */
{
	  struct TypeDescription *def_ptr;
	  if ((zz_pvt[-1].int_value != IDENTIFIER_T ) || ( g_end_identifier != g_type_name )) {
	    /* all identifier_t are from symbol table, so ptr match
	     * is sufficient for equality.
	     */
	    WarnMsg_MismatchEnd("PATCH", SCP(g_type_name),
	                        zz_pvt[-1].int_value, SCP(g_type_name));
	  }
	  def_ptr = CreatePatchTypeDef(g_type_name,
	                               g_refines_name,
	                               NULL,
	                               Asc_CurrentModule(),
	                               zz_pvt[-3].slptr,
	                               zz_pvt[-2].listp,
	                               g_untrapped_error);
	  g_untrapped_error = 0;
	  if (def_ptr != NULL) {
	    AddType(def_ptr);
	  } else {
	    /* CreatePatchTypeDef is responsible for freeing (if needed)
	     * all args sent to it so we don't have to here.
	     * in particular $2 $3
	     */
	    ErrMsg_NullDefPointer(SCP(g_type_name));
	  }
	  g_type_name = g_refines_name = g_proc_name = NULL;
	} break;
case 59:
/* # line 991 "ascParse.y" */
{
	  /*
	   * A patch definition looks just like a model def.
	   * with the original name <=> refine name.
	   */
	  g_type_name = zz_pvt[-3].id_ptr;
	  g_refines_name = zz_pvt[-1].id_ptr;
	  g_header_linenum = LineNum();
	} break;
case 60:
/* # line 1004 "ascParse.y" */
{
	  zz_val.int_value = 0;
	} break;
case 61:
/* # line 1008 "ascParse.y" */
{
	  zz_val.int_value = 1;
	} break;
case 62:
/* # line 1015 "ascParse.y" */
{
	  struct TypeDescription *def_ptr;
	  int keepnotes = 0;

	  if(( zz_pvt[-1].int_value != IDENTIFIER_T ) || ( g_end_identifier != zz_pvt[-4].id_ptr )) {
	    WarnMsg_MismatchEnd("DEFINITION", SCP(zz_pvt[-4].id_ptr), zz_pvt[-1].int_value, SCP(zz_pvt[-4].id_ptr));
	  }
	  if( zz_pvt[-4].id_ptr == GetBaseTypeName(relation_type)) {
	    def_ptr = CreateRelationTypeDef(Asc_CurrentModule(),zz_pvt[-4].id_ptr,zz_pvt[-3].slptr,zz_pvt[-2].listp);
	  }
	  else if( zz_pvt[-4].id_ptr == GetBaseTypeName(logrel_type) ) {
	    def_ptr = CreateLogRelTypeDef(Asc_CurrentModule(),zz_pvt[-4].id_ptr,zz_pvt[-3].slptr,zz_pvt[-2].listp);
	  }
	  else {
	    ErrMsg_Generic("Bad type passed to DEFINITION statement ");
	    def_ptr = NULL;
	  }
	  if ( def_ptr != NULL ) {
	    keepnotes = AddType(def_ptr);
	  } else {
	    ErrMsg_NullDefPointer(SCP(zz_pvt[-4].id_ptr));
	  }
	  ProcessNotes(keepnotes);
	  g_type_name = NULL;
	  g_untrapped_error = 0;
	} break;
case 63:
/* # line 1045 "ascParse.y" */
{
	  zz_val.id_ptr = zz_pvt[-0].id_ptr;
	  g_type_name = zz_pvt[-0].id_ptr; /* want this set early so parm lists see it */
	} break;
case 64:
/* # line 1054 "ascParse.y" */
{ /* nothing to do. just cruft to fix ; problem */ } break;
case 65:
/* # line 1059 "ascParse.y" */
{
          struct UnitDefinition *ud;
          unsigned long c,len;

	  if( zz_pvt[-0].int_value != UNITS_T ) {
	    WarnMsg_MismatchEnd("UNITS", NULL, zz_pvt[-0].int_value, NULL);
	  }
          len = gl_length(zz_pvt[-1].listp);
          for (c=1; c <= len; c++) {
            ud = (struct UnitDefinition *)gl_fetch(zz_pvt[-1].listp,c);
            ProcessUnitDef(ud);
            DestroyUnitDef(ud);
          }
          gl_destroy(zz_pvt[-1].listp);
          zz_val.statptr = NULL;
	} break;
case 66:
/* # line 1078 "ascParse.y" */
{
	  zz_val.listp = gl_create(100L);
	} break;
case 67:
/* # line 1082 "ascParse.y" */
{
	  gl_append_ptr(zz_pvt[-1].listp,(char *)zz_pvt[-0].udefptr);
	  zz_val.listp = zz_pvt[-1].listp;
	} break;
case 68:
/* # line 1090 "ascParse.y" */
{
	  zz_val.udefptr = CreateUnitDef(zz_pvt[-3].id_ptr,zz_pvt[-1].braced_ptr,Asc_ModuleBestName(Asc_CurrentModule()),
                             LineNum());
	} break;
case 69:
/* # line 1099 "ascParse.y" */
{
	  zz_val.listp = NULL;
	} break;
case 70:
/* # line 1103 "ascParse.y" */
{ /* To get rid of this, we will need a global proclist
           * that accumulates procs until a MODEL production is
           * completed. If any other sort of production is started,
           * and proclist is not NULL, it should be discarded.
           */
	} break;
case 71:
/* # line 1110 "ascParse.y" */
{
	  zz_val.listp = zz_pvt[-0].listp;
	} break;
case 72:
/* # line 1117 "ascParse.y" */
{
	  zz_val.listp = zz_pvt[-0].listp;
	  gl_sort(zz_val.listp,(CmpFunc)CmpProcs);
	} break;
case 73:
/* # line 1124 "ascParse.y" */
{
	  zz_val.listp = gl_create(7L);
	} break;
case 74:
/* # line 1128 "ascParse.y" */
{
	  unsigned long c;
	  struct InitProcedure *oldproc;
	  c = gl_length(zz_pvt[-1].listp);
          while (c > 0) {
            oldproc = (struct InitProcedure *)gl_fetch(zz_pvt[-1].listp,c);
            if (ProcName(zz_pvt[-0].procptr) == ProcName(oldproc)) {
	      ErrMsg_DuplicateProc(zz_pvt[-0].procptr);
              break;
            }
            c--;
          }
	  if (c) { /* broke early */
	    DestroyProcedure(zz_pvt[-0].procptr);
	  } else {
	    gl_append_ptr(zz_pvt[-1].listp,(char *)zz_pvt[-0].procptr);
	  }
	  zz_val.listp = zz_pvt[-1].listp;
	} break;
case 75:
/* # line 1151 "ascParse.y" */
{
	  if ((zz_pvt[-1].int_value != IDENTIFIER_T) || (zz_pvt[-4].id_ptr != g_end_identifier)) {
	    /* all identifier_t are from symbol table, so ptr match
	     * is sufficient for equality.
	     */
	    WarnMsg_MismatchEnd("METHOD", SCP(zz_pvt[-4].id_ptr), zz_pvt[-1].int_value, SCP(zz_pvt[-4].id_ptr));
	  }
	  zz_val.procptr = CreateProcedure(zz_pvt[-4].id_ptr,zz_pvt[-2].slptr);
	  g_proc_name = NULL;
	} break;
case 76:
/* # line 1165 "ascParse.y" */
{
	  zz_val.id_ptr = zz_pvt[-0].id_ptr;
	  g_proc_name = zz_pvt[-0].id_ptr;
	} break;
case 77:
/* # line 1174 "ascParse.y" */
{
	  zz_val.slptr = CreateStatementList(zz_pvt[-0].listp);
	} break;
case 78:
/* # line 1181 "ascParse.y" */
{
	  zz_val.listp = gl_create(7L);
	} break;
case 79:
/* # line 1185 "ascParse.y" */
{
	  /* this is appending to a gllist of statements, not yet slist. */
	  if (zz_pvt[-1].statptr != NULL) {
	    gl_append_ptr(zz_pvt[-2].listp,(char *)zz_pvt[-1].statptr);
	  }
	  zz_val.listp = zz_pvt[-2].listp;
	} break;
case 80:
/* # line 1193 "ascParse.y" */
{
	  ErrMsg_Generic("Error in statement input ");
	  zz_val.listp = zz_pvt[-2].listp;
	} break;
case 108:
/* # line 1231 "ascParse.y" */
{
	  struct TypeDescription *tmptype;
	  tmptype = FindType(zz_pvt[-2].id_ptr);
	  if (zz_pvt[-0].eptr != NULL) {
	    ErrMsg_Generic("WITH VALUE clause not allowed in IS_A ");
	    g_untrapped_error++;
	    DestroyVariableList(zz_pvt[-4].lptr);
	    DestroySetList(g_typeargs);
	    DestroyExprList(zz_pvt[-0].eptr);
	    zz_val.statptr = NULL;
	  } else {
	    if (tmptype != NULL) {
	      if ((GetBaseType(tmptype) != model_type) &&
	          (g_typeargs != NULL)) {
	        FPRINTF(ASCERR,
	                "%sThe IS_A on line %s:%lu\n"
	                "  has arguments to the nonmodel type %s.\n",
	                StatioLabel(3),
	                Asc_ModuleBestName(Asc_CurrentModule()),
	                LineNum(),
	                SCP(zz_pvt[-2].id_ptr));
	        DestroyVariableList(zz_pvt[-4].lptr);
	        DestroySetList(g_typeargs);
	        DestroyExprList(zz_pvt[-0].eptr);
	        g_untrapped_error++;
	        zz_val.statptr = NULL;
	      } else {
	        zz_val.statptr = CreateISA(zz_pvt[-4].lptr,zz_pvt[-2].id_ptr,g_typeargs,zz_pvt[-1].id_ptr);
	      }
	    } else {
	      FPRINTF(ASCERR,"%sThe IS_A on line %s:%lu\n",
	              StatioLabel(3),Asc_ModuleBestName(Asc_CurrentModule()),
	              LineNum());
	      FPRINTF(ASCERR,"  uses the undefined type %s.\n",SCP(zz_pvt[-2].id_ptr));
	      DestroyVariableList(zz_pvt[-4].lptr);
	      DestroySetList(g_typeargs);
	      DestroyExprList(zz_pvt[-0].eptr);
	      g_untrapped_error++;
	      zz_val.statptr = NULL;
	    }
	  }
	  g_typeargs = NULL;

	} break;
case 109:
/* # line 1279 "ascParse.y" */
{
	  struct TypeDescription *tmptype;
	  tmptype = FindType(zz_pvt[-2].id_ptr);
	  if (tmptype != NULL) {
	    if ((GetBaseType(tmptype) != model_type) &&
	        (g_typeargs != NULL)) {
	      FPRINTF(ASCERR,"%sThe WILL_BE on line %s:%lu\n",
	              StatioLabel(3),Asc_ModuleBestName(Asc_CurrentModule()),
	              LineNum());
	      FPRINTF(ASCERR,
	              "  has arguments to the nonmodel type %s.\n",SCP(zz_pvt[-2].id_ptr));
	      DestroyVariableList(zz_pvt[-4].lptr);
	      DestroySetList(g_typeargs);
	      DestroyExprList(zz_pvt[-0].eptr);
	      g_untrapped_error++;
	      zz_val.statptr = NULL;
	    } else {
	      zz_val.statptr = CreateWILLBE(zz_pvt[-4].lptr,zz_pvt[-2].id_ptr,g_typeargs,zz_pvt[-1].id_ptr,zz_pvt[-0].eptr);
	    }
	  } else {
	    DestroyVariableList(zz_pvt[-4].lptr);
	    DestroySetList(g_typeargs);
	    DestroyExprList(zz_pvt[-0].eptr);
	    g_untrapped_error++;
	    zz_val.statptr = NULL;
	    FPRINTF(ASCERR,"%sThe WILL_BE on line %s:%lu\n",StatioLabel(3),
	            Asc_ModuleBestName(Asc_CurrentModule()),LineNum());
	    FPRINTF(ASCERR,"	uses the undefined type %s.\n",SCP(zz_pvt[-2].id_ptr));
	  }
	  g_typeargs = NULL;
	} break;
case 110:
/* # line 1314 "ascParse.y" */
{
	  zz_val.statptr = CreateALIASES(zz_pvt[-2].lptr,zz_pvt[-0].nptr);
	} break;
case 111:
/* # line 1319 "ascParse.y" */
{
	  int carray_err;
	  carray_err = 0;
	  if (VariableListLength(zz_pvt[-11].lptr) != 1L) {
	    carray_err = 1;
	    FPRINTF(ASCERR,
	            "%sCompound ALIASES allows only 1 LHS name. Found:\n",
	            StatioLabel(3));
	    WriteVariableList(ASCERR,zz_pvt[-11].lptr);
	    FPRINTF(ASCERR,"\n");
	  }
	  if (VariableListLength(zz_pvt[-5].lptr) != 1L) {
	    carray_err = 1;
	    FPRINTF(ASCERR,
	            "%sCompound ALIASES/IS_A allows only "
	            "1 LHS name. Found:\n",StatioLabel(3));
	    WriteVariableList(ASCERR,zz_pvt[-5].lptr);
	    FPRINTF(ASCERR,"\n");
	  }
	  /* verify $9 == "set" */
	  if (!carray_err && zz_pvt[-3].id_ptr != GetBaseTypeName(set_type)) {
	    carray_err = 1;
	    FPRINTF(ASCERR,"%sCompound ALIASES statement requires IS_A %s. ",
	            StatioLabel(3),SCP(GetBaseTypeName(set_type)));
	    FPRINTF(ASCERR,"Found %s.\n",SCP(zz_pvt[-3].id_ptr));
	  }
	  /* verify set type */
	  if ((!carray_err) &&
	      (zz_pvt[-1].id_ptr != GetBaseTypeName(symbol_constant_type)) &&
	      (zz_pvt[-1].id_ptr != GetBaseTypeName(integer_constant_type))) {
	    carray_err = 1;
	    FPRINTF(ASCERR,
	            "%sCompound ALIASES IS_A statement requires %s or %s.\n",
	            StatioLabel(3),SCP(GetBaseTypeName(integer_constant_type)),
	            SCP(GetBaseTypeName(symbol_constant_type)));
	    FPRINTF(ASCERR,"	Found %s.\n",SCP(zz_pvt[-1].id_ptr));
	  }
	  if (carray_err) {
	    DestroyVariableList(zz_pvt[-11].lptr);
	    DestroyVariableList(zz_pvt[-8].lptr);
	    DestroyVariableList(zz_pvt[-5].lptr);
	    DestroySetList(zz_pvt[-0].sptr);
	    g_untrapped_error++;
	    zz_val.statptr = NULL;
	  } else {
	    int intset;
	    intset = (zz_pvt[-1].id_ptr == GetBaseTypeName(integer_constant_type));
	    zz_val.statptr = CreateARR(zz_pvt[-11].lptr,zz_pvt[-8].lptr,zz_pvt[-5].lptr,intset,zz_pvt[-0].sptr);
	  }
	} break;
case 112:
/* # line 1373 "ascParse.y" */
{
	  zz_val.sptr = NULL;
	} break;
case 113:
/* # line 1377 "ascParse.y" */
{
	  zz_val.sptr = zz_pvt[-1].sptr;
	} break;
case 114:
/* # line 1384 "ascParse.y" */
{
	  if (FindType(zz_pvt[-1].id_ptr)) {
	    zz_val.statptr = CreateREF(zz_pvt[-3].lptr,zz_pvt[-1].id_ptr,zz_pvt[-0].id_ptr,1);
	  } else {
	    zz_val.statptr = CreateREF(zz_pvt[-3].lptr,zz_pvt[-1].id_ptr,zz_pvt[-0].id_ptr,1);
	    FPRINTF(ASCERR,"%s The _IS_ on line %s:%lu\n",
	            StatioLabel(2),
	            Asc_ModuleBestName(Asc_CurrentModule()),LineNum());
	    FPRINTF(ASCERR,"uses the unbuilt prototype %s.\n",SCP(zz_pvt[-1].id_ptr));
	  }
	} break;
case 115:
/* # line 1399 "ascParse.y" */
{
	  struct TypeDescription *tmptype;
	  tmptype = FindType(zz_pvt[-0].id_ptr);
	  if (tmptype != NULL) {
	    if ((GetBaseType(tmptype) != model_type) && 
                (g_typeargs != NULL)) {
	      FPRINTF(ASCERR,"%sThe IS_REFINED_TO on line %s:%lu\n",
	              StatioLabel(3),
	              Asc_ModuleBestName(Asc_CurrentModule()),LineNum());
	      FPRINTF(ASCERR,
	              "  has arguments to the nonmodel type %s.\n",SCP(zz_pvt[-0].id_ptr));
	      DestroyVariableList(zz_pvt[-2].lptr);
	      DestroySetList(g_typeargs);
	      g_untrapped_error++;
	      zz_val.statptr = NULL;
	    } else {
	      zz_val.statptr = CreateIRT(zz_pvt[-2].lptr,zz_pvt[-0].id_ptr,g_typeargs);
	    }
	  } else {
	    FPRINTF(ASCERR,"%sThe IS_REFINED_TO on line %s:%lu\n",
	            StatioLabel(3),
	            Asc_ModuleBestName(Asc_CurrentModule()),LineNum());
	    FPRINTF(ASCERR,"	uses the undefined type %s.\n",SCP(zz_pvt[-0].id_ptr));
	    DestroyVariableList(zz_pvt[-2].lptr);
	    DestroySetList(g_typeargs);
	    g_untrapped_error++;
	    zz_val.statptr = NULL;
	  }
	  g_typeargs = NULL;
	} break;
case 116:
/* # line 1433 "ascParse.y" */
{
	  zz_val.id_ptr = zz_pvt[-0].id_ptr;
	  g_callargs = NULL;
	} break;
case 117:
/* # line 1438 "ascParse.y" */
{
	  zz_val.id_ptr = zz_pvt[-3].id_ptr;
	  g_callargs = zz_pvt[-1].sptr;
	} break;
case 118:
/* # line 1446 "ascParse.y" */
{
	  zz_val.id_ptr = zz_pvt[-0].id_ptr;
	  g_typeargs = NULL;
	} break;
case 119:
/* # line 1451 "ascParse.y" */
{
	  zz_val.id_ptr = zz_pvt[-3].id_ptr;
	  g_typeargs = zz_pvt[-1].sptr;
	} break;
case 120:
/* # line 1459 "ascParse.y" */
{
	  zz_val.id_ptr = NULL;
	} break;
case 121:
/* # line 1463 "ascParse.y" */
{
	  zz_val.id_ptr = zz_pvt[-0].id_ptr;
	} break;
case 122:
/* # line 1470 "ascParse.y" */
{
	  zz_val.id_ptr = NULL;
	} break;
case 123:
/* # line 1474 "ascParse.y" */
{
	  zz_val.id_ptr = zz_pvt[-0].id_ptr;
	} break;
case 124:
/* # line 1481 "ascParse.y" */
{
	  zz_val.eptr = NULL;
	} break;
case 125:
/* # line 1485 "ascParse.y" */
{
	  zz_val.eptr = zz_pvt[-0].eptr;
	} break;
case 126:
/* # line 1492 "ascParse.y" */
{
	  zz_val.statptr = CreateAA(zz_pvt[-1].lptr);
	} break;
case 127:
/* # line 1499 "ascParse.y" */
{
	  zz_val.statptr = CreateATS(zz_pvt[-1].lptr);
	} break;
case 128:
/* # line 1506 "ascParse.y" */
{
	  zz_val.statptr = CreateWBTS(zz_pvt[-1].lptr);
	} break;
case 129:
/* # line 1513 "ascParse.y" */
{
	  zz_val.statptr = CreateWNBTS(zz_pvt[-1].lptr);
	} break;
case 130:
/* # line 1520 "ascParse.y" */
{
	  zz_val.statptr = CreateASSIGN(zz_pvt[-2].nptr,zz_pvt[-0].eptr);
	} break;
case 131:
/* # line 1524 "ascParse.y" */
{
	  zz_val.statptr = CreateCASSIGN(zz_pvt[-2].nptr,zz_pvt[-0].eptr);
	} break;
case 132:
/* # line 1531 "ascParse.y" */
{
	  if (IsRelation(zz_pvt[-0].eptr)) {
	    if (g_parse_relns == 0) {
	      DestroyExprList(zz_pvt[-0].eptr);
	      zz_val.statptr = NULL;
	    } else {
	      zz_val.statptr = CreateREL(NULL,zz_pvt[-0].eptr);
	    }
	  } else {
	    zz_val.statptr = CreateLOGREL(NULL,zz_pvt[-0].eptr);
	  }
	} break;
case 133:
/* # line 1544 "ascParse.y" */
{
	  if (IsRelation(zz_pvt[-0].eptr)) {
	    if (g_parse_relns == 0) {
	      DestroyExprList(zz_pvt[-0].eptr);
	      DestroyName(zz_pvt[-2].nptr);
	      zz_val.statptr = NULL;
	    } else {
	      zz_val.statptr = CreateREL(zz_pvt[-2].nptr,zz_pvt[-0].eptr);
	    }
	  } else {
	    zz_val.statptr = CreateLOGREL(zz_pvt[-2].nptr,zz_pvt[-0].eptr);
	  }
	} break;
case 134:
/* # line 1561 "ascParse.y" */
{
	  zz_val.eptr = zz_pvt[-0].eptr;
	  if (NumberOfRelOps(zz_pvt[-0].eptr) < 1) {
	    /* want at least 1. restriction to exactly 1 is in typelint */
	    ErrMsg_Generic("Missing punctuation (,;:) or else\n"
	                  "expression contains the wrong number of relation\n"
	                  "operators (=, ==, <, >, <=, >=, !=)"
	                  " preceeding or ");
	    g_untrapped_error++;
	  }
	} break;
case 135:
/* # line 1573 "ascParse.y" */
{
	  zz_val.eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_minimize));
	  if (NumberOfRelOps(zz_pvt[-0].eptr) > 0) {
	    ErrMsg_Generic("Objective function contains relation\n"
	                  "operators (=, ==, <, >, <=, >=, !=) ");
	    g_untrapped_error++;
	  }
	} break;
case 136:
/* # line 1582 "ascParse.y" */
{
	  zz_val.eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_maximize));
	  if (NumberOfRelOps(zz_pvt[-0].eptr)>0) {
	    ErrMsg_Generic("Objective function contains relation\n"
	                  "operators (=, ==, <, >, <=, >=, !=) ");
	    g_untrapped_error++;
	  }
	} break;
case 137:
/* # line 1594 "ascParse.y" */
{
	  /*
	   * This is the blackbox declarative external relation.
	   */
	  struct VariableList *vl;
	  vl = JoinVariableLists(zz_pvt[-4].lptr,zz_pvt[-2].lptr);
	  zz_val.statptr = CreateEXTERN(2,zz_pvt[-8].nptr,SCP(zz_pvt[-6].id_ptr),vl,zz_pvt[-1].nptr,NULL);
	} break;
case 138:
/* # line 1606 "ascParse.y" */
{
	  zz_val.lptr = zz_pvt[-2].lptr;
	} break;
case 139:
/* # line 1613 "ascParse.y" */
{
	  zz_val.lptr = zz_pvt[-2].lptr;
	} break;
case 140:
/* # line 1620 "ascParse.y" */
{
	  zz_val.nptr = NULL;
	} break;
case 141:
/* # line 1624 "ascParse.y" */
{
	  zz_val.nptr = zz_pvt[-2].nptr;
	} break;
case 142:
/* # line 1631 "ascParse.y" */
{
	  /*
	   * This is the glassbox declarative external relation.
	   * This now allows a scope for placement of the relations
	   */
	  struct VariableList *vl = zz_pvt[-4].lptr;
	  struct Name *nptr;
	  char tmp[32]; 
	  symchar *str;

	  sprintf(tmp,"%ld",zz_pvt[-2].int_value);
	  str = AddSymbol(tmp);
	  nptr = CreateIdName(str);
	  zz_val.statptr = CreateEXTERN(1,zz_pvt[-8].nptr,SCP(zz_pvt[-6].id_ptr),vl,nptr,zz_pvt[-0].nptr);
	} break;
case 143:
/* # line 1650 "ascParse.y" */
{
	  zz_val.nptr = NULL;
	} break;
case 144:
/* # line 1654 "ascParse.y" */
{
	  zz_val.nptr = zz_pvt[-0].nptr;
	} break;
case 145:
/* # line 1662 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != FOR_T ) {
	    WarnMsg_MismatchEnd("FOR", SCP(zz_pvt[-6].id_ptr), zz_pvt[-0].int_value, NULL);
	  }
          if (zz_pvt[-2].fkind == fk_create && zz_pvt[-3].order != f_random) {
            /* create cannot have an order in declarative FOR */
	    ErrMsg_Generic("FOR loops only accept DECREASING or\n"
                           "INCREASING in the method section ");
	    g_untrapped_error++;
          }
          if (zz_pvt[-2].fkind == fk_do && zz_pvt[-3].order == f_random) {
            /* all FOR/DO default to increasing */
	    zz_val.statptr = CreateFOR(zz_pvt[-6].id_ptr,zz_pvt[-4].eptr,zz_pvt[-1].slptr,f_increasing,zz_pvt[-2].fkind);
          } else {
	    zz_val.statptr = CreateFOR(zz_pvt[-6].id_ptr,zz_pvt[-4].eptr,zz_pvt[-1].slptr,zz_pvt[-3].order,zz_pvt[-2].fkind);
          }
	} break;
case 146:
/* # line 1683 "ascParse.y" */
{
	  zz_val.order = f_random;
	} break;
case 147:
/* # line 1687 "ascParse.y" */
{
	  zz_val.order = f_increasing;
	} break;
case 148:
/* # line 1691 "ascParse.y" */
{
	  zz_val.order = f_decreasing;
	} break;
case 149:
/* # line 1698 "ascParse.y" */
{
          zz_val.fkind = fk_create; /* declarative FOR */
	} break;
case 150:
/* # line 1702 "ascParse.y" */
{
          zz_val.fkind = fk_expect; /* parameter FOR */
	} break;
case 151:
/* # line 1706 "ascParse.y" */
{
          zz_val.fkind = fk_check; /* WHERE FOR */
	} break;
case 152:
/* # line 1710 "ascParse.y" */
{
          zz_val.fkind = fk_do; /* method FOR */
	} break;
case 153:
/* # line 1717 "ascParse.y" */
{
	  zz_val.statptr = CreateRUN(zz_pvt[-0].nptr,NULL);
	} break;
case 154:
/* # line 1721 "ascParse.y" */
{
	  zz_val.statptr = CreateRUN(zz_pvt[-0].nptr,zz_pvt[-2].nptr);	  /* type :: name */
	} break;
case 155:
/* # line 1728 "ascParse.y" */
{
	  /*
	   * This is procedural external code.
	   */
	  zz_val.statptr = CreateEXTERN(0,NULL,SCP(zz_pvt[-3].id_ptr),zz_pvt[-1].lptr,NULL,NULL);
	} break;
case 156:
/* # line 1738 "ascParse.y" */
{
	  /*
	   * This is proper procedural external method code.
	   */
	  zz_val.statptr = CreateCALL(zz_pvt[-0].id_ptr,g_callargs);
          g_callargs = NULL;
	} break;
case 157:
/* # line 1749 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != IF_T ) {
	    WarnMsg_MismatchEnd("IF", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  zz_val.statptr = CreateIF(zz_pvt[-4].eptr,zz_pvt[-2].slptr,zz_pvt[-1].slptr);
	} break;
case 158:
/* # line 1759 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != WHILE_T ) {
	    WarnMsg_MismatchEnd("WHILE", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  zz_val.statptr = CreateWhile(zz_pvt[-3].eptr,zz_pvt[-1].slptr);
	} break;
case 159:
/* # line 1768 "ascParse.y" */
{
	  zz_val.slptr = NULL;
	} break;
case 160:
/* # line 1772 "ascParse.y" */
{
	  zz_val.slptr = zz_pvt[-0].slptr;
	} break;
case 161:
/* # line 1779 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != WHEN_T ) {
	    WarnMsg_MismatchEnd("WHEN", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  ErrMsg_Generic("() missing in WHEN statement ");
	  DestroyWhenList(zz_pvt[-1].wptr);
	  DestroyVariableList(zz_pvt[-2].lptr);
	  g_untrapped_error++;
	  zz_val.statptr = NULL;
	} break;
case 162:
/* # line 1790 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != WHEN_T ) {
	    WarnMsg_MismatchEnd("WHEN", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  ErrMsg_Generic("() missing in WHEN statement ");
	  DestroyWhenList(zz_pvt[-1].wptr);
	  DestroyVariableList(zz_pvt[-2].lptr);
	  DestroyName(zz_pvt[-5].nptr);
	  g_untrapped_error++;
	  zz_val.statptr = NULL;
	} break;
case 163:
/* # line 1802 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != WHEN_T ) {
	    WarnMsg_MismatchEnd("WHEN", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  zz_val.statptr = CreateWHEN(NULL,zz_pvt[-3].lptr,zz_pvt[-1].wptr);
	} break;
case 164:
/* # line 1809 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != WHEN_T ) {
	    WarnMsg_MismatchEnd("WHEN", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  zz_val.statptr = CreateWHEN(zz_pvt[-7].nptr,zz_pvt[-3].lptr,zz_pvt[-1].wptr);
	} break;
case 165:
/* # line 1819 "ascParse.y" */
{
	  zz_val.wptr = ReverseWhenCases(zz_pvt[-0].wptr);
	} break;
case 166:
/* # line 1826 "ascParse.y" */
{
	  zz_val.wptr = CreateWhen(zz_pvt[-2].sptr,zz_pvt[-0].slptr);
	} break;
case 167:
/* # line 1830 "ascParse.y" */
{
	  zz_val.wptr = CreateWhen(NULL,zz_pvt[-0].slptr);
	} break;
case 168:
/* # line 1834 "ascParse.y" */
{
	  zz_val.wptr = LinkWhenCases(CreateWhen(zz_pvt[-2].sptr,zz_pvt[-0].slptr),zz_pvt[-4].wptr);
	} break;
case 169:
/* # line 1838 "ascParse.y" */
{
	  zz_val.wptr = LinkWhenCases(CreateWhen(NULL,zz_pvt[-0].slptr),zz_pvt[-3].wptr);
	} break;
case 170:
/* # line 1845 "ascParse.y" */
{
	  zz_val.statptr = CreateFlow(fc_break,NULL);
	} break;
case 171:
/* # line 1849 "ascParse.y" */
{
	  zz_val.statptr = CreateFlow(fc_continue,NULL);
	} break;
case 172:
/* # line 1853 "ascParse.y" */
{
	  zz_val.statptr = CreateFlow(fc_fallthru,NULL);
	} break;
case 173:
/* # line 1857 "ascParse.y" */
{
	  zz_val.statptr = CreateFlow(fc_return,NULL);
	} break;
case 174:
/* # line 1861 "ascParse.y" */
{
	  zz_val.statptr = CreateFlow(fc_stop,zz_pvt[-0].braced_ptr);
	} break;
case 175:
/* # line 1868 "ascParse.y" */
{
	  zz_val.statptr = CreateFNAME(zz_pvt[-0].nptr);
	} break;
case 176:
/* # line 1875 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != SELECT_T ) {
	    WarnMsg_MismatchEnd("SELECT", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  ErrMsg_Generic("() missing in SELECT statement ");
	  DestroySelectList(zz_pvt[-1].septr);
	  DestroyVariableList(zz_pvt[-2].lptr);
	  g_untrapped_error++;
	  zz_val.statptr = NULL;
	} break;
case 177:
/* # line 1886 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != SELECT_T ) {
	    WarnMsg_MismatchEnd("SELECT", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  zz_val.statptr = CreateSELECT(zz_pvt[-3].lptr,zz_pvt[-1].septr);
	} break;
case 178:
/* # line 1896 "ascParse.y" */
{
	  zz_val.septr = ReverseSelectCases(zz_pvt[-0].septr);
	} break;
case 179:
/* # line 1903 "ascParse.y" */
{
	  zz_val.septr = CreateSelect(zz_pvt[-2].sptr,zz_pvt[-0].slptr);
	} break;
case 180:
/* # line 1907 "ascParse.y" */
{
	  zz_val.septr = CreateSelect(NULL,zz_pvt[-0].slptr);
	} break;
case 181:
/* # line 1911 "ascParse.y" */
{
	  zz_val.septr = LinkSelectCases(CreateSelect(zz_pvt[-2].sptr,zz_pvt[-0].slptr),zz_pvt[-4].septr);
	} break;
case 182:
/* # line 1915 "ascParse.y" */
{
	  zz_val.septr = LinkSelectCases(CreateSelect(NULL,zz_pvt[-0].slptr),zz_pvt[-3].septr);
	} break;
case 183:
/* # line 1922 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != SWITCH_T ) {
	    WarnMsg_MismatchEnd("SWITCH", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  ErrMsg_Generic("() missing in SWITCH statement ");
	  DestroySwitchList(zz_pvt[-1].swptr);
	  DestroyVariableList(zz_pvt[-2].lptr);
	  g_untrapped_error++;
	  zz_val.statptr = NULL;
	} break;
case 184:
/* # line 1933 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != SWITCH_T ) {
	    WarnMsg_MismatchEnd("SWITCH", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  zz_val.statptr = CreateSWITCH(zz_pvt[-3].lptr,zz_pvt[-1].swptr);
	} break;
case 185:
/* # line 1943 "ascParse.y" */
{
	  zz_val.swptr = ReverseSwitchCases(zz_pvt[-0].swptr);
	} break;
case 186:
/* # line 1950 "ascParse.y" */
{
	  zz_val.swptr = CreateSwitch(zz_pvt[-2].sptr,zz_pvt[-0].slptr);
	} break;
case 187:
/* # line 1954 "ascParse.y" */
{
	  zz_val.swptr = CreateSwitch(NULL,zz_pvt[-0].slptr);
	} break;
case 188:
/* # line 1958 "ascParse.y" */
{
	  zz_val.swptr = LinkSwitchCases(CreateSwitch(zz_pvt[-2].sptr,zz_pvt[-0].slptr),zz_pvt[-4].swptr);
	} break;
case 189:
/* # line 1962 "ascParse.y" */
{
	  zz_val.swptr = LinkSwitchCases(CreateSwitch(NULL,zz_pvt[-0].slptr),zz_pvt[-3].swptr);
	} break;
case 190:
/* # line 1969 "ascParse.y" */
{
	  if( zz_pvt[-0].int_value != CONDITIONAL_T ) {
	    WarnMsg_MismatchEnd("CONDITIONAL", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  zz_val.statptr = CreateCOND(zz_pvt[-1].slptr);
	} break;
case 191:
/* # line 1979 "ascParse.y" */
{
	  /*  All processing of notes takes place on the notes_body here.
	   *  Notes should NOT be added to the statement list.
	   *  Here we know the current type and method names.
	   */
	  if( zz_pvt[-0].int_value != NOTES_T ) {
	    WarnMsg_MismatchEnd("NOTES", NULL, zz_pvt[-0].int_value, NULL);
	  }
	  if (zz_pvt[-1].notesptr != NULL) {
	    struct NoteTmp *nt;
	    symchar *lang=NULL; /* dummy */
	    nt = zz_pvt[-1].notesptr;
	    while (nt != NULL) {
	      if (nt->lang != NULL) {
	        /* this logic works because of the reverse sort that
	         * yacc does via noteslist and the forward sort that
	         * we do via notesbody. lang recorded last appears
	         * before other entries that need it.
	         */
	        lang = nt->lang;
	      }

	      /* save exploding vardata to simple entries until we keep */
	      CollectNote(CreateNote(g_type_name, lang, NULL, g_proc_name,
	                             Asc_ModuleBestName(Asc_CurrentModule()),
	                             nt->bt,
	                             nt->line, nt->vardata, nd_vlist));
	      nt = nt->next;
	    }
	    DestroyNoteTmpList(zz_pvt[-1].notesptr);
          }
	  zz_val.statptr = NULL;
	} break;
case 192:
/* # line 2016 "ascParse.y" */
{
	  /*  At this point we have the "language", the names of the
	   *  objects we are explaining, and the explanation/notes itself.
	   */
	  zz_val.notesptr = zz_pvt[-0].notesptr;
	  assert(zz_val.notesptr->lang == NULL);
	  zz_val.notesptr->lang = zz_pvt[-1].sym_ptr;
	} break;
case 193:
/* # line 2025 "ascParse.y" */
{
	  struct NoteTmp *nt;
	  zz_val.notesptr = zz_pvt[-2].notesptr;
	  assert(zz_pvt[-0].notesptr->lang == NULL);
	  zz_pvt[-0].notesptr->lang = zz_pvt[-1].sym_ptr;
	  nt = zz_val.notesptr;
	  while (nt->next != NULL) {
	    nt = nt->next;
	  }
	  LinkNoteTmp(nt,zz_pvt[-0].notesptr);
	} break;
case 194:
/* # line 2040 "ascParse.y" */
{
	  zz_val.notesptr = CreateNoteTmp(NULL, AddBraceChar(zz_pvt[-0].braced_ptr,NULL),
                             (void *)zz_pvt[-1].lptr, LineNum());
	} break;
case 195:
/* # line 2045 "ascParse.y" */
{
	  zz_val.notesptr = CreateNoteTmp(NULL, AddBraceChar(zz_pvt[-0].braced_ptr,NULL),
	                     (void *)zz_pvt[-1].lptr, LineNum());
	  LinkNoteTmp(zz_val.notesptr,zz_pvt[-2].notesptr);
	} break;
case 196:
/* # line 2054 "ascParse.y" */
{
	  /*
	   * Reversing the variable list is now essential to deal with
	   * external procedures and other things where order is important.
	   */
	  zz_val.lptr = ReverseVariableList(zz_pvt[-0].lptr);
	} break;
case 197:
/* # line 2065 "ascParse.y" */
{
	  zz_val.lptr = CreateVariableNode(zz_pvt[-0].nptr);
	} break;
case 198:
/* # line 2069 "ascParse.y" */
{
	  zz_val.lptr = CreateVariableNode(zz_pvt[-0].nptr);
	  LinkVariableNodes(zz_val.lptr,zz_pvt[-2].lptr);
	} break;
case 199:
/* # line 2074 "ascParse.y" */
{
	  ErrMsg_CommaName("name",zz_pvt[-0].nptr);
	  zz_val.lptr = CreateVariableNode(zz_pvt[-0].nptr);
	  LinkVariableNodes(zz_val.lptr,zz_pvt[-1].lptr);
	  /* trash the definition. keep the loose fname around because
	   * destroying here is inconvenient
	   */
	  g_untrapped_error++;
	} break;
case 200:
/* # line 2087 "ascParse.y" */
{
	  symchar *simple;
	  void *data;
	  enum NoteData nd;
	  zz_val.nptr = ReverseName(zz_pvt[-1].nptr);
	  if (zz_pvt[-0].dquote_ptr != NULL && zz_pvt[-1].nptr != NULL) {
            simple = SimpleNameIdPtr(zz_val.nptr);
	    data = (simple == NULL ? (void *)zz_val.nptr : NULL);
	    nd = (data == NULL ? nd_empty : nd_name);
	    CollectNote(CreateNote(g_type_name, InlineNote(), simple,
	                           g_proc_name,
	                           Asc_ModuleBestName(Asc_CurrentModule()),
	                           AddBraceChar(zz_pvt[-0].dquote_ptr,InlineNote()),
	                           LineNum(), data, nd));
	  }
	} break;
case 201:
/* # line 2107 "ascParse.y" */
{
	  zz_val.nptr = CreateIdName(zz_pvt[-0].id_ptr);
	} break;
case 202:
/* # line 2111 "ascParse.y" */
{
	  zz_val.nptr = CreateIdName(zz_pvt[-0].id_ptr);
	  LinkNames(zz_val.nptr,zz_pvt[-2].nptr);
	} break;
case 203:
/* # line 2116 "ascParse.y" */
{
	  if (zz_pvt[-1].sptr == NULL) {
	    FPRINTF(ASCERR,"%ssyntax error at %lu\n",StatioLabel(3),LineNum());
	    FPRINTF(ASCERR,"  Empty set in name definition\n");
	    FPRINTF(ASCERR,"  Name: ");
	    WriteName(ASCERR,zz_pvt[-3].nptr);
	    FPRINTF(ASCERR,"[]\n");
	    g_untrapped_error++;
	  } else {
	    zz_val.nptr = CreateSetName(zz_pvt[-1].sptr);
	    LinkNames(zz_val.nptr,zz_pvt[-3].nptr);
	  }
	} break;
case 204:
/* # line 2133 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = CONDITIONAL_T;
        } break;
case 205:
/* # line 2138 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = FOR_T;
        } break;
case 206:
/* # line 2143 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = IF_T;
        } break;
case 207:
/* # line 2148 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = INTERACTIVE_T;
        } break;
case 208:
/* # line 2153 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = METHODS_T;
        } break;
case 209:
/* # line 2158 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = NOTES_T;
        } break;
case 210:
/* # line 2163 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = SELECT_T;
        } break;
case 211:
/* # line 2168 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = SWITCH_T;
        } break;
case 212:
/* # line 2173 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = UNITS_T;
        } break;
case 213:
/* # line 2178 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = GLOBAL_T;
        } break;
case 214:
/* # line 2183 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = WHEN_T;
        } break;
case 215:
/* # line 2188 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = WHILE_T;
        } break;
case 216:
/* # line 2193 "ascParse.y" */
{
          g_end_identifier = zz_pvt[-0].id_ptr;
          zz_val.int_value = IDENTIFIER_T;
        } break;
case 217:
/* # line 2198 "ascParse.y" */
{
          g_end_identifier = NULL;
          zz_val.int_value = END_T;
        } break;
case 218:
/* # line 2206 "ascParse.y" */
{
	  zz_val.braced_ptr = NULL;
	} break;
case 219:
/* # line 2210 "ascParse.y" */
{
	  zz_val.braced_ptr = zz_pvt[-0].braced_ptr;
	} break;
case 220:
/* # line 2217 "ascParse.y" */
{
	  zz_val.dquote_ptr = NULL;
	} break;
case 221:
/* # line 2221 "ascParse.y" */
{
	  zz_val.dquote_ptr = zz_pvt[-0].dquote_ptr;
	} break;
case 222:
/* # line 2228 "ascParse.y" */
{
	  zz_val.sptr = ReverseSetList(zz_pvt[-0].sptr);
	} break;
case 223:
/* # line 2232 "ascParse.y" */
{
	  zz_val.sptr = NULL;
	} break;
case 224:
/* # line 2239 "ascParse.y" */
{
	  zz_val.sptr = CreateSingleSet(zz_pvt[-0].eptr);
	} break;
case 225:
/* # line 2243 "ascParse.y" */
{
	  zz_val.sptr = CreateRangeSet(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 226:
/* # line 2247 "ascParse.y" */
{
	  zz_val.sptr = CreateSingleSet(zz_pvt[-0].eptr);
	  LinkSets(zz_val.sptr,zz_pvt[-2].sptr);
	} break;
case 227:
/* # line 2252 "ascParse.y" */
{
	  zz_val.sptr = CreateRangeSet(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	  LinkSets(zz_val.sptr,zz_pvt[-4].sptr);
	} break;
case 228:
/* # line 2260 "ascParse.y" */
{
	  zz_val.real_value = zz_pvt[-0].int_value;
	  g_constant_type = LONGCONSTANT;
	  g_default_dim_ptr = Dimensionless();
	} break;
case 229:
/* # line 2266 "ascParse.y" */
{
	  zz_val.real_value = zz_pvt[-0].real_value;
	  g_constant_type = DOUBLECONSTANT;
	  g_default_dim_ptr = g_dim_ptr;
	} break;
case 230:
/* # line 2275 "ascParse.y" */
{
	  zz_val.real_value = zz_pvt[-1].real_value*zz_pvt[-0].real_value;
	} break;
case 231:
/* # line 2279 "ascParse.y" */
{
	  unsigned long pos;
	  int error_code;
	  g_units_ptr = FindOrDefineUnits(zz_pvt[-0].braced_ptr,&pos,&error_code);
	  if (g_units_ptr != NULL) {
	    zz_val.real_value = (double)zz_pvt[-1].int_value*UnitsConvFactor(g_units_ptr);
	    g_dim_ptr = UnitsDimensions(g_units_ptr);
	  } else {
            char **errv;
	    zz_val.real_value = (double)zz_pvt[-1].int_value;
	    g_dim_ptr = WildDimension();
	    FPRINTF(ASCERR,"%sUndefined units {%s} %s:%lu.\n",StatioLabel(3),
	            zz_pvt[-0].braced_ptr,Asc_ModuleBestName(Asc_CurrentModule()),LineNum());
            errv = UnitsExplainError(zz_pvt[-0].braced_ptr,error_code,pos);
	    FPRINTF(ASCERR,"  %s\n  %s\n  %s\n",errv[0],errv[1],errv[2]);
	    g_untrapped_error++;
	  }
	} break;
case 232:
/* # line 2301 "ascParse.y" */
{
	  g_dim_ptr = Dimensionless();
	  zz_val.real_value = 1.0;
	} break;
case 233:
/* # line 2306 "ascParse.y" */
{
	  unsigned long pos;
	  int error_code;
	  g_units_ptr = FindOrDefineUnits(zz_pvt[-0].braced_ptr,&pos,&error_code);
	  if (g_units_ptr != NULL) {
	    zz_val.real_value = UnitsConvFactor(g_units_ptr);
	    g_dim_ptr = UnitsDimensions(g_units_ptr);
	  } else {
            char **errv;
	    zz_val.real_value = 1.0;
	    g_dim_ptr = WildDimension();
	    FPRINTF(ASCERR,"%sUndefined units {%s} %s:%lu.\n",StatioLabel(3),
	            zz_pvt[-0].braced_ptr,Asc_ModuleBestName(Asc_CurrentModule()),LineNum());
            errv = UnitsExplainError(zz_pvt[-0].braced_ptr,error_code,pos);
	    FPRINTF(ASCERR,"  %s\n  %s\n  %s\n",errv[0],errv[1],errv[2]);
	    g_untrapped_error++;
	  }
	} break;
case 234:
/* # line 2328 "ascParse.y" */
{
	  zz_val.dimp = zz_pvt[-0].dimp;
	} break;
case 235:
/* # line 2332 "ascParse.y" */
{
	  zz_val.dimp = Dimensionless();
	} break;
case 236:
/* # line 2336 "ascParse.y" */
{
	  zz_val.dimp = WildDimension();
	} break;
case 237:
/* # line 2343 "ascParse.y" */
{
	  zz_val.dimp = WildDimension();
	} break;
case 238:
/* # line 2347 "ascParse.y" */
{
	  zz_val.dimp = FindOrAddDimen(&(zz_pvt[-0].dimen));
	} break;
case 239:
/* # line 2354 "ascParse.y" */
{
	  ParseDim(&(zz_val.dimen),SCP(zz_pvt[-0].id_ptr));
	} break;
case 240:
/* # line 2358 "ascParse.y" */
{
	  ClearDimensions(&(zz_val.dimen));
	} break;
case 241:
/* # line 2362 "ascParse.y" */
{
	  zz_val.dimen = SubDimensions(&(zz_pvt[-2].dimen),&(zz_pvt[-0].dimen));
	} break;
case 242:
/* # line 2366 "ascParse.y" */
{
	  zz_val.dimen = AddDimensions(&(zz_pvt[-2].dimen),&(zz_pvt[-0].dimen));
	} break;
case 243:
/* # line 2370 "ascParse.y" */
{
	  zz_val.dimen = ScaleDimensions(&(zz_pvt[-2].dimen),zz_pvt[-0].frac_value);
	} break;
case 244:
/* # line 2374 "ascParse.y" */
{
	  CopyDimensions(&(zz_pvt[-1].dimen),&(zz_val.dimen));
	} break;
case 245:
/* # line 2381 "ascParse.y" */
{
	  zz_val.frac_value = zz_pvt[-1].int_value ? NegateF(zz_pvt[-0].frac_value) : zz_pvt[-0].frac_value;
	} break;
case 246:
/* # line 2388 "ascParse.y" */
{
	  zz_val.frac_value = CreateFraction((short)zz_pvt[-0].int_value,(short)1);
	} break;
case 247:
/* # line 2392 "ascParse.y" */
{
	  zz_val.frac_value = CreateFraction((short)zz_pvt[-3].int_value,(short)zz_pvt[-1].int_value);
	} break;
case 248:
/* # line 2399 "ascParse.y" */
{
	  zz_val.int_value = 0;
	} break;
case 249:
/* # line 2403 "ascParse.y" */
{
	  zz_val.int_value = 0;
	} break;
case 250:
/* # line 2407 "ascParse.y" */
{
	  zz_val.int_value = 1;
	} break;
case 251:
/* # line 2414 "ascParse.y" */
{
	  zz_val.eptr = CreateIntExpr(zz_pvt[-0].int_value);
	} break;
case 252:
/* # line 2418 "ascParse.y" */
{
	  zz_val.eptr = CreateIntExpr(LONG_MAX-1);
	} break;
case 253:
/* # line 2422 "ascParse.y" */
{
	  zz_val.eptr = CreateRealExpr(zz_pvt[-0].real_value,g_dim_ptr);
	} break;
case 254:
/* # line 2426 "ascParse.y" */
{
	  zz_val.eptr = CreateRealExpr(DBL_MAX/(1+1e-15),Dimensionless());
	} break;
case 255:
/* # line 2430 "ascParse.y" */
{
	  zz_val.eptr = CreateTrueExpr();
	} break;
case 256:
/* # line 2434 "ascParse.y" */
{
	  zz_val.eptr = CreateFalseExpr();
	} break;
case 257:
/* # line 2438 "ascParse.y" */
{
	  zz_val.eptr = CreateAnyExpr();
	} break;
case 258:
/* # line 2442 "ascParse.y" */
{
	  zz_val.eptr = CreateSymbolExpr(zz_pvt[-0].sym_ptr);
	} break;
case 259:
/* # line 2446 "ascParse.y" */
{
	  zz_val.eptr = CreateVarExpr(zz_pvt[-0].nptr);
	} break;
case 260:
/* # line 2450 "ascParse.y" */
{
	  zz_val.eptr = CreateSetExpr(zz_pvt[-1].sptr);
	} break;
case 261:
/* # line 2454 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_plus));
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 262:
/* # line 2459 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_minus));
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 263:
/* # line 2464 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_times));
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 264:
/* # line 2469 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_divide));
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 265:
/* # line 2474 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_power));
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 266:
/* # line 2479 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_and));
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 267:
/* # line 2484 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_or));
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 268:
/* # line 2489 "ascParse.y" */
{
	  zz_val.eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_not));
	} break;
case 269:
/* # line 2493 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,zz_pvt[-1].eptr);
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 270:
/* # line 2498 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,zz_pvt[-1].eptr);
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 271:
/* # line 2503 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_in));
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 272:
/* # line 2508 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_st));
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 273:
/* # line 2513 "ascParse.y" */
{
	  zz_pvt[-0].eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_st));
	  zz_val.eptr = JoinExprLists(zz_pvt[-2].eptr,zz_pvt[-0].eptr);
	} break;
case 274:
/* # line 2518 "ascParse.y" */
{
	  zz_val.eptr = zz_pvt[-0].eptr;
	} break;
case 275:
/* # line 2522 "ascParse.y" */
{
	  zz_val.eptr = JoinExprLists(zz_pvt[-0].eptr,CreateOpExpr(e_uminus));
	} break;
case 276:
/* # line 2526 "ascParse.y" */
{
	  zz_val.eptr = CreateSatisfiedExpr(zz_pvt[-3].nptr,zz_pvt[-1].real_value,g_dim_ptr);
	} break;
case 277:
/* # line 2530 "ascParse.y" */
{
	  zz_val.eptr = CreateSatisfiedExpr(zz_pvt[-1].nptr,DBL_MAX,NULL);
	} break;
case 278:
/* # line 2534 "ascParse.y" */
{
	  DestroySetList(zz_pvt[-1].sptr);
	  zz_val.eptr = NULL;
	  ErrMsg_ParensBrackets("SUM");
	  g_untrapped_error++;
	} break;
case 279:
/* # line 2541 "ascParse.y" */
{
	  zz_val.eptr = CreateBuiltin(e_sum,zz_pvt[-1].sptr);
	} break;
case 280:
/* # line 2545 "ascParse.y" */
{
	  DestroySetList(zz_pvt[-1].sptr);
	  zz_val.eptr = NULL;
	  ErrMsg_ParensBrackets("PROD");
	  g_untrapped_error++;
	} break;
case 281:
/* # line 2552 "ascParse.y" */
{
	  zz_val.eptr = CreateBuiltin(e_prod,zz_pvt[-1].sptr);
	} break;
case 282:
/* # line 2556 "ascParse.y" */
{
	  DestroySetList(zz_pvt[-1].sptr);
	  zz_val.eptr = NULL;
	  ErrMsg_ParensBrackets("UNION");
	  g_untrapped_error++;
	} break;
case 283:
/* # line 2563 "ascParse.y" */
{
	  zz_val.eptr = CreateBuiltin(e_union,zz_pvt[-1].sptr);
	} break;
case 284:
/* # line 2567 "ascParse.y" */
{
	  DestroySetList(zz_pvt[-1].sptr);
	  zz_val.eptr = NULL;
	  ErrMsg_ParensBrackets("INTERSECTION");
	  g_untrapped_error++;
	} break;
case 285:
/* # line 2574 "ascParse.y" */
{
	  zz_val.eptr = CreateBuiltin(e_inter,zz_pvt[-1].sptr);
	} break;
case 286:
/* # line 2578 "ascParse.y" */
{
	  DestroySetList(zz_pvt[-1].sptr);
	  zz_val.eptr = NULL;
	  ErrMsg_ParensBrackets("CARD");
	  g_untrapped_error++;
	} break;
case 287:
/* # line 2585 "ascParse.y" */
{
	  zz_val.eptr = CreateBuiltin(e_card,zz_pvt[-1].sptr);
	} break;
case 288:
/* # line 2589 "ascParse.y" */
{
	  DestroySetList(zz_pvt[-1].sptr);
	  zz_val.eptr = NULL;
	  ErrMsg_ParensBrackets("CHOICE");
	  g_untrapped_error++;
	} break;
case 289:
/* # line 2596 "ascParse.y" */
{
	  zz_val.eptr = CreateBuiltin(e_choice,zz_pvt[-1].sptr);
	} break;
case 290:
/* # line 2600 "ascParse.y" */
{
	  CONST struct Func *fptr;
	  if ((fptr = LookupFunc(SCP(zz_pvt[-3].id_ptr)))!=NULL) {
	    zz_val.eptr = JoinExprLists(zz_pvt[-1].eptr,CreateFuncExpr(fptr));
	  } else {
	    zz_val.eptr = NULL;
	    FPRINTF(ASCERR,"%sFunction %s is not defined.\n",
	            StatioLabel(3),SCP(zz_pvt[-3].id_ptr));
	    FPRINTF(ASCERR,"  File name: %s:%lu\n",
	            Asc_ModuleBestName(Asc_CurrentModule()),
	            LineNum());
	    g_untrapped_error++;
	  }
	} break;
case 291:
/* # line 2615 "ascParse.y" */
{
	  zz_val.eptr = zz_pvt[-1].eptr;
	} break;
case 292:
/* # line 2622 "ascParse.y" */
{
	  zz_val.eptr = CreateOpExpr(e_equal);
	} break;
case 293:
/* # line 2626 "ascParse.y" */
{
	  zz_val.eptr = CreateOpExpr(e_less);
	} break;
case 294:
/* # line 2630 "ascParse.y" */
{
	  zz_val.eptr = CreateOpExpr(e_greater);
	} break;
case 295:
/* # line 2634 "ascParse.y" */
{
	  zz_val.eptr = CreateOpExpr(e_lesseq);
	} break;
case 296:
/* # line 2638 "ascParse.y" */
{
	  zz_val.eptr = CreateOpExpr(e_greatereq);
	} break;
case 297:
/* # line 2642 "ascParse.y" */
{
	  zz_val.eptr = CreateOpExpr(e_notequal);
	} break;
case 298:
/* # line 2649 "ascParse.y" */
{
	  zz_val.eptr = CreateOpExpr(e_boolean_eq);
	} break;
case 299:
/* # line 2653 "ascParse.y" */
{
	  zz_val.eptr = CreateOpExpr(e_boolean_neq);
	} break;
	}
	goto zz_stack;		/* reset registers in driver code */
}

# ifdef __RUNTIME_ZZ_MAXDEPTH

static int allocate_stacks() {
	/* allocate the zz_s and zz_v stacks */
	zz_s = (int *) malloc(zz_maxdepth * sizeof(int));
	zz_v = (ZZ_STYPE *) malloc(zz_maxdepth * sizeof(ZZ_STYPE));

	if (zz_s==0 || zz_v==0) {
	   zz_error( (nl_msg(30004,"unable to allocate space for yacc stacks")) );
	   return(1);
	   }
	else return(0);

}


static void free_stacks() {
	if (zz_s!=0) free((char *) zz_s);
	if (zz_v!=0) free((char *) zz_v);
}

# endif  /* defined(__RUNTIME_ZZ_MAXDEPTH) */

