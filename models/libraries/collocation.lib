(********************************************************************

  collocation.lib
  by Robert S. Huss
  Part OF the ASCEND Library

This file is part of the Ascend modeling library.

Copyright (C) 1994

The Ascend modeling library is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

The Ascend Language Interpreter is distributed in hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
  
    ********************************************************************)

(*********************************************************************\
  $Date: 1997/07/03 14:49:44 $
  $Revision: 1.6 $
  $Author: mthomas $
  $Source: /afs/cs.cmu.edu/project/ascend/Repository/models/libraries/collocation.lib,v $
\*********************************************************************)
(*
	C O L L O C A T I O N . L I B
	-----------------------------

	AUTHOR:		Robert S. Huss

	DATES:		5/95 - First Public Release
                        4/96 - Modified for using constant instance types
	

	CONTENTS:	Collocation models for distillation modeling. 


			 

	REQUIRES:	"system.lib"
	                "atoms.lib"
			"components.lib"
			"H_S_thermodynamics.lib" or "H_G_thermodynamics.lib"
			"plot.lib"
			"stream.lib"
			"flash.lib"

*)


(* REQUIRE flash.lib *)
(* REQUIRE plot.lib *)


MODEL lagrange_polynomial;

	npoints,
	ntrays,
	order					IS_A integer_constant;
	W[0..npoints][0..order],
	w_tray[0..ntrays+1],
	w_points[0..npoints],
	w_mid					IS_A factor;
	f_int,
	f_mid					IS_A fraction;
	scale					IS_A scaling_constant;
	

	change[1..ntrays]			IS_A factor;

	change[1..ntrays] := 1.0;

	npoints :== 2*ntrays + 1;
	order :== ntrays;

	w_tray[0],
	    w_points[0]				ARE_THE_SAME;
	w_tray[ntrays+1],
	w_points[npoints]			ARE_THE_SAME;

	w_mid = w_tray[0] + f_mid*(w_tray[ntrays+1] - w_tray[0]);

	f_mid := 0.5;

	FOR i IN [0..npoints] CREATE
	    FOR k IN [0..ntrays] CREATE
		W[i][k] = PROD[(w_points[i] - w_tray[j])
		    / (w_tray[k] - w_tray[j]) | j IN
		    [0..k-1,k+1..ntrays]];
	    END FOR;
	END FOR;

  METHODS

     METHOD clear;
	W[0..npoints][0..order].fixed 	:= FALSE;
	w_tray[0..ntrays+1].fixed	:= FALSE;
	w_points[0..npoints].fixed 	:= FALSE;
	w_mid.fixed 			:= FALSE;
	f_int.fixed 			:= FALSE;
	f_mid.fixed			:= FALSE;
	change[1..ntrays].fixed		:= FALSE;
     END clear;
     METHOD specify;
	w_points[0..npoints].fixed	:= TRUE;
	f_int.fixed 			:= TRUE;
	f_mid.fixed			:= TRUE;
	change[1..ntrays].fixed		:= TRUE;
     END specify;
     METHOD reset;
	RUN clear;
	RUN specify;
     END reset;
     METHOD scale;
	 f_int.nominal := f_int;
	 f_mid.nominal := f_mid;
	 FOR j IN [1..ntrays] DO
	     change[j].nominal := abs(change[j]);
	     change[j].lower_bound := change[j] -
		 scale*change[j].nominal;
	     change[j].upper_bound := change[j] +
		 scale*change[j].nominal;
	 END FOR;
	 FOR i IN [0..npoints] DO
	     w_points[i].nominal := abs(w_points[i]) + 0.01;
	     w_points[i].lower_bound := -2.0;
	     w_points[i].upper_bound := abs(w_points[i]) +
		 scale*w_points[i].nominal;
	     
	     FOR j IN [0..order] DO
		 W[i][j].nominal := abs(W[i][j]) + 0.01;
		 W[i][j].lower_bound := W[i][j] -
		     scale*W[i][j].nominal;
		  W[i][j].upper_bound := W[i][j] +
		     scale*W[i][j].nominal;
	 
	     END FOR;
	 END FOR;
	 FOR j IN [0..ntrays+1] DO
	     w_tray[j].nominal := abs(w_tray[j]) + 0.01;
	     w_tray[j].lower_bound := -2.0;
	     w_tray[j].upper_bound := w_tray[j] +
		 scale*w_tray[j].nominal;
	 END FOR;
	 w_mid.nominal := abs(w_mid) + 0.01;
	 w_mid.lower_bound := -2.0;
	 w_mid.upper_bound := w_mid + scale*w_mid.nominal;
     END scale;
     
END lagrange_polynomial;

MODEL lgr_1_point REFINES lagrange_polynomial;

	ntrays :== 1;

	w_mid,
	w_tray[1]			ARE_THE_SAME;


END lgr_1_point;

MODEL lgr_2_points REFINES lagrange_polynomial;

	ntrays :== 2;

	f_int := 0.333;
		

	w_tray[1] = w_mid - change[1]*f_int
	    *(w_mid - w_tray[0]);
	w_tray[2] = w_mid + change[2]*f_int
	    *(w_tray[ntrays+1] - w_mid);

END lgr_2_points;

MODEL lgr_3_points REFINES lagrange_polynomial;

	ntrays :== 3;
	
	f_int := 0.5;
	w_tray[1] = w_mid - change[1]*f_int
	    *(w_mid - w_tray[0]);
	
	w_tray[2], w_mid		ARE_THE_SAME;
	
	w_tray[3] = w_mid + change[3]*f_int
	    *(w_tray[ntrays+1] - w_mid);

END lgr_3_points;

MODEL lgr_4_points REFINES lagrange_polynomial;

	ntrays :== 4;

	f_int := 0.6;
	w_tray[1] = w_mid - f_int*change[1]
	    *(w_mid - w_tray[0]);
	w_tray[2] = w_mid - f_int*change[2]
	    *(w_mid - w_tray[0])/3;
	w_tray[3] = w_mid + f_int*change[3]
	    *(w_tray[ntrays+1] - w_mid)/3;
	w_tray[4] = w_mid + f_int*change[4]
	    *(w_tray[ntrays+1] - w_mid);


END lgr_4_points;

MODEL lgr_5_points REFINES lagrange_polynomial;

	ntrays :== 5;

	f_int := 0.66666667;
	w_tray[1] = w_mid - f_int*(w_mid - w_tray[0]);
	w_tray[2] = w_mid - f_int*(w_mid - w_tray[0])/2;
	w_tray[3], w_mid		ARE_THE_SAME;
	w_tray[4] = w_mid + f_int*(w_tray[ntrays+1] - w_mid)/2;
	w_tray[5] = w_mid + f_int*(w_tray[ntrays+1] - w_mid);


END lgr_5_points;

MODEL t_lagrange;

	lgr[1..5] IS_A lagrange_polynomial;

	lgr[1] IS_REFINED_TO lgr_1_point;
	lgr[2] IS_REFINED_TO lgr_2_points;
	lgr[3] IS_REFINED_TO lgr_3_points;
	lgr[4] IS_REFINED_TO lgr_4_points;
	lgr[5] IS_REFINED_TO lgr_5_points;

END t_lagrange;
    

MODEL collpoint;
	a,
	z,s,
	ztop				IS_A factor;
	scale				IS_A scaling_constant;

	s_def: z = 1-exp(-a*s);
	ztopdefn: ztop = 1-(1-z)*exp(-up_down*a);

	up_down				IS_A real;

	a					:= 0.1;
	z					:= 0.5;
	ztop					:= 0.5;
	s					:= 1;


	a.lower_bound 				:= 0.0;
	a.upper_bound				:= 3.0;
	z.lower_bound				:= -0.5;
	ztop.lower_bound			:= -0.5;
	z.upper_bound				:= 1.0;
	ztop.upper_bound			:= 1.0;
	s.lower_bound				:= 0.0;
	

  METHODS
    METHOD scale;
	a.nominal := a + 0.01;
	z.nominal := abs(z) + 0.01;
	s.nominal := s + 0.01;
	ztop.nominal := abs(ztop) + 0.01;
	a.lower_bound := 0.0;
	a.upper_bound := 3.0;
	z.lower_bound := -0.5;
	z.upper_bound := 1.0;
	s.lower_bound := 0.0;
	s.upper_bound := s + scale*s.nominal;
	ztop.lower_bound := -0.5;
	ztop.upper_bound := 1.0;
    END scale;
    
	
     METHOD seqmod;
	a.fixed					:= TRUE;
	s.fixed					:= TRUE;
     END seqmod;

     METHOD specify;
	RUN seqmod;
     END specify;
     METHOD clear;
	a.fixed					:= FALSE;
	z.fixed					:= FALSE;
	ztop.fixed				:= FALSE;
	s_def.included				:= TRUE;
	ztopdefn.included			:= TRUE;
     END clear;
     METHOD reset;
	RUN clear;
	RUN specify;
     END reset;
     METHOD s_off;
	s_def.included				:= FALSE;
	s.fixed					:= TRUE;
     END s_off;
END collpoint;


MODEL z_set;

	ntrays				IS_A integer_constant;
	a,
	    s_values[0..ntrays+1],
	    z_values[0..ntrays+1],
	    stot			IS_A factor;
	up_down				IS_A real;


	z[0..ntrays+1]			IS_A collpoint;
	ztop,
	    zbot			IS_A factor;

	lgr				IS_A lagrange_polynomial;
	z_on				IS_A boolean;
	scale				IS_A scaling_constant;

	z_on := FALSE;

	lgr.ntrays, ntrays		ARE_THE_SAME;



	stot = s_values[ntrays+1] - s_values[0];

	FOR j IN [0..ntrays+1] CREATE
	    z[j].z,
		z_values[j]		ARE_THE_SAME;
	    z[j].s,
		s_values[j]		ARE_THE_SAME;
	END FOR;
	up_down,
	    z[0..ntrays+1].up_down		ARE_THE_SAME;

	s_values[0] := 0;
	z_values[0] := 0;

	a,
	    z[0..ntrays+1].a		ARE_THE_SAME;

	stot.lower_bound := 0.0;


	FOR j IN [1..ntrays] CREATE
	    lgr.w_points[2*j-1],
		lgr.w_tray[j]		ARE_THE_SAME;
	END FOR;


	(*	z_based		*)

	FOR j IN [1..ntrays] CREATE

	    z_based_odd[2*j-1]: lgr.w_points[2*j-1] = 
		z_values[j];
	    z_based_even[2*j]: lgr.w_points[2*j] =
		z[j].ztop;
	END FOR;

	z_based_0: lgr.w_points[0] = z_values[0];
	z_based_n: lgr.w_points[lgr.npoints] =
	    z_values[ntrays+1];


	(*	s_based	 	*)

	FOR j IN [1..ntrays] CREATE

	    s_based_odd[2*j-1]: lgr.w_points[2*j-1] = 
		s_values[j];
	    s_based_even[2*j]: lgr.w_points[2*j] =
		s_values[j] + z[0].up_down;
	END FOR;

	s_based_0: lgr.w_points[0] = s_values[0];
	s_based_n: lgr.w_points[lgr.npoints] =
	    s_values[ntrays+1];


	ztop = (up_down+1)*z_values[ntrays+1]/2 +(1-up_down)*z_values[0]/2;
	zbot = (up_down+1)*z_values[0]/2 +(1-up_down)*z_values[ntrays+1]/2;

	tray_delta		IS_A factor;

	s_values[ntrays] + tray_delta = s_values[ntrays+1];


  METHODS
    METHOD scale;
	RUN z[0..ntrays+1].scale;
	RUN lgr.scale;
	stot.nominal := stot + 0.01;
	stot.lower_bound := 1e-8;
	stot.upper_bound := stot + scale*stot.nominal;
	tray_delta.nominal := tray_delta + 0.01;
	tray_delta.lower_bound := 1e-8;
	tray_delta.upper_bound := tray_delta +
	    scale*tray_delta.nominal;
	ztop.nominal := abs(ztop) + 0.01;
	ztop.lower_bound := -0.5;
	ztop.upper_bound := 1.0;
	zbot.nominal := abs(zbot) + 0.01;
	zbot.lower_bound := -0.5;
	zbot.upper_bound := 1.0;
    END scale;

    METHOD clear;
	z_values[0..ntrays+1].fixed		:= FALSE;
	s_values[0..ntrays+1].fixed		:= FALSE;
	RUN z[0..ntrays+1].clear;
	ztop.fixed				:= FALSE;
	zbot.fixed				:= FALSE;
	stot.fixed				:= FALSE;
	a.fixed					:= FALSE;
	FOR j IN [1..ntrays] DO
	    z_based_odd[2*j-1].included 	:= TRUE;
	    z_based_even[2*j].included 		:= TRUE;
	    s_based_odd[2*j-1].included 	:= TRUE;
	    s_based_even[2*j].included 		:= TRUE;
	END FOR;
	z_based_0.included 			:= TRUE;
	z_based_n.included 			:= TRUE;
	s_based_0.included 			:= TRUE;
	s_based_n.included 			:= TRUE;
	RUN lgr.clear;
	tray_delta.fixed 			:= FALSE;
    END clear;
    METHOD specify;
	RUN lgr.specify;
	lgr.w_points[0..lgr.npoints].fixed 	:= FALSE;
	a.fixed					:= TRUE;
	s_values[0].fixed			:= TRUE;
	stot.fixed				:= TRUE;
	IF (z_on) THEN
	    RUN z_based_poly;
	ELSE
	    RUN s_based_poly;
	END FOR;
    END specify;
    METHOD reset;
	RUN clear;
	RUN specify;
    END reset;
    METHOD z_based_poly;
	FOR j IN [1..ntrays] DO
	    z_based_odd[2*j-1].included 	:= TRUE;
	    z_based_even[2*j].included 		:= TRUE;
	    s_based_odd[2*j-1].included 	:= FALSE;
	    s_based_even[2*j].included 		:= FALSE;
	END FOR;
	z_based_0.included 			:= TRUE;
	z_based_n.included 			:= TRUE;
	s_based_0.included 			:= FALSE;
	s_based_n.included 			:= FALSE;
	z_on 					:= TRUE;
    END z_based_poly;
    METHOD s_based_poly;
	FOR j IN [1..ntrays] DO
	    z_based_odd[2*j-1].included 	:= FALSE;
	    z_based_even[2*j].included 		:= FALSE;
	    s_based_odd[2*j-1].included 	:= TRUE;
	    s_based_even[2*j].included 		:= TRUE;
	END FOR;
	z_based_0.included 			:= FALSE;
	z_based_n.included 			:= FALSE;
	s_based_0.included 			:= TRUE;
	s_based_n.included 			:= TRUE;
	z_on 					:= FALSE;
    END s_based_poly;
    METHOD s_off;
	RUN z[ntrays..ntrays+1].s_off;
    END s_off;
    METHOD pin_end;
	tray_delta.fixed 			:= TRUE;
	tray_delta := 1.0;
	lgr.change[ntrays].fixed 		:= FALSE;
    END pin_end;

END z_set;

MODEL coll;
	components			IS_A set OF symbol_constant;
	inactive_component		IS_A symbol_constant;
	ntrays,
	    x_order,
	    y_order				IS_A integer_constant;
	topliq,
	    botliq,
	    topvap,
	    botvap				IS_A molar_stream;
	x_coeff[components
	    - [inactive_component]]
	    [0..x_order],
	    y_coeff[components
	    - [inactive_component]]
	    [0..y_order],
	    cmo[1..ntrays],
	    cmotot				IS_A factor;
	tray[1..ntrays]			IS_A simple_tray;
	z_set				IS_A z_set;
	z_on,
	    hat_on				IS_A boolean;
	x[1..ntrays][components]	IS_A fraction;
	y[1..ntrays][components]	IS_A fraction;
	x_hat[1..ntrays][components]	IS_A factor;
	scale				IS_A scaling_constant;

	z_on 		:= FALSE;
	hat_on 		:= FALSE;

	FOR i IN components CREATE
	    FOR j IN [1..ntrays] CREATE
		x[j][i] = (1+z_set.up_down)
		    *tray[ntrays+1-j].liqout['liquid'].state.y[i]/2
		    + (1-z_set.up_down)
		    *tray[j].liqout['liquid'].state.y[i]/2;
		y[j][i] = (1+z_set.up_down)
		    *tray[ntrays+1-j].input['vapor'].state.y[i]/2
		    + (1-z_set.up_down)
		    *tray[j].input['vapor'].state.y[i]/2;
		x_hat[j][i] = (1+z_set.up_down)
		    *tray_x_hat['out'][i][ntrays+1-j]/2
		    + (1-z_set.up_down)
		    *tray_x_hat['out'][i][j]/2;
	    END FOR;
	END FOR;

	x_order 	:== ntrays;
	y_order 	:== ntrays;

	z_on,
	    z_set.z_on			ARE_THE_SAME;

	y_coeff[components - [inactive_component]][0..y_order] := 0.5;
	x_coeff[components - [inactive_component]][0..x_order] := 0.5;

	components,
	    topliq.components,
	    topvap.components,
	    botliq.components,
	    botvap.components,
	    tray[1..ntrays].components	ARE_THE_SAME;

	ntrays,
	    z_set.ntrays			ARE_THE_SAME;


	tray[1..ntrays].VLE		ARE_ALIKE;


	tray[1..ntrays]			ARE_ALIKE;

	(* constant molar overflow model - instead of heat balance *)

	FOR j IN [1..ntrays] CREATE
	    cmo[j]*tray[j].input['liquid'].Ftot = botliq.Ftot;
	END FOR;

	cmotot*topliq.Ftot = botliq.Ftot;

	FOR i IN components CREATE
	    overall_MB[i]: topliq.f[i] - topvap.f[i] =
		botliq.f[i] - botvap.f[i];
	END FOR;


	tray[1..ntrays].liqout['liquid'].state	ARE_ALIKE;
	tray[1..ntrays].vapout['vapor'].state	ARE_ALIKE;

	(* xtrans stuff *)

	tray_x_hat['in','out'][components][1..ntrays],
	    tray_y_hat['in','out'][components][1..ntrays],
	    end_x_hat['top','bot'][components],
	    end_y_hat['top','bot'][components]	IS_A factor;
	td		IS_A real;

	td := 1.0;

	tray_x_hat['in','out'][components][1..ntrays].nominal := 20;
	tray_y_hat['in','out'][components][1..ntrays].nominal := 20;
	end_x_hat['top','bot'][components].nominal := 20;
	end_y_hat['top','bot'][components].nominal := 20;

	tray_x_hat['in','out'][components][1..ntrays] := 1;
	tray_y_hat['in','out'][components][1..ntrays] := 1;
	end_x_hat['top','bot'][components] := 1;
	end_y_hat['top','bot'][components] := 1;

	FOR i IN components CREATE
	    (1.0)*(2.0*botliq.state.y[i] - 1.0)
		= tanh(end_x_hat['bot'][i]*td);
	    (1.0)*(2.0*topliq.state.y[i] - 1.0)
		= tanh(end_x_hat['top'][i]*td); 
	    (1.0)*(2.0*botvap.state.y[i] - 1.0)
		= tanh(end_y_hat['bot'][i]*td); 
	    (1.0)*(2.0*topvap.state.y[i] - 1.0)
		= tanh(end_y_hat['top'][i]*td); 

	END FOR;

	FOR i IN components CREATE

	    FOR j IN [1..ntrays] CREATE

		(1.0)*(2.0*tray[j].liqout['liquid'].state.y[i] - 1.0)
		    = tanh(tray_x_hat['out'][i][j]*td);
		(1.0)*(2.0*tray[j].input['liquid'].state.y[i] - 1.0)
		    = tanh(tray_x_hat['in'][i][j]*td); 
		(1.0)*(2.0*tray[j].vapout['vapor'].state.y[i] - 1.0)
		    = tanh(tray_y_hat['out'][i][j]*td); 
		(1.0)*(2.0*tray[j].input['vapor'].state.y[i] - 1.0)
		    = tanh(tray_y_hat['in'][i][j]*td); 
	    END FOR;
	END FOR;

	(* polynomial *)

	(* Overall material balances *)

	FOR j IN [1..ntrays] CREATE
	    tot_trayMB[j]: botvap.Ftot - botliq.Ftot =
		tray[j].vapout['vapor'].Ftot -
		tray[j].input['liquid'].Ftot;

	END FOR;

	FOR i IN components - [inactive_component] CREATE
	    FOR j IN [1..ntrays] CREATE
		frac_x_in[j][i]:  tray[j].input['liquid'].state.y[i] =
		    SUM[z_set.lgr.W[2*j][k]*x_coeff[i][k]
		    | k IN [0..x_order]];
		frac_y_in[j][i]:  tray[j].input['vapor'].state.y[i] =
		    SUM[z_set.lgr.W[2*j-1][k]*y_coeff[i][k]
		    | k IN [0..y_order]];
		frac_x_out[j][i]:  tray[j].liqout['liquid'].state.y[i] =
		    SUM[z_set.lgr.W[2*j-1][k]*x_coeff[i][k]
		    | k IN [0..x_order]];
		frac_y_out[j][i]:  tray[j].vapout['vapor'].state.y[i] =
		    SUM[z_set.lgr.W[2*j][k]*y_coeff[i][k]
		    | k IN [0..y_order]];
	    END FOR;
	END FOR;

	FOR i IN components - [inactive_component] CREATE
	    FOR j IN [1..ntrays] CREATE

		trans_x_out[j][i]: tray_x_hat['out'][i][j] =
		    SUM[z_set.lgr.W[2*j-1][k]*x_coeff[i][k]
		    | k IN [0..x_order]];
		trans_x_in[j][i]: tray_x_hat['in'][i][j] =
		    SUM[z_set.lgr.W[2*j][k]*x_coeff[i][k]
		    | k IN [0..x_order]];
		trans_y_out[j][i]: tray_y_hat['out'][i][j] =
		    SUM[z_set.lgr.W[2*j][k]*y_coeff[i][k]
		    | k IN [0..y_order]];
		trans_y_in[j][i]: tray_y_hat['in'][i][j] =
		    SUM[z_set.lgr.W[2*j-1][k]*y_coeff[i][k]
		    | k IN [0..y_order]];
	    END FOR;
	END FOR;


	FOR i IN components - [inactive_component] CREATE
	    frac_x_top[1][i]:  topliq.state.y[i] 
		= SUM[((z_set.up_down+1)
		*z_set.lgr.W[z_set.lgr.npoints][k]/2
		+ (1-z_set.up_down)
		*z_set.lgr.W[0][k]/2)*x_coeff[i][k]
		| k IN [0..x_order]];
	    frac_y_top[1][i]:  topvap.state.y[i] 
		= SUM[((z_set.up_down+1)
		*z_set.lgr.W[z_set.lgr.npoints][k]/2
		+ (1-z_set.up_down)
		*z_set.lgr.W[0][k]/2)*y_coeff[i][k]
		| k IN [0..y_order]];
	    frac_y_bot[1][i]: botvap.state.y[i] 
		= SUM[((z_set.up_down+1)
		*z_set.lgr.W[0][k]/2
		+ (1-z_set.up_down)
		*z_set.lgr.W[z_set.lgr.npoints][k]/2)
		*y_coeff[i][k]
		| k IN [0..y_order]];
	END FOR;

	FOR i IN components - [inactive_component] CREATE
	    trans_x_top[1][i]: end_x_hat['top'][i] 
		= SUM[(((z_set.up_down+1)*z_set.lgr.W[z_set.lgr.npoints][k]/2
		+ (1-z_set.up_down)*z_set.lgr.W[0][k]/2))*x_coeff[i][k]
		| k IN [0..x_order]];
	    trans_y_top[1][i]: end_y_hat['top'][i] 
		= SUM[(((z_set.up_down+1)*z_set.lgr.W[z_set.lgr.npoints][k]/2
		+ (1-z_set.up_down)*z_set.lgr.W[0][k]/2))*y_coeff[i][k]
		| k IN [0..y_order]];
	    trans_y_bot[1][i]: end_y_hat['bot'][i] 
		= SUM[((z_set.up_down+1)*z_set.lgr.W[0][k]/2
		+ (1-z_set.up_down)
		*z_set.lgr.W[z_set.lgr.npoints][k]/2)*y_coeff[i][k]
		| k IN [0..y_order]];
	END FOR;


	slope[components]	IS_A factor;

	FOR i IN components CREATE
	    slope[i]*z_set.stot = abs(topliq.state.y[i] - botliq.state.y[i]);
	END FOR;


	aslope[components]			IS_A factor;
	intercept[components]			IS_A fraction;
	slope_slack[1..ntrays][components]	IS_A factor;




	FOR i IN components CREATE
	    botpoint[i]: botliq.state.y[i] = aslope[i]*z_set.zbot +
		intercept[i];
	    toppoint[i]: topliq.state.y[i] = aslope[i]*z_set.ztop +
		intercept[i];
	    FOR j IN [1..ntrays] CREATE
		midpoint[j][i]: tray[j].liqout['liquid'].state.y[i] =
		    aslope[i]*(z_set.z_values[j] - z_set.zbot) +
		    intercept[i] + slope_slack[j][i];
	    END FOR;
	END FOR;



  METHODS


    METHOD clear;
	RUN topliq.clear;
	RUN botliq.clear;
	RUN topvap.clear;
	RUN botvap.clear;
	x_coeff[components 
	    - [inactive_component]][0..x_order].fixed	:= FALSE;
	y_coeff[components 
	    - [inactive_component]][0..y_order].fixed	:= FALSE;
	cmo[1..ntrays].fixed 					:= FALSE;
	cmotot.fixed 						:= FALSE;
	RUN z_set.clear;
	RUN tray[1..ntrays].clear;	
	frac_x_in[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_y_in[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_x_out[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_y_out[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_x_top[1][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_y_top[1][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_y_bot[1][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_x_out[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_x_in[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_y_out[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_y_in[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_x_top[1][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_y_top[1][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_y_bot[1][components 
	    - [inactive_component]].included 		:=TRUE;
	tray_x_hat['in','out'][components][1..ntrays].fixed	:= FALSE;
	tray_y_hat['in','out'][components][1..ntrays].fixed	:= FALSE;
	end_x_hat['top','bot'][components].fixed		:= FALSE;
	end_y_hat['top','bot'][components].fixed		:= FALSE;
	x[1..ntrays][components].fixed				:= FALSE;
	y[1..ntrays][components].fixed				:= FALSE;
	x_hat[1..ntrays][components].fixed			:= FALSE;
	slope[components].fixed					:= FALSE;
	aslope[components].fixed				:= FALSE;
	intercept[components].fixed				:= FALSE;
	slope_slack[1..ntrays][components].fixed		:= FALSE;
	toppoint[components].included				:= TRUE;
	botpoint[components].included				:= TRUE;
	midpoint[1..ntrays][components].included		:= TRUE;


    END clear;
    METHOD standard_poly;
	frac_x_in[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_y_in[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_x_out[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_y_out[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_x_top[1][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_y_top[1][components 
	    - [inactive_component]].included 		:=TRUE;
	frac_y_bot[1][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_x_out[1..ntrays][components 
	    - [inactive_component]].included 		:=FALSE;
	trans_x_in[1..ntrays][components 
	    - [inactive_component]].included 		:=FALSE;
	trans_y_out[1..ntrays][components 
	    - [inactive_component]].included 		:=FALSE;
	trans_y_in[1..ntrays][components 
	    - [inactive_component]].included 		:=FALSE;
	trans_x_top[1][components 
	    - [inactive_component]].included 		:=FALSE;
	trans_y_top[1][components 
	    - [inactive_component]].included 		:=FALSE;
	trans_y_bot[1][components 
	    - [inactive_component]].included 		:=FALSE;
	hat_on 						:=FALSE;
    END standard_poly;
    METHOD trans_poly;
	frac_x_in[1..ntrays][components 
	    - [inactive_component]].included 		:=FALSE;
	frac_y_in[1..ntrays][components 
	    - [inactive_component]].included 		:=FALSE;
	frac_x_out[1..ntrays][components 
	    - [inactive_component]].included 		:=FALSE;
	frac_y_out[1..ntrays][components 
	    - [inactive_component]].included 		:=FALSE;
	frac_x_top[1][components 
	    - [inactive_component]].included 		:=FALSE;
	frac_y_top[1][components 
	    - [inactive_component]].included 		:=FALSE;
	frac_y_bot[1][components 
	    - [inactive_component]].included 		:=FALSE;
	trans_x_out[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_x_in[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_y_out[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_y_in[1..ntrays][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_x_top[1][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_y_top[1][components 
	    - [inactive_component]].included 		:=TRUE;
	trans_y_bot[1][components 
	    - [inactive_component]].included 		:=TRUE;

	hat_on 						:=TRUE;
    END trans_poly;
    METHOD seqmod;
	cmo[1..ntrays].fixed 				:= TRUE;
	cmotot.fixed					:= TRUE;
	RUN tray[1..ntrays].seqmod;
	RUN z_set.specify;
	RUN tray[1..ntrays].input[tray[1].inputs].seqmod;
	RUN topliq.seqmod;
	RUN botvap.seqmod;
	RUN topvap.seqmod;
	RUN botliq.seqmod;
	IF (hat_on) THEN
	    RUN trans_poly;
	ELSE
	    RUN standard_poly;
	END FOR;
    END seqmod;

    METHOD specify;
	RUN seqmod;
	RUN topliq.specify;
	RUN botvap.specify;
    END specify;
    METHOD reset;
	RUN clear;
	RUN specify;
    END reset;

    METHOD scale;
	RUN topliq.scale;
	RUN topvap.scale;
	RUN botliq.scale;
	RUN botvap.scale;
	RUN tray[1..ntrays].scale;
	RUN z_set.scale;

	FOR i IN components - [inactive_component] DO
	    FOR j IN [0..x_order] DO
		x_coeff[i][j].nominal :=
		    abs(x_coeff[i][j]) + 0.00001;
		x_coeff[i][j].lower_bound :=
		    x_coeff[i][j] - scale*x_coeff[i][j].nominal;
		x_coeff[i][j].upper_bound :=
		    x_coeff[i][j] + scale*x_coeff[i][j].nominal;
	    END FOR;
	    FOR j IN [0..y_order] DO
		y_coeff[i][j].nominal :=
		    abs(y_coeff[i][j]) + 0.00001;
		y_coeff[i][j].lower_bound :=
		    y_coeff[i][j] - scale*y_coeff[i][j].nominal;
		y_coeff[i][j].upper_bound :=
		    y_coeff[i][j] + scale*y_coeff[i][j].nominal;
	    END FOR;
	END FOR;
	FOR j IN [1..ntrays] DO
	    cmo[j].nominal := cmo[j];
	    cmo[j].lower_bound := 1e-8;
	    cmo[j].upper_bound := cmo[j] + scale*cmo[j].nominal;
	END FOR;
	cmotot.nominal := cmotot;
	cmotot.lower_bound := 1e-8;
	cmotot.upper_bound := cmotot + scale*cmotot.nominal;
	FOR i IN components DO
	    FOR j IN [1..ntrays] DO
		x[j][i].nominal := x[j][i];
		y[j][i].nominal := y[j][i];
		x_hat[j][i].nominal := abs(x_hat[j][i]);
		x_hat[j][i].lower_bound := x_hat[j][i] -
		    scale*x_hat[j][i].nominal;
		x_hat[j][i].upper_bound := x_hat[j][i] +
		    scale*x_hat[j][i].nominal;

		FOR k IN ['in','out'] DO
		    tray_x_hat[k][i][j].nominal :=
			abs(tray_x_hat[k][i][j]);
		    tray_x_hat[k][i][j].lower_bound :=
			tray_x_hat[k][i][j] -
			scale*tray_x_hat[k][i][j].nominal;
		    tray_x_hat[k][i][j].upper_bound :=
			tray_x_hat[k][i][j] +
			scale*tray_x_hat[k][i][j].nominal;
		    tray_y_hat[k][i][j].nominal :=
			abs(tray_y_hat[k][i][j]);
		    tray_y_hat[k][i][j].lower_bound :=
			tray_y_hat[k][i][j] -
			scale*tray_y_hat[k][i][j].nominal;
		    tray_y_hat[k][i][j].upper_bound :=
			tray_y_hat[k][i][j] +
			scale*tray_y_hat[k][i][j].nominal;
		END FOR;
	    END FOR;
	    FOR k IN ['top','bot'] DO
		end_x_hat[k][i].nominal := abs(end_x_hat[k][i]);
		end_x_hat[k][i].lower_bound := end_x_hat[k][i] -
		    scale*end_x_hat[k][i].nominal;
		end_x_hat[k][i].upper_bound := end_x_hat[k][i] +
		    scale*end_x_hat[k][i].nominal;
		end_y_hat[k][i].nominal := abs(end_y_hat[k][i]);
		end_y_hat[k][i].lower_bound := end_y_hat[k][i] -
		    scale*end_y_hat[k][i].nominal;
		end_y_hat[k][i].upper_bound := end_y_hat[k][i] +
		    scale*end_y_hat[k][i].nominal;
	    END FOR;
	    slope[i].nominal := abs(slope[i]);
	    slope[i].lower_bound := slope[i] - scale*slope[i];
	    slope[i].upper_bound := slope[i] + scale*slope[i];
	END FOR;
    END scale;
    METHOD s_off;
	RUN z_set.s_off;
    END s_off;
    METHOD z_based_poly;
	RUN z_set.z_based_poly;
    END z_based_poly;

    METHOD s_based_poly;
	RUN z_set.s_based_poly;
    END s_based_poly;

END coll;


MODEL coll_stack;

	components 			IS_A set OF symbol_constant;
	inactive_component		IS_A symbol_constant;
	straight_choice			IS_A symbol_constant;
	ncolls				IS_A integer_constant;
	coll[1..ncolls]			IS_A coll;
	split[1..ncolls]		IS_A fraction;
	stot				IS_A factor;
	scale				IS_A scaling_constant;

	components,
	coll[1..ncolls].components	ARE_THE_SAME;

	inactive_component,
	coll[1..ncolls].inactive_component	ARE_THE_SAME;

	FOR j IN [1..ncolls-1] CREATE
		coll[j].botvap,
		coll[j+1].topvap	ARE_THE_SAME;
		coll[j].botliq,
		coll[j+1].topliq	ARE_THE_SAME;
	END FOR;

	FOR j IN [1..ncolls] CREATE

		tray_split[j]: coll[j].z_set.stot = split[j]*stot;
		split[j] := 1.0/ncolls;

	END FOR;

	coll[1..ncolls].tray[1]		ARE_ALIKE;
	coll[1..ncolls].tray[1].VLE	ARE_ALIKE;

	stot_def: stot = SUM[coll[j].z_set.stot | j IN [1..ncolls]];


	stot.lower_bound := 1e-8;             

  METHODS
     METHOD clear;
	RUN coll[1..ncolls].clear;
	stot.fixed					:= FALSE;
	tray_split[1..ncolls-1].included 		:= TRUE;
	split[1..ncolls-1].fixed := FALSE;

     END clear;
     METHOD seqmod;
	RUN coll[1..ncolls].seqmod;
	FOR j IN [1..ncolls] DO
	    coll[j].z_set
		.z_values[coll[j].ntrays+1].fixed 	:= FALSE;
	    coll[j].z_set.stot.fixed			:= FALSE;
	END FOR;
	stot.fixed					:= TRUE;
	split[1..ncolls-1].fixed 			:= TRUE;
     END seqmod;
     METHOD specify;
	RUN seqmod;
	RUN coll[1].topliq.specify;
	RUN coll[ncolls].botvap.specify;
     END specify;
     METHOD reset;
	RUN clear;
	RUN specify;
     END reset;
     METHOD scale;
	RUN coll[1..ncolls].scale;
	stot.nominal := stot;
	stot.lower_bound := 1e-8;
	stot.upper_bound := stot + scale*stot.nominal;
     END scale;
     METHOD standard_poly;
	RUN coll[1..ncolls].standard_poly;
     END standard_poly;
     METHOD trans_poly;
	RUN coll[1..ncolls].trans_poly;
     END trans_poly;
     METHOD z_based_poly;
	RUN coll[1..ncolls].z_based_poly;
     END z_based_poly;
     METHOD s_based_poly;
	RUN coll[1..ncolls].s_based_poly;
     END s_based_poly;
END coll_stack; 

MODEL coll_column;

	nfeeds				IS_A integer_constant;
	condenser			IS_A condenser;
	coll_stack[1..nfeeds+1]		IS_A coll_stack;
	feed_tray[1..nfeeds]		IS_A simple_feed_tray;
	reboiler			IS_A reboiler;
	components			IS_A set OF symbol_constant;
	stot,
	s_stack[1..nfeeds+1]		IS_A factor;
	split[1..nfeeds+1]		IS_A fraction;
	xsi[components]			IS_A fraction;
	xsi_set[components]		IS_A fraction;
	xsi_diff[components]		IS_A fraction;
	scale				IS_A scaling_constant;
	
	components,
	condenser.components,
	coll_stack[1..nfeeds+1].components,
	feed_tray[1..nfeeds].components,
	reboiler.components		ARE_THE_SAME;

	FOR j IN [1..nfeeds+1] CREATE
		s_stack[j],
		coll_stack[j].stot	ARE_THE_SAME;
	END FOR;

	stot = SUM[s_stack[1..nfeeds+1]];

	FOR j IN [1..nfeeds+1] CREATE

		tray_split[j]: s_stack[j] = split[j]*stot;
		split[j] := 1.0/(nfeeds+1);

	END FOR;


	condenser.liqout['liquid'],
	coll_stack[1].coll[1].topliq			ARE_THE_SAME;
	condenser.input['vapor'],
	coll_stack[1].coll[1].topvap			ARE_THE_SAME;

	FOR j IN [1..nfeeds] CREATE

		coll_stack[j].coll[coll_stack[j].ncolls].botliq,
		feed_tray[j].input['liquid']		ARE_THE_SAME;
		coll_stack[j].coll[coll_stack[j].ncolls].botvap,
		feed_tray[j].vapout['vapor']		ARE_THE_SAME;
		
		coll_stack[j+1].coll[1].topliq,
		feed_tray[j].liqout['liquid']		ARE_THE_SAME;
		coll_stack[j+1].coll[1].topvap,
		feed_tray[j].input['vapor']		ARE_THE_SAME;
	END FOR;

	
	coll_stack[nfeeds+1].coll[coll_stack[nfeeds+1].ncolls].botliq,
	reboiler.input['liquid']		ARE_THE_SAME;
	coll_stack[nfeeds+1].coll[coll_stack[nfeeds+1].ncolls].botvap,
	reboiler.vapout['vapor']		ARE_THE_SAME;
		

	condenser.VLE,
	coll_stack[1..nfeeds+1].coll[1].tray[1].VLE,
	feed_tray[1..nfeeds].VLE,
	reboiler.VLE					ARE_ALIKE;

	condenser.liqout['liquid'].state,
	coll_stack[1..nfeeds+1].coll[1].tray[1].liqout['liquid'].state,
	feed_tray[1..nfeeds].liqout['liquid'].state,
	reboiler.liqout['bottoms'].state		ARE_ALIKE;

	condenser.vapout['vapor_product'].state,
	coll_stack[1..nfeeds+1].coll[1].tray[1].vapout['vapor'].state,
	feed_tray[1..nfeeds].vapout['vapor'].state,
	reboiler.vapout['vapor'].state			ARE_ALIKE;
		
	FOR i IN components CREATE
		OverallMB[i]: SUM[feed_tray[1..nfeeds].input['feed'].f[i]] =
			condenser.totprod.f[i] +
			reboiler.totprod.f[i];
	END FOR;

	FOR i IN components CREATE
		xsi[i]*SUM[feed_tray[k].input['feed'].f[i] | k IN [1..nfeeds]]
			= condenser.totprod.f[i];
		xsi_diff[i] = 0.5*sqr(xsi[i] - xsi_set[i]);
	END FOR;

	recovery: MINIMIZE SUM[xsi_diff[i] | i IN components];

	binary_sep[components][components]	IS_A factor;

	FOR i IN components CREATE
	    FOR j IN components CREATE
		
		
		binary_sep[i][j] *
	        (condenser.totprod.f[i] + condenser.totprod.f[j]) *
	        (reboiler.totprod.f[i] + reboiler.totprod.f[j]) =
		    (condenser.totprod.f[i] *
		    (reboiler.totprod.f[i] + reboiler.totprod.f[j]) -
		    reboiler.totprod.f[i] *
		    (condenser.totprod.f[i] + condenser.totprod.f[j]));

		sep_opt[i][j]: MINIMIZE -sqr(binary_sep[i][j]);
	
	    END FOR;
	END FOR;
	


  METHODS
     METHOD clear;
	RUN condenser.clear;
	RUN coll_stack[1..nfeeds+1].clear;
	RUN feed_tray[1..nfeeds].clear;
	RUN reboiler.clear;
	stot.fixed					:= FALSE;
	split[1..nfeeds+1].fixed			:= FALSE;
	xsi[components].fixed				:= FALSE;
	xsi_diff[components].fixed			:= FALSE;
	xsi_set[components].fixed			:= FALSE;
	binary_sep[components][components].fixed	:= FALSE;
	OverallMB[components].included			:= TRUE;
	recovery.included				:= TRUE;
	sep_opt[components][components].included	:= TRUE;
     END clear;
     METHOD seqmod;
	RUN condenser.seqmod;
	RUN coll_stack[1..nfeeds+1].seqmod;
	RUN feed_tray[1..nfeeds].seqmod;
	RUN reboiler.seqmod;
	OverallMB[components].included			:= FALSE;
	reboiler.reboil_ratio.fixed 			:= FALSE;
	condenser.totprod.Ftot.fixed 			:= TRUE;
	xsi_set[components].fixed			:= TRUE;
	recovery.included				:= FALSE;
	sep_opt[components][components].included	:= FALSE;
     END seqmod;
     METHOD specify;
	RUN seqmod;
	RUN feed_tray[1..nfeeds].input['feed'].specify;
     END specify;
     METHOD reset;
	RUN clear;
	RUN specify;
     END reset;
     METHOD scale;
	RUN condenser.scale;
	RUN coll_stack[1..nfeeds+1].scale;
	RUN feed_tray[1..nfeeds].scale;
	RUN reboiler.scale;
	stot.nominal := stot;
	stot.lower_bound := 1e-8;
	stot.upper_bound := stot + scale*stot.nominal;
	FOR i IN components DO
	    xsi[i].nominal := xsi[i];
	    xsi_set[i].nominal := xsi_set[i];
	    xsi_diff[i].nominal := xsi_diff[i];
	END FOR;
     END scale;
     METHOD standard_poly;
	RUN coll_stack[1..nfeeds+1].standard_poly;
     END standard_poly;
     METHOD trans_poly;
	RUN coll_stack[1..nfeeds+1].trans_poly;
     END trans_poly;
     METHOD z_based_poly;
	RUN coll_stack[1..nfeeds+1].z_based_poly;
     END z_based_poly;
     METHOD s_based_poly;
	RUN coll_stack[1..nfeeds+1].s_based_poly;
     END s_based_poly;
     METHOD propogate_feed;
	FOR i IN components DO
	    condenser.alpha[i] := feed_tray[1].alpha[i];
	    FOR k IN [2..nfeeds] DO
		feed_tray[k].alpha[i] :=
		    feed_tray[1].alpha[i];
	    END FOR;
	  FOR k IN [1..nfeeds+1] DO
	   FOR j IN [1..coll_stack[k].ncolls] DO
		coll_stack[k].coll[j].tray[1..coll_stack[k]
		  .coll[j].ntrays].alpha[i] 
			:= feed_tray[1].alpha[i];
	   END FOR;
	  END FOR;
		reboiler.alpha[i] := feed_tray[1].alpha[i];
	END FOR;

     END propogate_feed;
     METHOD overallMB;
	OverallMB[components].included			:= TRUE;
	feed_tray[1].totfeedflow[components].included 	:= FALSE;
     END overallMB;

END coll_column;


MODEL td_coll REFINES coll;
	data[components]		IS_A component_constants;
	
	tray[1..ntrays] IS_REFINED_TO td_simple_tray;
	topliq		IS_REFINED_TO td_stream;
	topvap		IS_REFINED_TO td_stream;
	botliq		IS_REFINED_TO td_stream;
	botvap		IS_REFINED_TO td_stream;

	tray[1..ntrays].liqout['liquid'].state	ARE_ALIKE;
	tray[1..ntrays].vapout['vapor'].state	ARE_ALIKE;

	FOR i IN components CREATE
		data[i],
		tray[1..ntrays].data[i],
		topliq.data[i],
		topvap.data[i],
		botliq.data[i],
		botvap.data[i]		ARE_THE_SAME;
	END FOR;
END td_coll;

MODEL h_coll REFINES td_coll;

	h_order					IS_A integer_constant;
	h_order,ntrays	ARE_THE_SAME;
	h_coeff['liquid','vapor'][0..h_order]	IS_A molar_energy;
	Qtot,
	Qin[1..ntrays]				IS_A energy_rate;
	h_exist,
	    hb_on				IS_A boolean;
		
	h_exist := TRUE;
	hb_on := FALSE;
	



	Overall_HB: Qtot + topliq.Htot + botvap.Htot =
	    botliq.Htot + topvap.Htot;

	FOR j IN [1..ntrays] CREATE
		tot_trayHB[j]: Qin[j] +topliq.Htot - topvap.Htot =
				tray[j].liqout['liquid'].Htot -
				tray[j].input['vapor'].Htot;
	END FOR;


(* end points *)

	h_end_topliq: topliq.H = SUM[((z_set.up_down+1)
			*z_set.lgr.W[z_set.lgr.npoints][k]/2
			+ (1-z_set.up_down)*z_set.lgr.W[0][k]/2)
			*h_coeff['liquid'][k]
			| k IN [0..h_order]];
	h_end_topvap: topvap.H = SUM[((z_set.up_down+1)
			*z_set.lgr.W[z_set.lgr.npoints][k]/2
			+ (1-z_set.up_down)*z_set.lgr.W[0][k]/2)
			*h_coeff['vapor'][k]
			| k IN [0..h_order]];
	h_end_botliq: botliq.H =  SUM[((z_set.up_down+1)
			*z_set.lgr.W[0][k]/2
			+ (1-z_set.up_down)
			*z_set.lgr.W[z_set.lgr.npoints][k]/2)
			*h_coeff['liquid'][k]
			| k IN [0..h_order]];
	h_end_botvap: botvap.H = SUM[((z_set.up_down+1)
			*z_set.lgr.W[0][k]/2
			+ (1-z_set.up_down)
			*z_set.lgr.W[z_set.lgr.npoints][k]/2)
			*h_coeff['vapor'][k]
			| k IN [0..h_order]]; 
(* interior points *)
	FOR j IN [1..ntrays] CREATE

		h_int_liqout[j]: tray[j].liqout['liquid'].H =
		    SUM[z_set.lgr.W[2*j-1][k]*h_coeff['liquid'][k]
		    | k IN [0..h_order]];
		h_int_liqin[j]: tray[j].input['liquid'].H =
		    SUM[z_set.lgr.W[2*j][k]*h_coeff['liquid'][k]
		    | k IN [0..h_order]];
		h_int_vapout[j]: tray[j].vapout['vapor'].H =
		    SUM[z_set.lgr.W[2*j][k]*h_coeff['vapor'][k]
		    | k IN [0..h_order]];
		h_int_vapin[j]: tray[j].input['vapor'].H =
		    SUM[z_set.lgr.W[2*j-1][k]*h_coeff['vapor'][k]
		    | k IN [0..h_order]];
	END FOR;

   METHODS
     METHOD clear;
	RUN topliq.clear;
	RUN botliq.clear;
	RUN topvap.clear;
	RUN botvap.clear;
	x_coeff[components 
		- [inactive_component]][0..x_order].fixed	:= FALSE;
	y_coeff[components 
		- [inactive_component]][0..y_order].fixed	:= FALSE;
	cmo[1..ntrays].fixed 					:= FALSE;
	cmotot.fixed 						:= FALSE;
	RUN z_set.clear;
	RUN tray[1..ntrays].clear;	
	frac_x_in[1..ntrays][components 
		- [inactive_component]].included 		:=TRUE;
	frac_y_in[1..ntrays][components 
		- [inactive_component]].included 		:=TRUE;
	frac_x_out[1..ntrays][components 
		- [inactive_component]].included 		:=TRUE;
	frac_y_out[1..ntrays][components 
		- [inactive_component]].included 		:=TRUE;
	frac_x_top[1][components 
		- [inactive_component]].included 		:=TRUE;
	frac_y_top[1][components 
		- [inactive_component]].included 		:=TRUE;
	frac_y_bot[1][components 
		- [inactive_component]].included 		:=TRUE;
	trans_x_out[1..ntrays][components 
		- [inactive_component]].included 		:=TRUE;
	trans_x_in[1..ntrays][components 
		- [inactive_component]].included 		:=TRUE;
	trans_y_out[1..ntrays][components 
		- [inactive_component]].included 		:=TRUE;
	trans_y_in[1..ntrays][components 
		- [inactive_component]].included 		:=TRUE;
	trans_x_top[1][components 
		- [inactive_component]].included 		:=TRUE;
	trans_y_top[1][components 
		- [inactive_component]].included 		:=TRUE;
	trans_y_bot[1][components 
		- [inactive_component]].included 		:=TRUE;
	tray_x_hat['in','out'][components][1..ntrays].fixed	:= FALSE;
	tray_y_hat['in','out'][components][1..ntrays].fixed	:= FALSE;
	end_x_hat['top','bot'][components].fixed		:= FALSE;
	end_y_hat['top','bot'][components].fixed		:= FALSE;
	x[1..ntrays][components].fixed				:= FALSE;
	y[1..ntrays][components].fixed				:= FALSE;
	x_hat[1..ntrays][components].fixed			:= FALSE;

	h_coeff['liquid','vapor'][0..h_order].fixed		:= FALSE;
	Qtot.fixed						:= FALSE;
	Qin[1..ntrays].fixed					:= FALSE;
	slope[components].fixed					:= FALSE;
     END clear;
     METHOD seqmod;
	cmo[1..ntrays].fixed 					:= TRUE;
	cmotot.fixed						:= TRUE;
	RUN tray[1..ntrays].seqmod;
	RUN z_set.specify;
	RUN tray[1..ntrays].input[tray[1].inputs].seqmod;
	RUN topliq.seqmod;
	RUN botvap.seqmod;
	RUN topvap.seqmod;
	RUN botliq.seqmod;
	IF (hat_on) THEN
		RUN trans_poly;
	ELSE
		RUN standard_poly;
	END FOR;
 	tray[1..ntrays].input[tray[1].inputs].H.fixed 		:= FALSE;
	topvap.H.fixed						:= FALSE;
	botliq.H.fixed						:= FALSE;
	IF (hb_on) THEN
	    RUN heat_balance;
	END FOR;
	
     END seqmod;
     METHOD heat_balance;
	RUN tray[1..ntrays].heat_balance;
	Qtot.fixed 						:= TRUE;
	cmotot.fixed 						:= FALSE;
	Qin[1..ntrays].fixed 					:= TRUE;
	cmo[1..ntrays].fixed 					:= FALSE;
	hb_on							:= TRUE;
     END heat_balance;
     METHOD CMO;
	 tray[1..ntrays].cmo_ratio.fixed			:= TRUE;
	 tray[1..ntrays].Qin.fixed				:= FALSE;
	 Qtot.fixed 						:= FALSE;
 	cmotot.fixed 						:= TRUE;
	Qin[1..ntrays].fixed 					:= FALSE;
	cmo[1..ntrays].fixed 					:= TRUE;
	hb_on							:= FALSE;
     END CMO;
     METHOD scale;
	RUN topliq.scale;
	RUN topvap.scale;
	RUN botliq.scale;
	RUN botvap.scale;
	RUN tray[1..ntrays].scale;
	RUN z_set.scale;
	
	FOR i IN components - [inactive_component] DO
	   FOR j IN [0..x_order] DO
		x_coeff[i][j].nominal :=
		    abs(x_coeff[i][j]) + 0.00001;
		x_coeff[i][j].lower_bound :=
		    x_coeff[i][j] - scale*x_coeff[i][j].nominal;
		x_coeff[i][j].upper_bound :=
		    x_coeff[i][j] + scale*x_coeff[i][j].nominal;
	   END FOR;
	   FOR j IN [0..y_order] DO
		y_coeff[i][j].nominal :=
		    abs(y_coeff[i][j]) + 0.00001;
		y_coeff[i][j].lower_bound :=
		    y_coeff[i][j] - scale*y_coeff[i][j].nominal;
		y_coeff[i][j].upper_bound :=
		    y_coeff[i][j] + scale*y_coeff[i][j].nominal;
	   END FOR;
	END FOR;
	FOR j IN [1..ntrays] DO
	    cmo[j].nominal := cmo[j];
	    cmo[j].lower_bound := 1e-8;
	    cmo[j].upper_bound := cmo[j] + scale*cmo[j].nominal;
	END FOR;
	cmotot.nominal := cmotot;
	cmotot.lower_bound := 1e-8;
	cmotot.upper_bound := cmotot + scale*cmotot.nominal;
	FOR i IN components DO
	    FOR j IN [1..ntrays] DO
		x[j][i].nominal := x[j][i];
		y[j][i].nominal := y[j][i];
		x_hat[j][i].nominal := abs(x_hat[j][i]);
		x_hat[j][i].lower_bound := x_hat[j][i] -
		    scale*x_hat[j][i].nominal;
		x_hat[j][i].upper_bound := x_hat[j][i] +
		    scale*x_hat[j][i].nominal;

		FOR k IN ['in','out'] DO
		    tray_x_hat[k][i][j].nominal :=
			abs(tray_x_hat[k][i][j]);
		    tray_x_hat[k][i][j].lower_bound :=
			tray_x_hat[k][i][j] -
			scale*tray_x_hat[k][i][j].nominal;
		    tray_x_hat[k][i][j].upper_bound :=
			tray_x_hat[k][i][j] +
			scale*tray_x_hat[k][i][j].nominal;
		    tray_y_hat[k][i][j].nominal :=
			abs(tray_y_hat[k][i][j]);
		    tray_y_hat[k][i][j].lower_bound :=
			tray_y_hat[k][i][j] -
			scale*tray_y_hat[k][i][j].nominal;
		    tray_y_hat[k][i][j].upper_bound :=
			tray_y_hat[k][i][j] +
			scale*tray_y_hat[k][i][j].nominal;
		END FOR;
	    END FOR;
	    FOR k IN ['top','bot'] DO
		end_x_hat[k][i].nominal := abs(end_x_hat[k][i]);
		end_x_hat[k][i].lower_bound := end_x_hat[k][i] -
		    scale*end_x_hat[k][i].nominal;
		end_x_hat[k][i].upper_bound := end_x_hat[k][i] +
		    scale*end_x_hat[k][i].nominal;
		end_y_hat[k][i].nominal := abs(end_y_hat[k][i]);
		end_y_hat[k][i].lower_bound := end_y_hat[k][i] -
		    scale*end_y_hat[k][i].nominal;
		end_y_hat[k][i].upper_bound := end_y_hat[k][i] +
		    scale*end_y_hat[k][i].nominal;
	    END FOR;
	    slope[i].nominal := abs(slope[i]);
	    slope[i].lower_bound := slope[i] - scale*slope[i];
	    slope[i].upper_bound := slope[i] + scale*slope[i];
	END FOR;
	FOR i IN ['liquid','vapor'] DO
	    FOR j IN [0..h_order] DO
		h_coeff[i][j].nominal := abs(h_coeff[i][j]);
		h_coeff[i][j].lower_bound := h_coeff[i][j] -
		    scale*h_coeff[i][j].nominal;
		h_coeff[i][j].upper_bound :=h_coeff[i][j] + scale*
		    h_coeff[i][j].nominal;
	    END FOR;
	END FOR;
	Qtot.nominal := abs(Qtot);
	Qtot.lower_bound := Qtot - scale*Qtot.nominal;
	Qtot.upper_bound := Qtot + scale*Qtot.nominal;
	FOR j IN [1..ntrays] DO
	    Qin[j].nominal := abs(Qin[j]);
	    Qin[j].lower_bound := Qin[j] - scale*Qin[j].nominal;
	    Qin[j].upper_bound := Qin[j] + scale*Qin[j].nominal;
	END FOR;
	
	
     END scale;
     
			 


END h_coll;

MODEL td_coll_stack REFINES coll_stack;

	data[components]	IS_A component_constants;
	coll[1..ncolls]		IS_REFINED_TO td_coll;
	hb_on			IS_A boolean;

	hb_on := FALSE;

	FOR i IN components CREATE
		data[i],
		coll[1..ncolls].data[i]	ARE_THE_SAME;
	END FOR;

	coll[1..ncolls].tray[1].liqout['liquid'].state		ARE_ALIKE;
	coll[1..ncolls].tray[1].vapout['vapor'].state		ARE_ALIKE;

	
   METHODS
     METHOD heat_balance;
	RUN coll[1..ncolls].heat_balance;
	hb_on							:= TRUE;
     END heat_balance;
     METHOD CMO;
	 RUN coll[1..ncolls].CMO;
	 hb_on							:= FALSE;
     END CMO;
     METHOD seqmod;
	RUN coll[1..ncolls].seqmod;
	FOR j IN [1..ncolls] DO
	   IF coll[j].h_exist THEN
		coll[j].botliq.H.fixed 				:= FALSE;
	   END FOR;
	    coll[j].z_set.z_values[coll[j].ntrays+1].fixed 	:= FALSE;
	    coll[j].z_set.stot.fixed				:= FALSE;
	END FOR;
	stot.fixed						:= TRUE;
	split[1..ncolls-1].fixed 				:= TRUE;
	IF (hb_on) THEN
	    RUN heat_balance;
	END FOR;
     END seqmod;	
END td_coll_stack;

MODEL pinch_stack REFINES td_coll_stack;
	pinch_VLE[1..ncolls-1]	IS_A equilibrium_mixture;

	pinch_VLE[1..ncolls-1].components,
	    components		ARE_THE_SAME;

	
	pinch_VLE[1..ncolls-1].phases := ['liquid','vapor'];
	pinch_VLE[1..ncolls-1].reference := 'liquid';

	pinch_slack[1..ncolls-1][components]	IS_A factor;

	FOR j IN [1..ncolls-1] CREATE
	    pinch_VLE[j].mix['liquid'],
		coll[j].botliq.state	ARE_THE_SAME;
	    FOR i IN components CREATE
		pinch_VLE[j].mix['vapor'].y[i] = pinch_slack[j][i]
		    + coll[j].botvap.state.y[i];
	    END FOR;
	END FOR;
	FOR i IN components CREATE
	    data[i],
		pinch_VLE[1..ncolls-1].data[i]	ARE_THE_SAME;
	END FOR;
	pinch_VLE[1..ncolls-1].mix['liquid'] IS_REFINED_TO UNIFAC_mixture;
	pinch_VLE[1..ncolls-1].mix['vapor'] IS_REFINED_TO Pitzer_mixture;
  METHODS
     METHOD clear;
	RUN coll[1..ncolls].clear;
	stot.fixed					:= FALSE;
	tray_split[1..ncolls-1].included 		:= TRUE;
	split[1..ncolls-1].fixed := FALSE;
	RUN pinch_VLE[1..ncolls-1].clear;
	pinch_slack[1..ncolls-1][components].fixed	:= FALSE;
     END clear;
     METHOD seqmod;
	RUN coll[1..ncolls].seqmod;
	FOR j IN [1..ncolls] DO
	   IF coll[j].h_exist THEN
		coll[j].botliq.H.fixed 				:= FALSE;
	   END FOR;
	    coll[j].z_set.z_values[coll[j].ntrays+1].fixed 	:= FALSE;
	    coll[j].z_set.stot.fixed				:= FALSE;
	END FOR;
	stot.fixed						:= TRUE;
	split[1..ncolls-1].fixed 				:= TRUE;
	IF (hb_on) THEN
	    RUN heat_balance;
	END FOR;
	RUN pinch_VLE[1..ncolls-1].specify;
	pinch_VLE[1..ncolls-1].y[components].fixed		:= FALSE;
     END seqmod;
     METHOD force_pinch;
	 FOR j IN [1..ncolls-1] DO
	     pinch_slack[j][components].fixed			:= TRUE;
	     pinch_slack[j][CHOICE[components]].fixed		:= FALSE;
	     pinch_slack[j][components]				:= 0.0;
	     coll[j+1].trans_x_top[1][components -
		 [inactive_component]].included 		:= FALSE;
	     coll[j+1].frac_x_top[1][components -
		 [inactive_component]].included 		:= FALSE;
	 END FOR;
	 coll[ncolls].slope[CHOICE[components]].fixed				:= TRUE;
	 stot.fixed						:= FALSE;
	
     END force_pinch;
   
END pinch_stack;

MODEL td_coll_column REFINES coll_column;

	reduce				IS_A factor;
	reduce := 0.5;

	data[components]		IS_A component_constants;

	condenser			IS_REFINED_TO td_condenser;
	feed_tray[1..nfeeds] 		IS_REFINED_TO td_simple_feed_tray;
	reboiler 			IS_REFINED_TO td_reboiler;
	coll_stack[1..nfeeds+1]		IS_REFINED_TO td_coll_stack;
	hb_on				IS_A boolean;

	hb_on := FALSE;
	

	FOR i IN components CREATE
		data[i],
		condenser.data[i],
		coll_stack[1..nfeeds+1].coll[1].data[i],
		feed_tray[1..nfeeds].data[i],
		reboiler.data[i]				ARE_THE_SAME;
	END FOR;



	condenser.liqout['liquid'].state,
	coll_stack[1..nfeeds+1].coll[1].tray[1].liqout['liquid'].state,
	feed_tray[1..nfeeds].liqout['liquid'].state,
	reboiler.liqout['bottoms'].state			ARE_ALIKE;

	condenser.vapout['vapor_product'].state,
	coll_stack[1..nfeeds+1].coll[1].tray[1].vapout['vapor'].state,
	feed_tray[1..nfeeds].vapout['vapor'].state,
	reboiler.vapout['vapor_product'].state			ARE_ALIKE;


   METHODS
     METHOD heat_balance;
	RUN coll_stack[1..nfeeds+1].heat_balance;
	RUN feed_tray[1..nfeeds].heat_balance;
	hb_on := TRUE;
     END heat_balance;
     METHOD CMO;
	 RUN coll_stack[1..nfeeds+1].CMO;
	 feed_tray[1..nfeeds].q.fixed := TRUE;
	 feed_tray[1..nfeeds].Qin.fixed := FALSE;
	 hb_on := FALSE;
     END CMO;
     METHOD reduce_Q;
	FOR i IN [1..nfeeds+1] DO
	  FOR j IN [1..coll_stack[i].ncolls] DO
		coll_stack[i].coll[j].Qtot :=
		coll_stack[i].coll[j].Qtot*reduce;
	    FOR k IN [1..coll_stack[i].coll[j].ntrays] DO
		coll_stack[i].coll[j].Qin[k] :=
		coll_stack[i].coll[j].Qin[k]*reduce;
		coll_stack[i].coll[j].tray[k].Qin :=
		coll_stack[i].coll[j].tray[k].Qin*reduce;
	    END FOR;
	  END FOR;
	END FOR;
	FOR i IN [1..nfeeds] DO
 		feed_tray[i].Qin := 
		feed_tray[i].Qin*reduce;
	END FOR;
     END reduce_Q;
     METHOD zero_Q;
	reduce := 0;
	RUN reduce_Q;
     END zero_Q;
     METHOD seqmod;
	RUN condenser.seqmod;
	RUN coll_stack[1..nfeeds+1].seqmod;
	RUN feed_tray[1..nfeeds].seqmod;
	RUN reboiler.seqmod;
	OverallMB[components].included			:= FALSE;
	reboiler.reboil_ratio.fixed 			:= FALSE;
	condenser.totprod.Ftot.fixed 			:= TRUE;
	xsi_set[components].fixed			:= TRUE;
	IF (hb_on) THEN
	    RUN heat_balance;
	END FOR;
	recovery.included				:= FALSE;
	sep_opt[components][components].included	:= FALSE;
     END seqmod;
     


END td_coll_column;


MODEL equilibrium_coll_column REFINES td_coll_column;

	condenser.VLE			IS_REFINED_TO equilibrium_mixture;
	feed_tray[1..nfeeds]
		.input['feed'].state 	IS_REFINED_TO equilibrium_mixture;
   METHODS
     METHOD seqmod;
	RUN condenser.seqmod;
	RUN coll_stack[1..nfeeds+1].seqmod;
	RUN feed_tray[1..nfeeds].seqmod;
	RUN reboiler.seqmod;
	OverallMB[components].included			:= FALSE;
	reboiler.reboil_ratio.fixed 			:= FALSE;
	condenser.totprod.Ftot.fixed 			:= TRUE;
	condenser.VLE.T.fixed 				:= FALSE;
	xsi_set[components].fixed			:= TRUE;
	IF (hb_on) THEN
	    RUN heat_balance;
	END FOR;
	recovery.included				:= FALSE;
	sep_opt[components][components].included	:= FALSE;
     END seqmod;
     METHOD CRV;
	RUN condenser.VLE.CRV;
	RUN feed_tray[1..nfeeds].VLE.CRV;
	RUN reboiler.VLE.CRV;
	FOR i IN [1..nfeeds+1] DO
	  FOR j IN [1..coll_stack[i].ncolls] DO
	   FOR k IN [1..coll_stack[i].coll[j].ntrays] DO
		RUN coll_stack[i].coll[j].tray[k].VLE.CRV;
	   END FOR;
	  END FOR;
	END FOR;
      END CRV;
     METHOD equilibrium;
	RUN condenser.VLE.equilibrium;
	RUN feed_tray[1..nfeeds].VLE.equilibrium;
	RUN reboiler.VLE.equilibrium;
	FOR i IN [1..nfeeds+1] DO
	  FOR j IN [1..coll_stack[i].ncolls] DO
	   FOR k IN [1..coll_stack[i].coll[j].ntrays] DO
		RUN coll_stack[i].coll[j].tray[k].VLE.equilibrium;
	   END FOR;
	  END FOR;
	END FOR;
      END equilibrium;
     

END equilibrium_coll_column;




MODEL basic_coll_column REFINES coll_column;

	nfeeds :== 1;
	coll_stack[1..2].ncolls :== 2;

	coll_stack[1..2].coll[1].z_set.up_down := -1.0;
	coll_stack[1..2].coll[2].z_set.up_down := 1.0;

END basic_coll_column;


MODEL two_feed_column REFINES coll_column;

	nfeeds :== 2;

	coll_stack[1..3].ncolls :== 2;

	coll_stack[1..3].coll[1].z_set.up_down := -1.0;
	coll_stack[1..3].coll[2].z_set.up_down := 1.0;
END two_feed_column;

MODEL coll_plot;

	ntrays					IS_A integer_constant;
	components				IS_A set OF symbol_constant;

	box_height,
	z_values[0..ntrays+1],
	s_values[0..ntrays+1]			IS_A factor;
	shift,
	up_down					IS_A real;
	x[0..ntrays+1][components],
	y[0..ntrays+1][components]		IS_A fraction;

	tray_x_hat[components][0..ntrays+1]	IS_A factor;

	(* PLOTTING *)

	plots['plotx',
	    'ploty',
	    'plotx_s',
	    'ploty_s',
	    'plotxt']			IS_A plt_plot_symbol;
	(* liquid composition *)



	box_height := 1.0;
	shift := 0.0;


	

	plots['plotx'].title :== 'liquid compositions vs z';
	plots['plotx'].XLabel :== 'z';
	plots['plotx'].YLabel :== 'liquid comp';
	plots['plotx'].curve_set :== components + ['box'];
	plots['plotx',
	    'ploty',
	    'plotx_s',
	    'ploty_s',
	    'plotxt'].curve_set			ARE_THE_SAME;

	plots['plotx'].curve['box'].npnt	:== 4;
	plots['plotx','ploty','plotx_s','ploty_s',
		'plotxt'].curve['box'].npnt	ARE_THE_SAME;	
	plots['plotx','ploty','plotx_s','ploty_s',
		'plotxt'].curve['box'].legend	ARE_THE_SAME;	
	plots['plotx'].curve['box'].legend 	:== 'box';


	FOR k IN ['plotx','ploty','plotx_s','ploty_s','plotxt'] CREATE

		plots[k].curve['box'].pnt[1..2].x	ARE_THE_SAME;
		plots[k].curve['box'].pnt[3..4].x	ARE_THE_SAME;

		plots[k].curve['box'].pnt[1].x,
		plots[k].curve[CHOICE[components]].pnt[1].x ARE_THE_SAME;
		plots[k].curve[CHOICE[components]]
		    .pnt[plots[k].curve[CHOICE[components]].npnt].x,
		plots[k].curve['box'].pnt[4].x	 	ARE_THE_SAME;
	END FOR;

	plots['plotx','ploty','plotx_s','ploty_s','plotxt']
	    .curve[plots['plotx'].curve_set].pnt[1].x IS_REFINED_TO factor;

(* basics *)
	FOR k IN [components] CREATE

	  plots['plotx'].curve[k].legend :== k;
	  plots['plotx','ploty','plotx_s','ploty_s',
		'plotxt'].curve[k].legend	ARE_THE_SAME;

	  plots['plotx'].curve[k].npnt	:== ntrays+2;
	  plots['plotx','ploty','plotx_s','ploty_s',
		'plotxt'].curve[k].npnt	ARE_THE_SAME;

	END FOR;

	  plots['ploty'].title	:== 'Vapor composition vs z';
	  plots['ploty'].XLabel  	:== 'z';
	  plots['ploty'].YLabel  	:== 'vapor composition';


	plots['plotx_s'].title :== 'liquid compositions vs s';
	plots['plotx_s'].XLabel :== 's';
	plots['plotx_s'].YLabel :== 'liquid comp';


	  plots['ploty_s'].title	:== 'Vapor composition vs s';
	  plots['ploty_s'].XLabel  	:== 's';
	  plots['ploty_s'].YLabel  	:== 'vapor composition';


	plots['plotxt'].title :== 'x_hat vs z';
	plots['plotxt'].XLabel :== 'z';
	plots['plotxt'].YLabel :== 'x_hat';


	box_height,
	plots['plotx'].curve['box'].pnt[2,3].y,
	plots['plotxt'].curve['box'].pnt[2,3].y,
	plots['ploty'].curve['box'].pnt[2,3].y,
	plots['plotx_s'].curve['box'].pnt[2,3].y,
	plots['ploty_s'].curve['box'].pnt[2,3].y ARE_THE_SAME;

	plots['plotx'].curve['box'].pnt[1,4].y,
	plots['plotxt'].curve['box'].pnt[1,4].y,
	plots['ploty'].curve['box'].pnt[1,4].y,
	plots['plotx_s'].curve['box'].pnt[1,4].y,
	plots['ploty_s'].curve['box'].pnt[1,4].y ARE_THE_SAME;


(* point merges *)
	FOR j IN [1..plots['plotx'].curve['box'].npnt] CREATE
		plots['plotx','ploty','plotxt']
		 .curve['box'].pnt[j].x 	ARE_THE_SAME;
		plots['plotx_s','ploty_s']
		 .curve['box'].pnt[j].x		ARE_THE_SAME;
	END FOR;
	FOR j IN [1..plots['plotx'].curve[CHOICE[components]].npnt] CREATE
		plots['plotx','ploty','plotxt']
		 .curve[components].pnt[j].x	ARE_THE_SAME;
		plots['plotx_s','ploty_s']
		 .curve[components].pnt[j].x	ARE_THE_SAME;
	END FOR;


(* composition merges *)

	FOR k IN [components] CREATE
	   FOR j IN [0..ntrays+1] CREATE
		plots['plotx'].curve[k].pnt[j+1].y,
		plots['plotx_s'].curve[k].pnt[j+1].y,
		x[j][k]		ARE_THE_SAME;

		plots['ploty'].curve[k].pnt[j+1].y,
		plots['ploty_s'].curve[k].pnt[j+1].y,
		y[j][k]		ARE_THE_SAME;

		plots['plotxt'].curve[k].pnt[j+1].y,
		tray_x_hat[k][j]	ARE_THE_SAME;
	   END FOR;
	END FOR;

(* equations also IN procedure *)

	plots['plotx'].curve['box'].pnt[1].y = 0;

	plots['plotx'].curve[CHOICE[components]].pnt[1].x = z_values[0];
	plots['plotx'].curve[CHOICE[components]].pnt[ntrays+2].x =
	    z_values[ntrays+1];
	plots['plotx_s'].curve[CHOICE[components]].pnt[1].x =
	    s_values[0] + shift;
	plots['plotx_s'].curve[CHOICE[components]].pnt[ntrays+2].x =
	    s_values[ntrays+1]+ shift;
	FOR j IN [1..ntrays] CREATE
		plots['plotx'].curve[CHOICE[components]].pnt[j+1].x = 
		    (1+up_down)*(z_values[ntrays+1]-z_values[ntrays+1-j])/2
		    + (1-up_down)*z_values[j]/2;
		plots['plotx_s'].curve[CHOICE[components]].pnt[j+1].x = shift +
		    (1+up_down)*(s_values[ntrays+1]-s_values[ntrays+1-j])/2
		    + (1-up_down)*s_values[j]/2;
	END FOR;

   METHODS
     METHOD clear;
	z_values[0..ntrays+1].fixed			:= FALSE;
	s_values[0..ntrays+1].fixed			:= FALSE;
	box_height.fixed				:= FALSE;
	x[1..ntrays][components].fixed			:= FALSE;
	y[1..ntrays][components].fixed			:= FALSE;
	tray_x_hat[components][1..ntrays].fixed		:= FALSE;
     END clear;
     METHOD specify;
	z_values[0..ntrays+1].fixed			:= TRUE;
	s_values[0..ntrays+1].fixed			:= TRUE;
	box_height.fixed				:= TRUE;
	x[1..ntrays][components].fixed			:= TRUE;
	y[1..ntrays][components].fixed			:= TRUE;
	tray_x_hat[components][1..ntrays].fixed		:= TRUE;
     END specify;
     METHOD reset;
	RUN clear;
	RUN specify;
     END reset;
     METHOD plot_values;
	plots['plotx'].curve['box'].pnt[1].y := 0;

	plots['plotx'].curve[CHOICE[components]].pnt[1].x :=
	    z_values[0];
	plots['plotx'].curve[CHOICE[components]].pnt[ntrays+2].x :=
	    z_values[ntrays+1];
	plots['plotx_s'].curve[CHOICE[components]].pnt[1].x :=
	    s_values[0]+ shift;
	plots['plotx_s'].curve[CHOICE[components]].pnt[ntrays+2].x :=
	    s_values[ntrays+1] + shift;
	FOR j IN [1..ntrays] DO
		plots['plotx'].curve[CHOICE[components]].pnt[j+1].x :=
		    shift + (1+up_down)*(z_values[ntrays+1]-
		    z_values[ntrays+1-j])/2
		    + (1-up_down)*z_values[j]/2;
		plots['plotx_s'].curve[CHOICE[components]].pnt[j+1].x :=
		    shift + (1+up_down)*(s_values[ntrays+1]-
		    s_values[ntrays+1-j])/2
		    + (1-up_down)*s_values[j]/2;
	END FOR;
      END plot_values;
		
END coll_plot;


MODEL coll_stack_plot;

	components				IS_A set OF symbol_constant;
	ncolls					IS_A integer_constant;
	coll[1..ncolls]				IS_A coll_plot;
	box_height,
	z_space					IS_A factor;
	
	box_height,
	coll[1..ncolls].box_height		ARE_THE_SAME;

	components,
	coll[1..ncolls].components		ARE_THE_SAME;

	endpoints[1..ncolls][plots['plotx'].curve_set]		IS_A integer_constant;
	plots['plotx',
	    'ploty',
	    'plotx_s',
	    'ploty_s',
	    'plotxt']				IS_A plt_plot_symbol;


	plots['plotx'].curve_set,
	plots['plotxt'].curve_set,
	plots['ploty'].curve_set,
	plots['plotx_s'].curve_set,
	plots['ploty_s'].curve_set			ARE_THE_SAME;


	plots['plotx'].curve_set,
	coll[1].plots['plotx'].curve_set		ARE_THE_SAME;

	FOR k IN [plots['plotx'].curve_set] CREATE
		endpoints[1][k] :== coll[1].plots['plotx'].curve[k].npnt;
	END FOR;
	FOR j IN [2..ncolls] CREATE
	    FOR k IN [plots['plotx'].curve_set] CREATE

	  	endpoints[j][k] :== 
		 endpoints[j-1][k] + coll[j].plots['plotx'].curve[k].npnt;
	    END FOR;
	END FOR;
	FOR k IN [plots['plotx'].curve_set] CREATE

		plots['plotx'].curve[k].npnt,
		plots['plotxt'].curve[k].npnt,
		plots['ploty'].curve[k].npnt,
		plots['plotx_s'].curve[k].npnt,
		plots['ploty_s'].curve[k].npnt		ARE_THE_SAME;
		
		plots['plotx'].curve[k].npnt :== endpoints[ncolls][k];
	END FOR;

	FOR k IN ['plotx','ploty','plotx_s','ploty_s','plotxt'] CREATE
		plots[k].title, 
		coll[1..ncolls].plots[k].title		ARE_THE_SAME;
		plots[k].XLabel,
		coll[1..ncolls].plots[k].XLabel		ARE_THE_SAME;
		plots[k].YLabel,
		coll[1..ncolls].plots[k].YLabel		ARE_THE_SAME;
	END FOR;


	FOR k IN [plots['plotx'].curve_set] CREATE

	  	plots['plotx','ploty','plotx_s','ploty_s'
			,'plotxt'].curve[k].legend,
		coll[1].plots['plotx'].curve[k].legend		ARE_THE_SAME;
	END FOR;
	FOR k IN [plots['plotx'].curve_set] CREATE

	    FOR j IN [1..plots['plotx'].curve[k].npnt] CREATE
		plots['plotx','ploty','plotxt'].curve[k].pnt[j].x ARE_THE_SAME;
		plots['plotx_s','ploty_s'].curve[k].pnt[j].x	  ARE_THE_SAME;
	    END FOR;
	END FOR;
	FOR k IN [plots['plotx'].curve_set] CREATE

	    FOR j IN [1..endpoints[1][k]] CREATE
		plots['plotx'].curve[k].pnt[j],
		coll[1].plots['plotx'].curve[k].pnt[j]		ARE_THE_SAME;
	    END FOR; 
	END FOR;
	FOR k IN [plots['plotx'].curve_set] CREATE
	    FOR i IN [2..ncolls] CREATE
		FOR j IN [1..coll[i].plots['plotx'].curve[k].npnt] CREATE
		 plots['plotx'].curve[k].pnt[j+endpoints[i-1][k]].y,
		 coll[i].plots['plotx'].curve[k].pnt[j].y	ARE_THE_SAME;
		END FOR;
	    END FOR;
	END FOR;

	FOR k IN [plots['ploty'].curve_set] CREATE

	    FOR j IN [1..endpoints[1][k]] CREATE
		plots['ploty'].curve[k].pnt[j],
		coll[1].plots['ploty'].curve[k].pnt[j]	ARE_THE_SAME;
	    END FOR; 
	END FOR;
	FOR k IN [plots['ploty'].curve_set] CREATE
	    FOR i IN [2..ncolls] CREATE
		FOR j IN [1..coll[i].plots['ploty'].curve[k].npnt] CREATE
		 plots['ploty'].curve[k].pnt[j+endpoints[i-1][k]].y,
		 coll[i].plots['ploty'].curve[k].pnt[j].y	ARE_THE_SAME;
		END FOR;
	    END FOR;
	END FOR;

	FOR k IN [plots['plotx_s'].curve_set] CREATE

	    FOR j IN [1..endpoints[1][k]] CREATE
		plots['plotx_s'].curve[k].pnt[j],
		coll[1].plots['plotx_s'].curve[k].pnt[j]	ARE_THE_SAME;
	    END FOR; 
	END FOR;
	FOR k IN [plots['plotx_s'].curve_set] CREATE
	    FOR i IN [2..ncolls] CREATE
		FOR j IN [1..coll[i].plots['plotx_s'].curve[k].npnt] CREATE
		 plots['plotx_s'].curve[k].pnt[j+endpoints[i-1][k]].y,
		 coll[i].plots['plotx_s'].curve[k].pnt[j].y	ARE_THE_SAME;
		END FOR;
	    END FOR;
	END FOR;

	FOR k IN [plots['ploty_s'].curve_set] CREATE

	    FOR j IN [1..endpoints[1][k]] CREATE
		plots['ploty_s'].curve[k].pnt[j],
		coll[1].plots['ploty_s'].curve[k].pnt[j]	ARE_THE_SAME;
	    END FOR; 
	END FOR;
	FOR k IN [plots['ploty_s'].curve_set] CREATE
	    FOR i IN [2..ncolls] CREATE
		FOR j IN [1..coll[i].plots['ploty_s'].curve[k].npnt] CREATE
		 plots['ploty_s'].curve[k].pnt[j+endpoints[i-1][k]].y,
		 coll[i].plots['ploty_s'].curve[k].pnt[j].y	ARE_THE_SAME;
		END FOR;
	    END FOR;
	END FOR;

	FOR k IN [plots['plotxt'].curve_set] CREATE

	    FOR j IN [1..endpoints[1][k]] CREATE
		plots['plotxt'].curve[k].pnt[j],
		coll[1].plots['plotxt'].curve[k].pnt[j]	ARE_THE_SAME;
	    END FOR; 
	END FOR;
	FOR k IN [plots['plotxt'].curve_set] CREATE
	    FOR i IN [2..ncolls] CREATE
		FOR j IN [1..coll[i].plots['plotxt'].curve[k].npnt] CREATE
		 plots['plotxt'].curve[k].pnt[j+endpoints[i-1][k]].y,
		 coll[i].plots['plotxt'].curve[k].pnt[j].y	ARE_THE_SAME;
		END FOR;
	    END FOR;
	END FOR;


	FOR i IN [2..ncolls] CREATE

	   FOR k IN [plots['plotx'].curve_set] CREATE
	      FOR j IN [1..coll[i].plots['plotx'].curve[k].npnt] CREATE
		 plots['plotx'].curve[k].pnt[j+endpoints[i-1][k]].x
		  = plots['plotx'].curve[k].pnt[endpoints[i-1][k]].x
		 	+ coll[i].plots['plotx'].curve[k].pnt[j].x;
		 plots['plotx_s'].curve[k].pnt[j+endpoints[i-1][k]].x
		  = plots['plotx_s'].curve[k].pnt[endpoints[i-1][k]].x
		 	+ coll[i].plots['plotx_s'].curve[k].pnt[j].x;
	      END FOR;
	   END FOR;
	END FOR;


   METHODS
     METHOD clear;
	RUN coll[1..ncolls].clear;
	z_space.fixed 				:= FALSE;
     END clear;
     METHOD specify;
	z_space.fixed 				:= TRUE;
	RUN coll[1..ncolls].specify;
     END specify;
     METHOD reset;
	RUN clear;
	RUN specify;
     END reset;
     METHOD plot_values;
	RUN coll[1..ncolls].plot_values;

	FOR i IN [2..ncolls] DO

	   FOR k IN [plots['plotx'].curve_set] DO
	      FOR j IN [1..coll[i].plots['plotx'].curve[k].npnt] DO
		 plots['plotx'].curve[k].pnt[j+endpoints[i-1][k]].x
		  := plots['plotx'].curve[k].pnt[endpoints[i-1][k]].x
		 	+ coll[i].plots['plotx'].curve[k].pnt[j].x;
		 plots['plotx_s'].curve[k].pnt[j+endpoints[i-1][k]].x
		  := plots['plotx_s'].curve[k].pnt[endpoints[i-1][k]].x
		 	+ coll[i].plots['plotx_s'].curve[k].pnt[j].x;
	      END FOR;
	   END FOR;
	END FOR;
     END plot_values;

END coll_stack_plot;

MODEL coll_column_plot;

	nfeeds					IS_A integer_constant;
	components				IS_A set OF symbol_constant;
	coll_stack[1..nfeeds+1]			IS_A coll_stack_plot;

	box_height				IS_A factor;
	xreb[components],	
	ycond[components]			IS_A fraction;
	components,
	coll_stack[1..nfeeds+1].components	ARE_THE_SAME;

	box_height,
	coll_stack[1..nfeeds+1].box_height	ARE_THE_SAME;

	plots['plotx',
	    'ploty',
	    'plotx_s',
	    'ploty_s',
	    'plotxt']				IS_A plt_plot_symbol;


	plots['plotx'].curve_set,
	plots['plotxt'].curve_set,
	plots['ploty'].curve_set,
	plots['plotx_s'].curve_set,
	plots['ploty_s'].curve_set			ARE_THE_SAME;

	z_space					IS_A factor;
	stack_npnt[1..nfeeds+1][plots['plotx'].curve_set],
	endpoints[1..nfeeds+1][plots['plotx'].curve_set]	IS_A integer_constant;

	z_space,
	coll_stack[1..nfeeds+1].z_space		ARE_THE_SAME;
	z_space := 0.1;

	plots['plotx'].curve_set,
	coll_stack[1..nfeeds+1].plots['plotx'].curve_set	ARE_THE_SAME;

	FOR k IN [plots['plotx'].curve_set] CREATE

		plots['plotx'].curve[k].npnt,
		plots['plotxt'].curve[k].npnt,
		plots['ploty'].curve[k].npnt,
		plots['plotx_s'].curve[k].npnt,
		plots['ploty_s'].curve[k].npnt		ARE_THE_SAME;
	END FOR;
	FOR k IN [plots['plotx'].curve_set] CREATE


	  FOR j IN [1..nfeeds+1] CREATE
		stack_npnt[j][k],
		coll_stack[j].plots['plotx'].curve[k].npnt	ARE_THE_SAME;
	  END FOR;
	END FOR;
	FOR k IN [plots['plotx'].curve_set] CREATE

		endpoints[1][k] :==  stack_npnt[1][k];
	END FOR;
	FOR k IN [plots['plotx'].curve_set] CREATE
	  FOR j IN [2..nfeeds+1] CREATE
		endpoints[j][k] :== endpoints[j-1][k] + stack_npnt[j][k];
	  END FOR;
	END FOR;
	FOR k IN [plots['plotx'].curve_set] CREATE
		plots['plotx'].curve[k].npnt :== 1 + endpoints[nfeeds+1][k];
	END FOR;

	FOR k IN ['plotx','ploty','plotx_s','ploty_s','plotxt'] CREATE
		plots[k].title,
		coll_stack[1..nfeeds+1].coll[1].plots[k].title	ARE_THE_SAME;
		plots[k].XLabel,
		coll_stack[1..nfeeds+1].coll[1].plots[k].XLabel	ARE_THE_SAME;
		plots[k].YLabel,
		coll_stack[1..nfeeds+1].coll[1].plots[k].YLabel	ARE_THE_SAME;
	END FOR;

	FOR k IN [plots['plotx'].curve_set] CREATE

	  	plots['plotx','ploty','plotx_s'
			,'ploty_s','plotxt'].curve[k].legend,
		coll_stack[1..nfeeds+1].coll[1].
		    plots['plotx'].curve[k].legend	ARE_THE_SAME;
	END FOR;
	FOR k IN [plots['plotx'].curve_set] CREATE

	  FOR j IN [1..plots['plotx'].curve[k].npnt-1] CREATE
		plots['plotx','plotxt'].curve[k].pnt[j].x,
		plots['ploty'].curve[k].pnt[j+1].x		ARE_THE_SAME;
		plots['plotx_s'].curve[k].pnt[j].x,
		plots['ploty_s'].curve[k].pnt[j+1].x		ARE_THE_SAME;
	  END FOR;
	END FOR;

	FOR k IN [plots['plotx'].curve_set] CREATE

	  FOR j IN [1..stack_npnt[1][k]] CREATE
		plots['plotx'].curve[k].pnt[j],
		coll_stack[1].plots['plotx'].curve[k].pnt[j]	ARE_THE_SAME;
	  END FOR;
	END FOR;
	FOR k IN [plots['plotx'].curve_set] CREATE

	  FOR i IN [2..nfeeds+1] CREATE
	    FOR j IN [1..stack_npnt[i][k]] CREATE
		plots['plotx'].curve[k].pnt[j+endpoints[i-1][k]].y,
		coll_stack[i].plots['plotx'].curve[k].pnt[j].y	ARE_THE_SAME;
	
	    END FOR;
	  END FOR;
	END FOR;

	FOR k IN [components] CREATE
		plots['plotx'].curve[k].pnt[plots['plotx'].curve[k].npnt].y,
		xreb[k]	ARE_THE_SAME;
	END FOR;

	plots['plotx'].curve['box']
	 .pnt[plots['plotx'].curve['box'].npnt],
	plots['plotx'].curve['box'].pnt[plots['plotx']
	 .curve['box'].npnt-1]		ARE_THE_SAME;

	FOR k IN [plots['plotx_s'].curve_set] CREATE
	    FOR j IN [1..stack_npnt[1][k]] CREATE
		plots['plotx_s'].curve[k].pnt[j],
		coll_stack[1].plots['plotx_s'].curve[k].pnt[j]	ARE_THE_SAME;
	    END FOR;
	END FOR;
	FOR k IN [plots['plotx_s'].curve_set] CREATE
	  FOR i IN [2..nfeeds+1] CREATE
	    FOR j IN [1..stack_npnt[i][k]] CREATE
		plots['plotx_s'].curve[k].pnt[j+endpoints[i-1][k]].y,
		coll_stack[i].plots['plotx_s'].curve[k].pnt[j].y	ARE_THE_SAME;
	
	    END FOR;
	  END FOR;
	END FOR;
	FOR k IN [components] CREATE
		plots['plotx_s'].curve[k].pnt[plots['plotx_s'].curve[k].npnt].y,
		xreb[k]	ARE_THE_SAME;
	END FOR;

	plots['plotx_s'].curve['box'].pnt[plots['plotx_s']
		.curve['box'].npnt],
	plots['plotx_s'].curve['box'].pnt[plots['plotx_s']
		.curve['box'].npnt-1]		ARE_THE_SAME;



	FOR k IN [components] CREATE
		plots['ploty'].curve[k].pnt[1].y,
		plots['ploty_s'].curve[k].pnt[1].y,
		ycond[k]	ARE_THE_SAME;
	END FOR;

	plots['ploty'].curve['box'].pnt[1],
	plots['ploty'].curve['box'].pnt[2] 	ARE_THE_SAME;

	FOR k IN [plots['ploty'].curve_set] CREATE
	    FOR j IN [1..stack_npnt[1][k]] CREATE
		plots['ploty'].curve[k].pnt[j+1],
		coll_stack[1].plots['ploty'].curve[k].pnt[j]	ARE_THE_SAME;
	    END FOR;
	END FOR;
	FOR k IN [plots['ploty'].curve_set] CREATE
	  FOR i IN [2..nfeeds+1] CREATE
	    FOR j IN [1..stack_npnt[i][k]] CREATE
		plots['ploty'].curve[k].pnt[1+j+endpoints[i-1][k]].y,
		coll_stack[i].plots['ploty'].curve[k].pnt[j].y	ARE_THE_SAME;
	
	    END FOR;
	  END FOR;
	END FOR;

	plots['ploty_s'].curve['box'].pnt[1],
	plots['ploty_s'].curve['box'].pnt[2]	ARE_THE_SAME;

	FOR k IN [plots['ploty_s'].curve_set] CREATE
	    FOR j IN [1..stack_npnt[1][k]] CREATE
		plots['ploty_s'].curve[k].pnt[j+1],
		coll_stack[1].plots['ploty_s'].curve[k].pnt[j]	ARE_THE_SAME;
	    END FOR;
	END FOR;
	FOR k IN [plots['ploty_s'].curve_set] CREATE
	  FOR i IN [2..nfeeds+1] CREATE
	    FOR j IN [1..stack_npnt[i][k]] CREATE
		plots['ploty_s'].curve[k].pnt[1+j+endpoints[i-1][k]].y,
		coll_stack[i].plots['ploty_s'].curve[k].pnt[j].y	ARE_THE_SAME;
	
	    END FOR;
	  END FOR;
	END FOR;

	FOR k IN [plots['plotxt'].curve_set] CREATE
	    FOR j IN [1..stack_npnt[1][k]] CREATE
		plots['plotxt'].curve[k].pnt[j],
		coll_stack[1].plots['plotxt'].curve[k].pnt[j]	ARE_THE_SAME;
	    END FOR;
	END FOR;
	FOR k IN [plots['plotxt'].curve_set] CREATE
	  FOR i IN [2..nfeeds+1] CREATE
	    FOR j IN [1..stack_npnt[i][k]] CREATE
		plots['plotxt'].curve[k].pnt[j+endpoints[i-1][k]].y,
		coll_stack[i].plots['plotxt'].curve[k].pnt[j].y	ARE_THE_SAME;
	
	    END FOR;
	  END FOR;
	END FOR;

	FOR k IN [components] CREATE
		plots['plotxt'].curve[k].pnt[plots['plotxt']
			.curve[k].npnt].y,
		plots['plotxt'].curve[k].pnt[plots['plotxt']
			.curve[k].npnt-1].y			ARE_THE_SAME;
	END FOR;

	plots['plotxt'].curve['box'].pnt[plots['plotxt']
		.curve['box'].npnt],
	plots['plotxt'].curve['box'].pnt[plots['plotxt']
		.curve['box'].npnt-1]		ARE_THE_SAME;

(* *)
	FOR k IN [plots['plotx'].curve_set] CREATE
	  FOR i IN [2..nfeeds+1] CREATE
	    FOR j IN [1..stack_npnt[i][k]] CREATE
		plots['plotx'].curve[k].pnt[j+endpoints[i-1][k]].x =
		    z_space +
		    plots['plotx'].curve[k].pnt[endpoints[i-1][k]].x +
		    coll_stack[i].plots['plotx'].curve[k].pnt[j].x;
		plots['plotx_s'].curve[k].pnt[j+endpoints[i-1][k]].x =
			1 +
		    plots['plotx_s'].curve[k].pnt[endpoints[i-1][k]].x +
		    coll_stack[i].plots['plotx_s'].curve[k].pnt[j].x;
	     END FOR;
	  END FOR;
	END FOR;

	FOR k IN [components] CREATE
		plots['plotx'].curve[k].pnt[plots['plotx'].curve[k].npnt].x =
		  z_space + 
		  plots['plotx'].curve[k].pnt[plots['plotx'].curve[k].npnt-1].x;
		plots['plotx_s'].curve[k].pnt[plots['plotx_s'].curve[k].npnt].x
		  = 1 + plots['plotx_s'].curve[k].pnt[plots['plotx_s']
		 	.curve[k].npnt-1].x;
		plots['ploty'].curve[k].pnt[1].x = plots['ploty'].curve[k].pnt[2].x - z_space;
		plots['ploty_s'].curve[k].pnt[1].x = plots['ploty_s'].curve[k].pnt[2].x -1.0;
		plots['plotxt'].curve[k].pnt[plots['plotxt'].curve[k].npnt].x 
		  = z_space + plots['plotxt']
			 .curve[k].pnt[plots['plotxt'].curve[k].npnt-1].x;
	END FOR;

   METHODS
     METHOD clear;
	RUN coll_stack[1..nfeeds+1].clear;
	xreb[components].fixed := FALSE;
	ycond[components].fixed := FALSE;
     END clear;
     METHOD specify;
	RUN coll_stack[1..nfeeds+1].specify;
     END specify;
     METHOD reset;
	RUN clear;
	RUN specify;
     END reset;
     METHOD plot_values;
	RUN coll_stack[1..nfeeds+1].plot_values;

	FOR k IN [plots['plotx'].curve_set] DO
	  FOR i IN [2..nfeeds+1] DO
	    FOR j IN [1..stack_npnt[i][k]] DO
		plots['plotx'].curve[k].pnt[j+endpoints[i-1][k]].x :=
			z_space + plots['plotx'].curve[k].pnt[endpoints[i-1][k]].x +
			coll_stack[i].plots['plotx'].curve[k].pnt[j].x;
		plots['plotx_s'].curve[k].pnt[j+endpoints[i-1][k]].x :=
			1 + plots['plotx_s'].curve[k].pnt[endpoints[i-1][k]].x +
			coll_stack[i].plots['plotx_s'].curve[k].pnt[j].x;
	     END FOR;
	  END FOR;
	END FOR;

	FOR k IN [components] DO
		plots['plotx'].curve[k].pnt[plots['plotx'].curve[k].npnt].x :=
		  z_space + 
		  plots['plotx'].curve[k].pnt[plots['plotx'].curve[k].npnt-1].x;
		plots['plotx_s'].curve[k].pnt[plots['plotx_s'].curve[k].npnt].x
		  := 1 + plots['plotx_s'].curve[k].pnt[plots['plotx_s']
		 	.curve[k].npnt-1].x;
		plots['ploty'].curve[k].pnt[1].x := plots['ploty'].curve[k].pnt[2].x - z_space;
		plots['ploty_s'].curve[k].pnt[1].x := plots['ploty_s'].curve[k].pnt[2].x -1.0;
		plots['plotxt'].curve[k].pnt[plots['plotxt'].curve[k].npnt].x 
		  := z_space + plots['plotxt']
			 .curve[k].pnt[plots['plotxt'].curve[k].npnt-1].x;
	END FOR;


     END plot_values;

END coll_column_plot;

	
MODEL ternary_column_plot REFINES coll_column_plot;

	ternary[components]	IS_A plt_plot_integer;

	ternary[components].ncurve :== 2;
	ternary[components].curve[2].npnt :== 2;

	ternary[components].curve[2].pnt[1].x := 0.0;
	ternary[components].curve[2].pnt[1].y := 1.0;
	ternary[components].curve[2].pnt[2].x := 1.0;
	ternary[components].curve[2].pnt[2].y := 0.0;
	

	FOR i IN components CREATE
	    ternary[i].curve[1].npnt,
		plots['plotx'].curve[i].npnt	ARE_THE_SAME;
	END FOR;
	FOR i IN components CREATE 
	    
		ternary[i].XLabel :== CHOICE[components-[i]];
		ternary[i].YLabel :== CHOICE[(components-[i])-[CHOICE[components-[i]]]];
		ternary[i].curve[1..2].legend :== ' ' ;
		ternary[i].title :== ' ' ;
	END FOR;
	FOR i IN components CREATE
	    FOR j IN [1..ternary[i].curve[1].npnt] CREATE
		ternary[i].curve[1].pnt[j].x,
		    plots['plotx'].curve[CHOICE[components -
		    [i]]].pnt[j].y ARE_THE_SAME;
		
		ternary[i].curve[1].pnt[j].y,
		    plots['plotx'].curve[((components - [i]) -
		    [CHOICE[components - [i]]])].pnt[j].y	ARE_THE_SAME;
	    END FOR;
	END FOR;
	
END ternary_column_plot;

MODEL coll_w_plot;

	col	IS_A coll;
	plot	IS_A coll_plot;
	components	IS_A set OF symbol_constant;

	col.z_set.up_down,
	plot.up_down				ARE_THE_SAME;

	components,
	col.components,
	plot.components				ARE_THE_SAME;
	col.ntrays,
	plot.ntrays				ARE_THE_SAME;

	FOR j IN [0..col.ntrays+1] CREATE

		col.z_set.z_values[j],
		plot.z_values[j]		ARE_THE_SAME;
		col.z_set.s_values[j],
		plot.s_values[j]		ARE_THE_SAME;
	END FOR;

	FOR i IN col.components CREATE
	   FOR j IN [1..col.ntrays] CREATE
		col.x[j][i],
		plot.x[j][i]			ARE_THE_SAME;
		col.y[j][i],
		plot.y[j][i]			ARE_THE_SAME;
		col.x_hat[j][i],
		plot.tray_x_hat[i][j]		ARE_THE_SAME;
	   END FOR;
		col.topliq.state.y[i],
		plot.x[0][i]			ARE_THE_SAME;
		col.topvap.state.y[i],
		plot.y[0][i]			ARE_THE_SAME;
		col.botliq.state.y[i],
		plot.x[col.ntrays+1][i]		ARE_THE_SAME;
		col.botvap.state.y[i],
		plot.y[col.ntrays+1][i]		ARE_THE_SAME;

		col.end_x_hat['top'][i],
		plot.tray_x_hat[i][0]		ARE_THE_SAME;
		col.end_x_hat['bot'][i],
		plot.tray_x_hat[i][col.ntrays+1]	ARE_THE_SAME;
	END FOR;
   METHODS
     METHOD clear;
	RUN col.clear;
     END clear;
     METHOD seqmod;
	RUN col.seqmod;
     END seqmod;
     METHOD specify;
	RUN col.specify;
     END specify;
     METHOD reset;
 	RUN col.reset;
     END reset;
     METHOD scale;
	RUN col.scale;
     END scale;

END coll_w_plot;

MODEL coll_stack_w_plot;
 	coll_stack		IS_A coll_stack;
	plots			IS_A coll_stack_plot;
	components		IS_A set OF symbol_constant;

	components,
	coll_stack.components,
	plots.components	ARE_THE_SAME;

	coll_stack.ncolls,
	plots.ncolls		ARE_THE_SAME;

	FOR k IN [1..plots.ncolls] CREATE

		coll_stack.coll[k].z_set.up_down,
		plots.coll[k].up_down		ARE_THE_SAME;

		coll_stack.coll[k].ntrays,
		plots.coll[k].ntrays		ARE_THE_SAME;
	END FOR;
	FOR k IN [1..plots.ncolls] CREATE

	   FOR j IN [0..coll_stack.coll[k].ntrays+1] CREATE
		coll_stack.coll[k].z_set.z_values[j],
		plots.coll[k].z_values[j]	ARE_THE_SAME;
		coll_stack.coll[k].z_set.s_values[j],
		plots.coll[k].s_values[j]	ARE_THE_SAME;
	   END FOR;
	END FOR;
	FOR k IN [1..plots.ncolls] CREATE

	   FOR i IN coll_stack.coll[k].components CREATE
	      FOR j IN [1..coll_stack.coll[k].ntrays] CREATE

		coll_stack.coll[k].x[j][i],
		plots.coll[k].x[j][i]		ARE_THE_SAME;
		coll_stack.coll[k].y[j][i],
		plots.coll[k].y[j][i]		ARE_THE_SAME;
		coll_stack.coll[k].x_hat[j][i],
		plots.coll[k].tray_x_hat[i][j]	ARE_THE_SAME;
	      END FOR;
	   END FOR;
	END FOR;
	FOR k IN [1..plots.ncolls] CREATE
	   FOR i IN coll_stack.coll[k].components CREATE
		coll_stack.coll[k].topliq.state.y[i],
		plots.coll[k].x[0][i]		ARE_THE_SAME;
		coll_stack.coll[k].topvap.state.y[i],
		plots.coll[k].y[0][i]		ARE_THE_SAME;
		coll_stack.coll[k].botliq.state.y[i],
		plots.coll[k].x[plots.coll[k].ntrays+1][i]	ARE_THE_SAME;
		coll_stack.coll[k].botvap.state.y[i],
		plots.coll[k].y[plots.coll[k].ntrays+1][i]	ARE_THE_SAME;

		coll_stack.coll[k].end_x_hat['top'][i],
		plots.coll[k].tray_x_hat[i][0]			ARE_THE_SAME;
		coll_stack.coll[k].end_x_hat['bot'][i],
		plots.coll[k]
		.tray_x_hat[i][plots.coll[k].ntrays+1]		ARE_THE_SAME;
	      
	    END FOR;
	END FOR;

   METHODS
     METHOD clear;
	RUN coll_stack.clear;
	RUN plots.clear;
     END clear;
     METHOD seqmod;
	plots.box_height.fixed := TRUE;
	RUN coll_stack.seqmod;
     END seqmod;
     METHOD specify;
	plots.box_height.fixed := TRUE;
	RUN coll_stack.specify;
     END specify;
     METHOD reset;
	RUN clear;
	RUN specify;
     END reset;
     METHOD scale;
	RUN coll_stack.scale;
     END scale;
END coll_stack_w_plot;


MODEL column_w_plot;
	col				IS_A coll_column;
	plots				IS_A coll_column_plot;
	components			IS_A set OF symbol_constant;
	scale				IS_A scaling_constant;
	
	components,
	col.components,
	plots.components			ARE_THE_SAME;
	
	col.nfeeds,
	plots.nfeeds				ARE_THE_SAME;

	FOR j IN [1..col.nfeeds+1] CREATE
		col.coll_stack[j].ncolls,
		plots.coll_stack[j].ncolls	ARE_THE_SAME;
	END FOR;

	FOR i IN col.components CREATE

		col.reboiler.liqout['bottoms'].state.y[i],
		plots.xreb[i]			ARE_THE_SAME;
		col.condenser.vapout['vapor_product'].state.y[i],
		plots.ycond[i]			ARE_THE_SAME;
	END FOR;

	FOR m IN [1..col.nfeeds+1] CREATE
	  FOR k IN [1..col.coll_stack[m].ncolls] CREATE
		col.coll_stack[m].coll[k].z_set.up_down,
		plots.coll_stack[m].coll[k].up_down	ARE_THE_SAME;

		col.coll_stack[m].coll[k].ntrays,
		plots.coll_stack[m].coll[k].ntrays	ARE_THE_SAME;
	  END FOR;
	END FOR;
	FOR m IN [1..col.nfeeds+1] CREATE
	  FOR k IN [1..col.coll_stack[m].ncolls] CREATE
	   FOR j IN [0..col.coll_stack[m].coll[k].ntrays+1] CREATE

		col.coll_stack[m].coll[k].z_set.z_values[j],
		plots.coll_stack[m].coll[k].z_values[j]	ARE_THE_SAME;
		col.coll_stack[m].coll[k].z_set.s_values[j],
		plots.coll_stack[m].coll[k].s_values[j]	ARE_THE_SAME;
 	   END FOR;
	  END FOR;
	END FOR;
	FOR m IN [1..col.nfeeds+1] CREATE
	  FOR k IN [1..col.coll_stack[m].ncolls] CREATE
	   FOR i IN col.coll_stack[m].coll[k].components CREATE

	      FOR j IN [1..col.coll_stack[m].coll[k].ntrays] CREATE
		col.coll_stack[m].coll[k].x[j][i],
		plots.coll_stack[m].coll[k].x[j][i]		ARE_THE_SAME;
		col.coll_stack[m].coll[k].y[j][i],
		plots.coll_stack[m].coll[k].y[j][i]		ARE_THE_SAME;
		col.coll_stack[m].coll[k].x_hat[j][i],
		plots.coll_stack[m].coll[k].tray_x_hat[i][j]	ARE_THE_SAME;
	      END FOR;
	   END FOR;
	  END FOR;
	END FOR;
	FOR m IN [1..col.nfeeds+1] CREATE
	  FOR k IN [1..col.coll_stack[m].ncolls] CREATE
	   FOR i IN col.coll_stack[m].coll[k].components CREATE
		col.coll_stack[m].coll[k].topliq.state.y[i],
		plots.coll_stack[m].coll[k].x[0][i]		ARE_THE_SAME;
		col.coll_stack[m].coll[k].topvap.state.y[i],
		plots.coll_stack[m].coll[k].y[0][i]		ARE_THE_SAME;
		col.coll_stack[m].coll[k].botliq.state.y[i],
		plots.coll_stack[m].coll[k]
		 .x[col.coll_stack[m].coll[k].ntrays+1][i]	ARE_THE_SAME;
		col.coll_stack[m].coll[k].botvap.state.y[i],
		plots.coll_stack[m].coll[k]
		 .y[col.coll_stack[m].coll[k].ntrays+1][i]	ARE_THE_SAME;

		col.coll_stack[m].coll[k].end_x_hat['top'][i],
		plots.coll_stack[m].coll[k].tray_x_hat[i][0]	ARE_THE_SAME;
		col.coll_stack[m].coll[k].end_x_hat['bot'][i],
		plots.coll_stack[m].coll[k]
		 .tray_x_hat[i][col.coll_stack[m].coll[k].ntrays+1]	ARE_THE_SAME;
	   END FOR;
	  END FOR;
	END FOR;

   METHODS
     METHOD clear;
	RUN col.clear;
	RUN plots.clear;
     END clear;
     METHOD seqmod;
	plots.z_space.fixed := TRUE;
	plots.box_height.fixed := TRUE;
	RUN col.seqmod;
     END seqmod;
     METHOD specify;
	plots.z_space.fixed := TRUE;
	plots.box_height.fixed := TRUE;
	RUN col.specify;
     END specify;
     METHOD reset;
	RUN clear;
	RUN specify;
     END reset;
     METHOD scale;
	RUN col.scale;
     END scale;
END column_w_plot;















