(*
	View factor calculation from a bank of tubes
	to an opposing flat surface. This case is of
	interest in solar collector design.

                      F
	    ___	         _._          ___
	 .˙˙   ˙˙.    .˙˙ : ˙˙.G   .˙˙   ˙˙.
	:     E   :  :    :   C:. :     D   :
	|    ´    |  |  C ^   E| .|    ´    |·········
	'.       .' B'.   :   .'; '.H      .'      ^
	  '-----'     .'--:--'. .   '-----'        :
	               .  :  .  `    I˙ .          : h
	                . : .   ˙        ˙ .       :
	                 .:.     .           ˙ .   :
	------------------+------+----------+----+-+->
                       O      A        X      J   x
                             (x1)            (x2)

	(ASCII art above uses UTF-8 encoding)

	The view factor from the entire surface of cylinder
	'C' to the plane slice from A to J is calculated and
	returned as 'F' by this model.

	The distance OC is given by the variable 'h'.
	The distance OA is given by the variable 'x1'.
	The distance OJ is given by the variable 'x2'.
	The radius of the cylinders is given by 'r'.
	The spacing of the cylinders (centre-to-centre) is 2*s.

	At the point X there is a region boundary. To the
	right of X, some beams from the cylinder C are 
	occluded by the cylinder D. For this reason, the model
	currently requires the conditional solver CMSlv.

	The calculation method uses Hottel's crossed string rule
	to determine the view factor.
*)

REQUIRE "atoms.a4l";

(*
	Calculates the angle (relative to the top of the
	circle) at which a tangent strikes a circle, given the position
	of the point (x,-h) and the radius of the circle (r).
*)
MODEL wrapping_angle(
	x WILL_BE delta_distance;
	h WILL_BE distance;
	r WILL_BE distance;
	theta WILL_BE angle;
);
	theta = arccos((x*sqrt(h^2 + x^2 - r^2) - h*r) / (x^2 + h^2));
END wrapping_angle;

(*
	Calculate the length L of a piece of string from the top
	of a circle, of radius r, stretched around the circle to a
	point (x,-h) located below the circle and to one side.

	This will be used in the Hottel 'crossed string' method to
	calculate view factors from a tube bank to a plane wall.
*)
MODEL wrapping_length(
	x WILL_BE delta_distance;
	h WILL_BE distance;
	r WILL_BE distance;
	L WILL_BE distance; (* resulting length (output) *)
);
	theta IS_A angle;
	wrap_ang IS_A wrapping_angle(x,h,r,theta);
	
	L_tan, L_arc IS_A distance;
	L_tan = sqrt(h^2 + x^2 - r^2);
	L_arc = r*theta;
	L = L_tan + L_arc;
END wrapping_length;

(*
	Calculate the length L of a piece of string from the
	top of a circle (at 0,0, with radius r) stretched to a
	remote point (x,-h)	for the case where the string is
	partly obstructed by another circle adjacent to the first
	one. The obstructing circle is located at (2s,0) and has
	the same radius r.
*)
MODEL wrapping_length_obstructed(
	x WILL_BE delta_distance;
	h WILL_BE distance;
	r WILL_BE distance;
	s WILL_BE distance;
	L WILL_BE distance; (* resulting length (output) *)
);
	phi IS_A angle;
	phi = arcsin(r/s);

	L_arc, L_span, L_tan IS_A distance;
	L_arc = r*phi;
	L_span = 2*sqrt(s^2-r^2);
	
	x1 IS_A delta_distance;
	-x1 = (x - 2*s);
	psi IS_A angle;
	wrap IS_A wrapping_angle(x1,h,r,psi);

	L_hug IS_A delta_distance;
	L_hug = r*(psi - (1{PI} - phi));
	
	L_tan = sqrt(h^2 + x1^2 - r^2);

	L = L_arc + L_span + L_hug + L_tan;

END wrapping_length_obstructed;

(*
	Conditional model, to calculate the length of a string
	as for wrapping_length_obstructed and wrapping_length
	for remote points (x,-h) where it is not yet known
	whether or not the string is obstructed by an adjacent
	circle. The distance x_crit is calculated, then depending
	on its value, the appropriate wrapping length formula
	is used. The equations are condensed from the above
	models into fewer (but more complex) equations, to help
	with model convergence.
*)
MODEL wrapping_length_ambi(
	x WILL_BE delta_distance;
	h WILL_BE distance;
	r WILL_BE distance;
	s WILL_BE distance;
	L WILL_BE distance; (* resulting length (output) *)
);
	x_crit IS_A distance;
	x_crit = s + h*sqrt(s^2-r^2)/r;

	(* obstructed case *)	
	phi IS_A angle;
	phi = arcsin(r/s);

	x1 IS_A delta_distance;
	-x1 = (x - 2*s);

	psi IS_A angle;
	wrap IS_A wrapping_angle(x1,h,r,psi);

	L_span IS_A distance;
	L_span = 2*sqrt(s^2-r^2);
	L_hug IS_A delta_distance;
	L_hug = r*(psi - (1{PI} - phi));

	L_expr_obstructed: L = r*phi + L_span + L_hug + sqrt(h^2 + x1^2 - r^2);

	(* unobstructed case *)
	theta IS_A angle;
	wrap_clear IS_A wrapping_angle(x,h,r,theta);

	L_expr_clear: L = r*theta + sqrt(h^2 + x^2 - r^2);
	
	CONDITIONAL
		obstructed_expr: abs(x) > x_crit;
	END CONDITIONAL;
	is_obstructed IS_A boolean_var;
	is_obstructed == SATISFIED(obstructed_expr, 1e-3{m});
	WHEN(is_obstructed)
		CASE TRUE:
			USE L_expr_obstructed;
		CASE FALSE:
			USE L_expr_clear;
	END WHEN;

END wrapping_length_ambi;	

(*
	View factor from a circle C to a flat strip OA
	placed below it (see diagram at top of file)
*)
MODEL vfac_circle_plane(
	x WILL_BE delta_distance;
	h WILL_BE distance;
	r WILL_BE distance;
	F WILL_BE fraction; (* output *)
);
	xzero IS_A delta_distance;
	xzero = 0;
	OBF, OECF, ADBF, ACF IS_A distance;
	OBF_wrap IS_A wrapping_length(xzero,h,r,OBF);
	OECF,OBF ARE_THE_SAME;
	xneg IS_A delta_distance;
	xneg = -x;
	ADBF_wrap IS_A wrapping_length(xneg,h,r,ADBF);
	ACF_wrap IS_A wrapping_length(x,h,r,ACF);

	F = ((ADBF + OECF) - (OBF + ACF)) / (4{PI}*r);
END vfac_circle_plane;

(*
	View factor from a circle C to a flat strip OA
	placed below it, for the case where the view is
	obstructed by adjacent circle D (see diagram at top
	of file).
*)
MODEL vfac_circle_plane_obstructed(
	x WILL_BE delta_distance;
	h WILL_BE distance;
	r WILL_BE distance;
	s WILL_BE distance;
	F WILL_BE fraction; (* output *)
);
	xzero IS_A delta_distance;
	xzero = 0;
	OBF, OEGF, JKBF, JIHGF IS_A distance;
	OBF_wrap IS_A wrapping_length(xzero,h,r,OBF);
	OEGF,OBF ARE_THE_SAME;
	xneg IS_A delta_distance;
	xneg = -x;
	JKBF_wrap IS_A wrapping_length(xneg,h,r,JKBF);
	JIHGF_wrap IS_A wrapping_length_obstructed(x,h,r,s,JIHGF);

	F = ((JKBF + OEGF) - (OBF + JIHGF)) / (4{PI}*r);
END vfac_circle_plane_obstructed;

(*
	Conditional model that calculates the view factor
	from a circle C to a flat string OA placed below it,
	for the case where it may or may not be obstructed by
	a neighbouring circle D.
*)
MODEL vfac_circle_plane_ambi(
	x WILL_BE delta_distance;
	h WILL_BE distance;
	r WILL_BE distance;
	s WILL_BE distance;
	F WILL_BE fraction; (* output *)
);
	xzero IS_A delta_distance;
	xzero = 0;
	OBF, OEGF, JKBF, JIHGF IS_A distance;
	OBF_wrap IS_A wrapping_length(xzero,h,r,OBF);
	OEGF,OBF ARE_THE_SAME;
	xneg IS_A delta_distance;
	xneg = -x;
	JKBF_wrap IS_A wrapping_length(xneg,h,r,JKBF);
	JIHGF_wrap IS_A wrapping_length_ambi(x,h,r,s,JIHGF);

	F = ((JKBF + OEGF) - (OBF + JIHGF)) / (4{PI}*r);
END vfac_circle_plane_ambi;

(*
	Model of a tube bank (many tubes) facing opposite a
	flat surface. Model serves only to calculate the view
	factors, which will then be used elsewhere.
*)
MODEL tubebank;
	x1, x2 IS_A delta_distance;
	h IS_A distance;
	r IS_A distance;
	L IS_A distance;
	s IS_A distance;

	F1, F2, F IS_A fraction;
	F1_wrap IS_A vfac_circle_plane_ambi(x1,h,r,s,F1);
	F2_wrap IS_A vfac_circle_plane_ambi(x2,h,r,s,F2);
	F = F2 - F1;
METHODS
METHOD on_load;
	FIX x1; x1:= 102 {mm};
	FIX x2; x2:= 208 {mm};
	FIX h; h:= 117 {mm};
	FIX r; r:= 42.164 {mm} / 2.;
	FIX s; s:= 575. {mm} / 12 / 2;
END on_load;
METHOD self_test;
	ASSERT abs(wrap.L_tan - 150 {mm}) < 1 {mm};
	ASSERT abs(wrap.theta - 62 {deg}) < 1.5 {deg};
END self_test;

END tubebank;
