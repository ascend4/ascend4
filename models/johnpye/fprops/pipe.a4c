REQUIRE "johnpye/fprops/rankine_fprops.a4c";
REQUIRE "johnpye/shapes.a4c";

IMPORT "johnpye/fprops/pipe_sequence_plot";

MODEL flow_node REFINES stream_node;
	(* a stream that includes information about its crosssectional shape *)
	shape IS_A shape_generic;
	A ALIASES shape.A;
END flow_node;

MODEL flow_equipment REFINES stream_equipment;
	(* a SISO component that knows about the shape of its ports *)
	outlet IS_REFINED_TO flow_node;
	inlet IS_REFINED_TO flow_node;
END flow_equipment;
	
(*
	TODO FIXME this model still doesn't include thermophysical property calculation
	(ie, fprops_lam and fprops_mu)
*)

MODEL viscosity_eq;
	mu IS_A viscosity;
	T IS_A temperature;
	cd IS_A fluid;

	calc_mu: fprops_mu_T_incomp(
		T : INPUT;
		mu : OUTPUT;
		cd : DATA
	);
METHODS
METHOD default;
	IF cd.component == 'sodium' THEN
		RUN enable;
	ELSE
		RUN disable;
		FIX mu := 0.024 {cP}; (* you should set your own value for this *)
	END IF;
END default;
METHOD default_self;
	RUN default;
END default_self;
METHOD enable;
	calc_mu[1].included := TRUE;
	FREE mu;
END enable;
METHOD disable;
	calc_mu[1].included := FALSE;
	FIX mu;
END disable;	
END viscosity_eq;


MODEL thcond_eq;
	k IS_A thermal_conductivity;
	T IS_A temperature;
	cd IS_A fluid;

	calc_k: fprops_lam_T_incomp(
		T : INPUT;
		k : OUTPUT;
		cd : DATA
	);
METHODS
METHOD default; END default;
METHOD default_self; RUN default; END default_self;
END thcond_eq;

MODEL thcond_eq_test REFINES thcond_eq;
	cd.component :== 'sodium';
	cd.type :== 'incomp';
METHODS
METHOD on_load;
	RUN thcond_eq::default_self;
	FIX T := 1000 {K};
END on_load;
METHOD self_test;
	ASSERT abs(k - 54.24 {W/m/K})< 0.005 {W/m/K};
END self_test;
END thcond_eq_test;


MODEL specheat_eq;
	cp IS_A specific_heat_capacity;
	T IS_A temperature;
	cd IS_A fluid;

	calc_cp: fprops_cp_T_incomp(
		T : INPUT;
		cp : OUTPUT;
		cd : DATA
	);
METHODS
METHOD default; END default;
METHOD default_self; RUN default; END default_self;
END specheat_eq;

MODEL specheat_eq_test REFINES specheat_eq;
	cd.component :== 'sodium';
	cd.type :== 'incomp';
METHODS
METHOD on_load;
	RUN specheat_eq::default_self;
	FIX T := 1100 {K};
END on_load;
METHOD self_test;
	ASSERT abs(cp - 1.261 {kJ/kg/K})< 0.001 {kJ/kg/K};
END self_test;
END specheat_eq_test;




MODEL pipe_config_generic;
	(* this model contains the material and heat transfer parameters for the
	pipe in question, allowing similar pipe configurations to be easily
	merged, even if shape/length are different *)
END pipe_config_generic;

MODEL pipe_config_adiabatic REFINES pipe_config_generic;
	eps "pipe roughness" IS_A distance;
END pipe_config_adiabatic;

MODEL pipe_config_insul REFINES pipe_config_adiabatic;
	k_insul "thermal conductivity of the insulation" IS_A thermal_conductivity;
	k_pipe "thermal conductivity of the pipe" IS_A thermal_conductivity;
	h_ext IS_A heat_transfer_coefficient;
	emiss "pipe external emissivity" IS_A fraction;
	corr_intconv "internal convection heat transfer correction choice" IS_A symbol_constant;
END pipe_config_insul;	



MODEL pipe_adiabatic REFINES flow_equipment;
	solid IS_A solid_cylinder;
	solid.end, inlet.shape, outlet.shape ARE_THE_SAME;
	D ALIASES solid.d;
	L ALIASES solid.L;
	A "cross-sectional area" IS_A area;
	A, inlet.A ARE_THE_SAME;	
	A_int ALIASES solid.side.A;	

	config IS_A pipe_config_adiabatic;
	eps ALIASES config.eps;

	(* energy equation, ignoring potential energy *)
	Vel_in, Vel_out IS_A speed;
	Vel_in * A = mdot * inlet.v;
	Vel_out * A = mdot * outlet.v;
	en_eqn: inlet.h + 0.5*Vel_in^2 = outlet.h + 0.5*Vel_out^2;

	(* pressure drops *)
	Re "Reynolds number" IS_A positive_factor;
	f_D "Friction factor (Darcy)" IS_A positive_factor;
	mu "dynamic viscosity" IS_A viscosity;
	Re = Vel_in * D / inlet.v / mu;
	(* Swamee-Jain eqn *)
	f_D = 0.25 / (log10(eps/(D*3.7) +5.74/Re^0.9))^2; (* note: constant f assumed over length, calculated with inlet spec vol *)
	(* momentum equation *)
	mom_eqn: (inlet.p - outlet.p) = (0.5 * Vel_in^2 / inlet.v) * f_D * (L/D);

	calc_mu IS_A viscosity_eq;
	calc_mu.cd, cd ARE_THE_SAME;
	calc_mu.T, inlet.T ARE_THE_SAME;
	mu, calc_mu.mu ARE_THE_SAME;

	ke_in, ke_out IS_A specific_energy;
	ke_in = 0.5 * Vel_in^2;
	ke_out = 0.5 * Vel_out^2;

	Vel_sonic_out "speed of sound at fluid outlet" IS_A speed;
	rho_out IS_A mass_density;
	rho_out = 1 / outlet.v;
	calc_w: fprops_w_Trho(
		outlet.T, rho_out : INPUT;
		Vel_sonic_out : OUTPUT;
		outlet.cd : DATA
	);
	T_in_C IS_A delta_temperature;
	T_in_C = inlet.T - 273.15 {K};
	T_out_C IS_A delta_temperature;
	T_out_C = outlet.T - 273.15 {K};
METHODS
METHOD default_self;
	RUN stream_equipment::default_self;
	Re.nominal := 100e5;
	RUN calc_mu.default_self;
END default_self;	
END pipe_adiabatic;


MODEL pipe_adiabatic_test REFINES pipe_adiabatic;
	cd.component :== 'water';
	cd.type :== 'helmholtz';
METHODS
METHOD on_load;
	RUN pipe_adiabatic::default_self;
	FIX D := 10 {mm};
	FIX L := 5 {m};
	FIX mdot := 0.1 {kg/s};
	FIX inlet.p := 35 {bar};
	FIX inlet.T := 370 {K} + 273.15 {K};

	FIX mu := 0.024 {cP};
	FIX eps := 0.09 {mm};

	(* initial guesses *)
	f_D := 0.0001;
	inlet.h := 4000 {kJ/kg};
	outlet.h := 4000 {kJ/kg};
END on_load;
END pipe_adiabatic_test;

MODEL pipe_adiabatic_test_sodium REFINES pipe_adiabatic;
	cd.component :== 'sodium';
	cd.type :== 'incomp';
METHODS
METHOD on_load;
	RUN pipe_adiabatic::default_self;
	RUN calc_mu.enable;
	FIX D := 10 {mm};
	FIX L := 5 {m};
	FIX mdot := 0.1 {kg/s};
	FIX inlet.p := 35 {bar};
	FIX inlet.T := 370 {K} + 273.15 {K};

	FIX eps := 0.09 {mm};

	(* initial guesses *)
	f_D := 0.0001;
	inlet.h := 514. {kJ/kg};
	outlet.h := 1146. {kJ/kg};
END on_load;
END pipe_adiabatic_test_sodium;

MODEL pipe_heat_loss REFINES pipe_adiabatic;
	NOTES 'description' SELF {This is a model of a bare pipe with external
	radiative and convective heat loss. It is a bit crappy, since it doesn't
	handle the tube-wall temperature difference, which will usually be
	important. It also doesn't (currently) calculate the internal convection
	coefficient, which will vary with temperature, in particular.}
	END NOTES;

	D_o IS_A distance;
	t IS_A distance;
	D_o = D + 2*t;
	
	T_amb IS_A temperature;
	U "pipe overall heat transfer coeff" IS_A heat_transfer_coefficient;
	emiss "pipe external emissivity" IS_A fraction;
	Q IS_A energy_rate;
	Q = - U * L*1{PI}*D_o * (inlet.T - T_amb) - 1{SIGMA_C}*emiss*(inlet.T^4 - T_amb^4);

	(* energy equation, ignoring potential energy *)
	(* note that the pipe_adiabatic::en_eqn must be de-included in METHODS *)
	en_eqn_Q: Q/mdot + inlet.h + 0.5*Vel_in^2 = outlet.h + 0.5*Vel_out^2;
METHODS
METHOD default_self;
	RUN pipe_adiabatic::default_self;
	en_eqn.included := FALSE;
	en_eqn_Q.included := TRUE;
	RUN calc_mu.disable;
END default_self;	
END pipe_heat_loss;


MODEL pipe_heat_loss_test REFINES pipe_heat_loss;
	cd.component :== 'water';
	cd.type :== 'helmholtz';
METHODS
METHOD on_load;
	RUN pipe_heat_loss::default_self;
	FIX D := 10 {mm};
	FIX t := 1 {mm};
	FIX L := 5 {m};
	FIX mdot := 0.1 {kg/s};
	FIX inlet.p := 35 {bar};
	FIX inlet.T := 370 {K} + 273.15 {K};

	FIX mu := 0.024 {cP};
	FIX eps := 0.09 {mm};
	FIX emiss := 0.8;

	FIX U := 20 {W/m^2/K};
	FIX T_amb := 20 {K} + 273.15{K};

	(* initial guesses *)
	f_D := 0.0001;

END on_load;
END pipe_heat_loss_test;

MODEL pipe_heat_loss_test_incomp REFINES pipe_heat_loss;
	cd.component :== 'sodium';
	cd.type :== 'incomp';
METHODS
METHOD on_load;
	RUN pipe_heat_loss::default_self;
	FIX D := 10 {mm};
	FIX t := 1 {mm};
	FIX L := 5 {m};
	FIX mdot := 0.1 {kg/s};
	FIX inlet.p := 35 {bar};
	FIX inlet.T := 370 {K} + 273.15 {K};

	FIX mu := 0.024 {cP};
	FIX eps := 0.09 {mm};
	FIX emiss := 0.8;

	FIX U := 20 {W/m^2/K};
	FIX T_amb := 20 {K} + 273.15{K};

	(* initial guesses *)
	f_D := 0.0001;
	
	SOLVER QRSlv;
	OPTION convopt 'RELNOM_SCALE';
END on_load;
END pipe_heat_loss_test_incomp;
	


MODEL pipe_heat_loss_insul REFINES pipe_adiabatic;
	NOTES 'description' SELF {This is a model of an insulated pipe, with
	internal convection, pipe wall conduction, insulation conduction
	considered, and external convection (with a fixed convection coefficient)
	as well as external radiative heat loss (with a fixed emissivity). The
	effect of internal convection can be turned off to improve speed.}
	END NOTES;

	config IS_REFINED_TO pipe_config_insul;
	
	solid_pipe IS_A solid_tube;
	solid_insul IS_A solid_tube;
	solid.side, solid_pipe.inner ARE_THE_SAME;
	solid_pipe.outer, solid_insul.inner ARE_THE_SAME;
	
	D_o ALIASES solid_pipe.d_o;
	t ALIASES solid_pipe.t;
	D_ext ALIASES solid_insul.d_o;
	t_insul ALIASES solid_insul.t;
	A_ext ALIASES solid_insul.outer.A;

	T_ext IS_A temperature;
	T_ext_C IS_A delta_temperature;
	T_ext_C = T_ext - 273.15 {K};

	R_insul IS_A thermal_resistance;
	R_insul = ln(D_ext / D_o) / 2{PI} / config.k_insul / L;

	R_pipe IS_A thermal_resistance;
	R_pipe = ln(D_o / D) / 2{PI} / config.k_pipe / L;

	Nu, Pe, Pr IS_A factor;

	R_intconv IS_A thermal_resistance;
	SELECT(config.corr_intconv)
	CASE 'skupinski':
		Pe = Re * Pr;
		calc_k IS_A thcond_eq;
		calc_cp IS_A specheat_eq;
		k ALIASES calc_k.k;
		cp ALIASES calc_cp.cp;
		calc_k.T, calc_cp.T, T_flow ARE_THE_SAME;
		calc_k.cd, calc_cp.cd, cd ARE_THE_SAME;

		(*corr_intconv IS_A symbol_constant;*)
		Nu = 4.82 + 0.0185 * (Re*Pr)^0.827;
		Pr = cp * mu / k;

		R_intconv = D / (k * Nu * A_int);
 	OTHERWISE:
		R_intconv = 0;
	END SELECT;

	T_flow IS_A temperature;
	T_flow = (inlet.T + outlet.T) / 2;

	Q * (R_intconv + R_insul + R_pipe) = T_flow - T_ext;

	T_amb IS_A temperature;
	Q IS_A energy_rate;
	Q_rad IS_A energy_rate;
	Q_rad = 1{SIGMA_C}*config.emiss*(T_ext^4 - T_amb^4);
	Q_conv IS_A energy_rate;
	Q_conv = config.h_ext * A_ext * (T_ext - T_amb);

	R_ext IS_A thermal_resistance;
	Q * R_ext = T_ext - T_amb;

	Q = Q_conv + Q_rad;

	(* energy equation, ignoring potential energy *)
	(* note that the pipe_adiabatic::en_eqn must be de-included in METHODS *)
	en_eqn_Q: inlet.h + 0.5*Vel_in^2 = Q/mdot + outlet.h + 0.5*Vel_out^2;
METHODS
METHOD default_self;
	RUN pipe_adiabatic::default_self;
	en_eqn.included := FALSE;
	en_eqn_Q.included := TRUE;
	t.lower_bound := 0 {m};
	t_insul.lower_bound := 0 {m};
	D.lower_bound := 0 {m};
	RUN calc_mu.disable;
END default_self;	
END pipe_heat_loss_insul;

MODEL pipe_heat_loss_insul_test REFINES pipe_heat_loss_insul;
	cd.component :== 'sodium';
	cd.type :== 'incomp';
	corr_intconv :== 'skupinski';
METHODS
METHOD on_load;
	RUN pipe_heat_loss_insul::default_self;

	FIX mdot := 50 {kg/s};
	FIX inlet.p := 10 {bar};
	FIX inlet.T := 720 {K} + 273.15 {K};

	FIX T_amb := 20 {K} + 273.15{K};

	FIX D := 100 {mm};
	FIX t := 3 {mm};
	(*FIX t_insul := 500 {mm};*)
	FIX T_ext := 50 {K} + 273.15 {K};
	FIX L := 100 {m};

	FIX config.h_ext := 10 {W/m^2/K};
	(* FIX k_insul := 0.2 {W/m/K}; (* rough number for rockwool at high temperature *)*)
	FIX config.k_insul := 0.08 {W/m/K}; (* 'microporous insulation board', https://is.gd/5j9Gkw *)
	FIX config.k_pipe := 22.4 {W/m/K}; (* Haynes 230 @ 700°C: https://is.gd/F0RICh *)
	FIX config.eps := 0.09 {mm};
	FIX config.emiss := 0.8;

	(* initial guesses *)
	f_D := 0.0001;
	
	SOLVER QRSlv;
	OPTION convopt 'RELNOM_SCALE';
END on_load;
END pipe_heat_loss_insul_test;



MODEL pipe_sequence REFINES flow_equipment;
	solid IS_A solid_cylinder;
	solid_pipe IS_A solid_tube;
	solid_insul IS_A solid_tube;
	solid_pipe.outer, solid_insul.inner ARE_THE_SAME;
	solid.side, solid_pipe.inner ARE_THE_SAME;
	L ALIASES solid.L;
	D ALIASES solid.d;
	t_insul ALIASES solid_insul.t;
	t_pipe ALIASES solid_pipe.t;
	
	n IS_A integer_constant;
	P[1..n] IS_A pipe_heat_loss_insul;
	FOR i IN [1..n-1] CREATE
		P[i].outlet, P[i+1].inlet ARE_THE_SAME;
	END FOR;
	inlet, P[1].inlet ARE_THE_SAME;
	outlet, P[n].outlet ARE_THE_SAME;

	P[1..n].solid ARE_THE_SAME;
	P[1..n].solid_insul ARE_THE_SAME;
	P[1..n].solid_pipe ARE_THE_SAME;
	P[1].solid_insul.end, solid_insul.end ARE_THE_SAME;
	P[1].solid_pipe.end, solid_pipe.end ARE_THE_SAME;
	corr_intconv ALIASES P[1].config.corr_intconv;

	P[1..n].config ARE_THE_SAME;
	config ALIASES P[1].config;
	k_pipe ALIASES P[1].config.k_pipe;
	k_insul ALIASES P[1].config.k_insul;	
	h_ext ALIASES P[1].config.h_ext;
	emiss ALIASES P[1].config.emiss;
	eps ALIASES P[1].config.eps;
	L = n * P[1].L;

	P[1..n].D_o ARE_THE_SAME;
	P[1..n].D_ext ARE_THE_SAME;

	P[1..n].T_amb ARE_THE_SAME;
	T_amb ALIASES P[1].T_amb;
	T_in ALIASES inlet.T;
	T_out ALIASES outlet.T;
	p_in ALIASES inlet.p;
	p_out ALIASES outlet.p;

	Q IS_A energy_rate;
	Q = SUM[P[i].Q | i IN [1..n]];

METHODS
METHOD default_self;
	FOR i IN [1..n] DO
		RUN P[i].default_self;
	END FOR;
END default_self;
METHOD enable_calc_mu;
	FOR i IN [1..n] DO
		RUN P[i].calc_mu.enable;
	END FOR;
END enable_calc_mu;
END pipe_sequence;

MODEL pipe_sequence_test_sodium REFINES pipe_sequence;
	n :== 30;

	cd.component :== 'sodium';
	cd.type :== 'incomp';
	config.corr_intconv :== 'none';
METHODS
METHOD plot;
	EXTERNAL pipe_sequence_plot(SELF);
END plot;
METHOD on_load;
	RUN default_self;
	FIX L := 500 {m};
	FIX t_insul := 100 {mm};
	FIX t_pipe := 3 {mm};
	FIX D := 200 {mm};

	FIX eps := 0.09 {mm};
	FIX h_ext := 20 {W/m^2/K};
	FIX emiss := 0.8;
	FIX k_insul := 0.08 {W/m/K}; (* 'microporous insulation board', https://is.gd/5j9Gkw *)
	FIX k_pipe := 22.4 {W/m/K}; (* Haynes 230 @ 700°C: https://is.gd/F0RICh *)

	FIX T_amb := 20 {K} + 273.15 {K};

	FIX inlet.p := 3 {bar};
	FIX inlet.T := 500 {K} + 273.15 {K};
	FIX mdot := 60 {kg/s};

	IF cd.component == 'sodium' THEN
		P[1].inlet.h := 400 {kJ/kg};
		RUN enable_calc_mu;
	ELSE
		P[1].inlet.h := 4000 {kJ/kg};
		FIX P[1..n].mu := 0.024 {cP};
	END IF;
	
	RUN enable_calc_mu;
	SOLVER QRSlv;
	OPTION convopt 'RELNOM_SCALE';
END on_load;
END pipe_sequence_test_sodium;


MODEL pipe_sequence_test_water REFINES pipe_sequence;
	n :== 1;

	cd.component :== 'water';
	cd.type :== 'helmholtz';
METHODS
METHOD plot;
	EXTERNAL pipe_sequence_plot(SELF);
END plot;
METHOD on_load;
	RUN default_self;
	FIX L := 50 {m};
	FIX t_insul := 100 {mm};
	FIX t_pipe := 3 {mm};
	FIX D := 100 {mm};

	FIX eps := 0.09 {mm};
	FIX h_ext := 20 {W/m^2/K};
	FIX emiss := 0.8;
	FIX k_insul := 0.08 {W/m/K}; (* 'microporous insulation board', https://is.gd/5j9Gkw *)
	FIX k_pipe := 22.4 {W/m/K}; (* Haynes 230 @ 700°C: https://is.gd/F0RICh *)

	FIX T_amb := 20 {K} + 273.15 {K};

	FIX inlet.p := 35 {bar};
	FIX inlet.T := 500 {K} + 273.15 {K};
	FIX mdot := 1 {kg/s};

	IF cd.component == 'sodium' THEN
		P[1].inlet.h := 400 {kJ/kg};
		RUN enable_calc_mu;
	ELSE
		P[1].inlet.h := 4000 {kJ/kg};
		FIX P[1..n].mu := 0.024 {cP};
	END IF;
	
	RUN enable_calc_mu;
	SOLVER QRSlv;
	OPTION convopt 'RELNOM_SCALE';
END on_load;
END pipe_sequence_test_water;

