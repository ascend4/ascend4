REQUIRE "johnpye/fprops/rankine_fprops.a4c";
REQUIRE "johnpye/fprops/pipe.a4c";

MODEL throttle REFINES stream_equipment;
	inlet.h, outlet.h ARE_THE_SAME;
METHODS
METHOD default_self;
	RUN inlet.default_self;
	RUN outlet.default_self;
END default_self;
END throttle;

(*
	Model of a linear array of CSP solar concentrators (eg dishes) with pressure
	drop and heat loss in the connection lines, and fixed heat input in each
	collector, but no assumed pressure drop (boiler_simple model).

	     PC1     PC2     ...    PCn     (cold-side pipe connections)
	>>-o------+-------+-------+-------\
	          |       |       |       |
	      DI1 |   DI2 |   ... |   DIn |   (dishes/collectors)
	<<-o------+-------+-------+-------/
	     PH1     PH2     ...    PHn     (hot-size pipe connections)

*)
MODEL csparray;
	n IS_A integer_constant;

	PC[1..n] IS_A pipe_heat_loss_insul;
	PH[1..n] IS_A pipe_heat_loss_insul;
	TE[1..n-1] IS_A tee;
	JO[1..n-1] IS_A merge;
	TH[1..n-1] IS_A throttle;
	DI[1..n] IS_A boiler_simple;

	PC[1..n].config, PH[1..n].config ARE_THE_SAME;
	corr_intconv ALIASES PC[1].config.corr_intconv;
	k_pipe ALIASES PC[1].config.k_pipe;
	k_insul ALIASES PC[1].config.k_insul;	
	h_ext ALIASES PC[1].config.h_ext;
	emiss ALIASES PC[1].config.emiss;
	eps ALIASES PC[1].config.eps;

	m_pipe, m_insul IS_A mass;
	rho_pipe, rho_insul IS_A mass_density;
	C_pipe, C_insul, C_tot IS_A monetary_unit;
	c_pipe, c_insul IS_A cost_per_mass;
	F_pipe, F_insul IS_A factor;
	m_pipe = rho_pipe * SUM[PC[i].solid_pipe.V + PH[i].solid_pipe.V | i IN [1..n]];
	m_insul = rho_insul * SUM[PC[i].solid_insul.V + PH[i].solid_insul.V | i IN [1..n]];
	C_pipe = c_pipe * F_pipe * m_pipe;
	C_insul = c_insul * F_insul * m_insul;
	C_tot = C_pipe + C_insul;
	
	(* wire up the network... *)
	FOR i IN [1..n-1] CREATE
		PC[i].outlet, TE[i].inlet ARE_THE_SAME;
		TE[i].outlet_branch, DI[i].inlet ARE_THE_SAME;
		DI[i].outlet, TH[i].inlet ARE_THE_SAME;
		TH[i].outlet, JO[i].inlet_branch ARE_THE_SAME;
		JO[i].outlet, PH[i].inlet ARE_THE_SAME;
		TE[i].outlet,PC[i+1].inlet ARE_THE_SAME;
		JO[i].inlet,PH[i+1].inlet ARE_THE_SAME;
	END FOR;
	PC[n].outlet, DI[n].inlet ARE_THE_SAME; (* last collector in the chain *)
	DI[n].outlet, PH[n].inlet ARE_THE_SAME;

	(* all pipe legs are identical in geometry *)
	PC[1..n].solid, PH[1..n].solid ARE_THE_SAME;
	PC[1..n].solid_pipe, PH[1..n].solid_pipe ARE_THE_SAME;
	PC[1..n].solid_insul, PH[1..n].solid_insul ARE_THE_SAME;
	D_pipe ALIASES PC[1].D;
	t_pipe ALIASES PC[1].t_pipe;
	t_insul ALIASES PC[1].t_insul;
	L ALIASES PC[1].L;
	
	T_amb IS_A temperature;
	T_amb, PC[1..n].T_amb, PH[1..n].T_amb ARE_THE_SAME;

	Qdot_onecoll IS_A energy_rate;
	Qdot_onecoll, DI[1..n].Qdot ARE_THE_SAME;
	DI[1..n].eta ARE_THE_SAME; eta_DI ALIASES DI[1].eta;

	Qdot_coll_tot IS_A energy_rate;
	Qdot_coll_tot = SUM[DI[i].Qdot | i IN [1..n]];

	Qdot_loss_tot IS_A energy_rate;
	Qdot_loss_tot = SUM[PC[i].Q + PH[i].Q|i IN [1..n]];

	Qdot_net IS_A energy_rate;
	Qdot_net = outlet.mdot*outlet.h - inlet.mdot*inlet.h;

	eta_th_array IS_A fraction;
	eta_th_array = Qdot_net / Qdot_coll_tot;
	
	inlet ALIASES PC[1].inlet;
	outlet ALIASES PH[1].outlet;

	(* try: same mass flow for each dish *)
	DI[1..n].mdot ARE_THE_SAME;

	cd ALIASES inlet.cd;

	p_in ALIASES PC[1].inlet.p;
	p_out ALIASES PH[1].outlet.p;
METHODS
METHOD default_self;
	FOR i IN [1..n-1] DO
		RUN TE[i].default_self;
		RUN JO[i].default_self;
		RUN TH[i].default_self;
	END FOR;
	FOR i IN [1..n] DO
		RUN PC[i].default_self;
		RUN DI[i].default_self;
		RUN PH[i].default_self;
	END FOR;
END default_self;
METHOD enable_calc_mu;
	FOR i IN [1..n] DO
		RUN PC[i].calc_mu.enable;
		RUN PH[i].calc_mu.enable;
	END FOR;
END enable_calc_mu;	
METHOD disable_calc_mu;
	FOR i IN [1..n] DO
		RUN PC[i].calc_mu.disable;
		RUN PH[i].calc_mu.disable;
	END FOR;
END disable_calc_mu;	
END csparray;

MODEL disharray REFINES csparray;
	n :== 4;
	cd.component :== 'water';
	cd.type :== 'helmholtz';
	corr_intconv :== 'none';
METHODS
METHOD on_load;
	RUN default_self;
	FOR i IN [1..n-1] DO
		(*RUN TE[i].disable_cons_mass;*)
		(*FIX TE[i].phi := 0.5;*)
	END FOR;
	FIX Qdot_onecoll := 400 {kW};
	FIX eta_DI := 1;
	FIX D_pipe := 25 {mm};
	FIX L := 40 {m};
	FIX t_pipe := 4 {mm};
	FIX t_insul := 100 {mm};
	FIX eps := 0.015 {mm};
	FIX emiss := 0.5;
	FIX mu := 0.024 {cP};
	FIX h := 10 {W/m^2/K};
	FIX inlet.p := 50 {bar};
	FIX inlet.T := 100 {K} +  273.15 {K};
	FIX DI[1].mdot := 0.1 {kg/s}; (* same for all dishes *)
	FIX T_amb := 300 {K};
	(* initial guesses to help the solver *)
	PC[1..n].inlet.h := 400 {kJ/kg};
END on_load;
END disharray;

(* FIXME there is some problem with the 'enable_calc_mu'... doesn't work with
more complex networks. Could it be the soft dependence mu(p,T) on p, which
perhaps should be removed? *)

MODEL towerarray REFINES csparray;
	n :== 10;
	cd.component :== 'sodium';
	cd.type :== 'incomp';
	corr_intconv :== 'none'; (* pipe R_th due to int conv is negl for sodium *)
METHODS
METHOD on_load;
	RUN default_self;
	FOR i IN [1..n-1] DO
		(*RUN TE[i].disable_cons_mass;*)
		(*FIX TE[i].phi := 0.5;*)
	END FOR;
	FIX Qdot_onecoll := 5 {MW};
	FIX eta_DI := 1;
	FIX D_pipe := 200 {mm};
	FIX L := 200 {m};
	FIX t_pipe := 4 {mm};
	FIX t_insul := 100 {mm};

	FIX eps := 0.09 {mm};
	FIX h_ext := 20 {W/m^2/K};
	FIX emiss := 0.8;
	FIX k_insul := 0.08 {W/m/K}; (* 'microporous insulation board', https://is.gd/5j9Gkw *)
	FIX k_pipe := 22.4 {W/m/K}; (* Haynes 230 @ 700°C: https://is.gd/F0RICh *)
	FIX rho_pipe := 9 {g/cm^3}; (* Haynes 230 @ 700°C: https://is.gd/F0RICh *)
	FIX rho_insul := 300 {g/m^3}; (* 'microporous insulation board', https://is.gd/5j9Gkw *)
	FIX F_pipe := 2.5;
	FIX F_insul := 20;
	FIX c_pipe := 84 {USD/kg};
	FIX c_insul := 0.8 {USD/kg};

	FIX inlet.p := 50 {bar};
	FIX inlet.T := 500 {K} +  273.15 {K};
	FIX DI[1].mdot := 20 {kg/s}; (* same for all dishes *)
	FIX T_amb := 300 {K};

	(* initial guesses to help the solver *)
	PC[1..n].inlet.h := 400 {kJ/kg};

	SOLVER QRSlv;
	OPTION convopt 'RELNOM_SCALE';
END on_load;
END towerarray;



