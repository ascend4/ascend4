(*********************************************************************\
                        column_tests.asc
                        by Robert S. Huss
                        Part of the Ascend Library

This file is part of the Ascend modeling library.

Copyright (C) 1994

The Ascend modeling library is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

The Ascend Language Interpreter is distributed in hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License along with
the program; if not, write to the Free Software Foundation, Inc., 675
Mass Ave, Cambridge, MA 02139 USA.  Check the file named COPYING.

Use of this module is demonstrated by the associated script file
column_tests.s.
\*********************************************************************)

(*********************************************************************\
  $Date: 1997/07/03 14:51:41 $
  $Revision: 1.7 $
  $Author: mthomas $
  $Source: /afs/cs.cmu.edu/project/ascend/Repository/models/examples/column_tests.asc,v $
\*********************************************************************)

(*
	column_tests.asc by Robert S. Huss

	This file contains column examples.  The model test_column1
	can be used as a template for generating column models.  For
	multicomponent columns you should change the the
	model to refine plot_column rather than mccabe_plot.

	The script file column_tests.s runs these examples.

	The models in this file require the following files:
	system.lib
	atoms.lib
	components.lib
	H_S_thermodynamics.lib or H_G_thermodynamics.lib
	plot.lib
	stream.lib
	flash.lib
	column.lib
*)

(* REQUIRE column.lib *)

MODEL mccabe_plot REFINES plot_column;


	mcplot	IS_A plt_plot_integer;


	mcplot.ncurve :== 5;
	mcplot.title :== 'McCabe-Thiele Plot of Column';
	mcplot.XLabel :== 'Liquid composition';
	mcplot.YLabel :== 'vapor composition';
	mcplot.curve[1].legend :== 'equilibrium';
	mcplot.curve[1].npnt :== plotx.curve[CHOICE[col.components]].npnt;
	mcplot.curve[2].legend :== 'stages';
	mcplot.curve[2].npnt :== 2*(plotx.curve[CHOICE[col.components]].npnt) + 1;
	mcplot.curve[3].legend :== 'operating line';
	mcplot.curve[3].npnt :== plotx.curve[CHOICE[col.components]].npnt+1;
	mcplot.curve[4].legend :== 'x=y';
	mcplot.curve[4].npnt :== 2;
	mcplot.curve[5].legend :== 'qline';
	mcplot.curve[5].npnt :== 2;

	FOR j IN [1..mcplot.curve[1].npnt] CREATE
		mcplot.curve[1].pnt[j].x,
		plotx.curve[CHOICE[col.components]].pnt[j].y		ARE_THE_SAME;
		mcplot.curve[1].pnt[j].y,
		ploty.curve[CHOICE[col.components]].pnt[j].y		ARE_THE_SAME;

		mcplot.curve[2].pnt[2*j-1],
		mcplot.curve[3].pnt[j]		ARE_THE_SAME;
		mcplot.curve[2].pnt[2*j],
		mcplot.curve[1].pnt[j]		ARE_THE_SAME;
	END FOR;

	FOR j IN [2..mcplot.curve[3].npnt-1] CREATE

		mcplot.curve[3].pnt[j].x,
		plotx.curve[CHOICE[col.components]].pnt[j-1].y		ARE_THE_SAME;
		mcplot.curve[3].pnt[j].y,
		ploty.curve[CHOICE[col.components]].pnt[j].y		ARE_THE_SAME;
	END FOR;
		


		mcplot.curve[2].pnt[1].x,
		mcplot.curve[2].pnt[1].y,
		ploty.curve[CHOICE[col.components]].pnt[1].y		ARE_THE_SAME;
		mcplot.curve[2].pnt[2*(plotx.curve[CHOICE[col.components]].npnt)+1].x,
		mcplot.curve[2].pnt[2*(plotx.curve[CHOICE[col.components]].npnt)+1].y,
		plotx.curve[CHOICE[col.components]].pnt[plotx.curve[CHOICE[col.components]].npnt].y		ARE_THE_SAME;


		mcplot.curve[2].pnt[2*(plotx.curve[CHOICE[col.components]].npnt)+1],
		mcplot.curve[3].pnt[plotx.curve[CHOICE[col.components]].npnt+1]	ARE_THE_SAME;

		mcplot.curve[4].pnt[1],
		mcplot.curve[3].pnt[1]		ARE_THE_SAME;
		mcplot.curve[4].pnt[2],
		mcplot.curve[3].pnt[mcplot.curve[3].npnt]	ARE_THE_SAME;

		mcplot.curve[5].pnt[2],
		mcplot.curve[1].pnt[col.feed_loc]	ARE_THE_SAME;
END mccabe_plot;


MODEL test_column1 REFINES mccabe_plot;
	
	feed			IS_A molar_stream;

	mcplot.curve[5].pnt[1].x,
	mcplot.curve[5].pnt[1].y,
	feed.state.y[CHOICE[col.components]]		ARE_THE_SAME;

	col.components :== ['a','b'];


	col IS_REFINED_TO simple_column;

	col.ntrays :== 13;
	col.feed_loc :== 7;


	feed, col.tray[col.feed_loc].input['feed'] ARE_THE_SAME;
	
   METHODS
     METHOD values; 
	feed.f['a'] := 3{mol/s};
	feed.f['b'] := 3{mol/s};
	col.tray[col.feed_loc].alpha['a'] := 1.5;
	col.tray[col.feed_loc].alpha['b'] := 1.0;
	col.tray[col.feed_loc].q := 1.0;
	RUN col.propogate_feed;
	col.tray[1].reflux_ratio := 1.3;
	col.tray[1].totprod.Ftot := 3{mol/s};
	col.tray[1].prodsplit['vapor_product'] := 0.0;
	col.tray[col.ntrays].prodsplit['vapor_product'] := 0.0;    
	RUN plot_values;  
	col.reduce := 0.5;
   END values; 

END test_column1;   

MODEL td_test_column1 REFINES test_column1;

        col IS_REFINED_TO td_column;

        col.data['a'] IS_REFINED_TO methanol;
        col.data['b'] IS_REFINED_TO water;


   METHODS
     METHOD new_values;
        feed.state.phi['liquid']                := 1.0;
        feed.state.phi['vapor']                 := 0.0;
        feed.state.alpha['vapor']['a']          := 2.0;
        feed.state.alpha['vapor']['b']          := 0.5;

   END  new_values;

END td_test_column1;


MODEL murph1 REFINES td_test_column1;

	col IS_REFINED_TO murph_column;

   METHODS
     METHOD murph_plot_values;
	FOR k IN [plotx.curve_set] DO
	    FOR j IN [2..col.feed_loc-1] DO
		plotx.curve[k].pnt[j].x := plotx.curve[k].pnt[j-1].x
				+ col.tray[j].murph_eff;
		ploty.curve[k].pnt[j].x := ploty.curve[k].pnt[j-1].x
				+ col.tray[j].murph_eff;
	    END FOR;
		plotx.curve[k].pnt[col.feed_loc].x := 
			plotx.curve[k].pnt[col.feed_loc-1].x + 1;
		ploty.curve[k].pnt[col.feed_loc].x := 
			ploty.curve[k].pnt[col.feed_loc-1].x + 1;
	    FOR j IN [col.feed_loc+1..col.ntrays-1] DO
		plotx.curve[k].pnt[j].x := plotx.curve[k].pnt[j-1].x 
				+ col.tray[j].murph_eff;
		ploty.curve[k].pnt[j].x := ploty.curve[k].pnt[j-1].x
				 + col.tray[j].murph_eff;
	    END FOR;
		plotx.curve[k].pnt[col.ntrays].x := 
			plotx.curve[k].pnt[col.ntrays-1].x + 1;
		ploty.curve[k].pnt[col.ntrays].x := 
			ploty.curve[k].pnt[col.ntrays-1].x + 1;
	END FOR;
      END murph_plot_values;
      METHOD increase_murph;
	col.top_murph := 1.5;
	col.bot_murph := 1.5;
      END increase_murph;
END murph1;







