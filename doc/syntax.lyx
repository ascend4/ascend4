#LyX 1.4.3 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage[bookmarks]{hyperref}
\usepackage{lmodern}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Chapter
Syntax reference
\begin_inset LatexCommand \label{cha:ASCENDSyntax}

\end_inset


\end_layout

\begin_layout Standard
We shall present an informal description of the ASCEND IV language.
 Being informal, we shall usually include examples and descriptions of the
 intended semantics along with the syntax of the items.
 At times the inclusion of semantics will seem to anticipate later definitions.
 We do this because we would also like this chapter to be used as a reference
 for the ASCEND language even after one generally understands it.
 Often one will need to clarify a point about a particular item and will
 not wish to have to search in several places to do so.
\end_layout

\begin_layout Standard
Syntax
\begin_inset LatexCommand \index{syntax}

\end_inset

 is the form or structure for the statements in ASCEND, where one worries
 about the exact words one uses, their ordering, the punctuation, etc.
 Semantics
\begin_inset LatexCommand \index{semantics}

\end_inset

 describe the meaning of a statement.
\end_layout

\begin_layout Standard
To distinguish between syntax and semantics, consider the statement
\end_layout

\begin_layout LyX-Code
y IS_A fraction;
\end_layout

\begin_layout Standard
Rules on the syntax for this statement tell us we need a user supplied instance
 name, y, followed by the ASCEND operator IS_A, followed by a type name
 (fraction).
 The statement terminates with a semicolon.
 The statement semantics says we are declaring the existence of an instance,
 locally named y, of the type fraction as a part within the current model
 definition and it is to be constructed when an instance of the current
 model definition is constructed.
\end_layout

\begin_layout Standard
The syntax for a computer language is often defined by using a Bachus-Naur
\begin_inset LatexCommand \index{Bachus-Naur}

\end_inset

 formal (BNF
\begin_inset LatexCommand \index{BNF}

\end_inset

) description.
 The complete YACC
\begin_inset LatexCommand \index{YACC}

\end_inset

 and FLEX
\begin_inset LatexCommand \index{FLEX}

\end_inset

 description of the language described (as presently implemented) is available
 by FTP and via the World Wide Web.
 The semantics of a very high level modeling language such as ASCEND IV
 are generally much more restrictive than the syntax.
 For this reason we do not include a BNF description in this paper.
 ASCEND IV is an experiment.
 The language is under constant scrutiny and improvement, so this document
 is under constant revision.
 
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
\InsetSpace ~

\end_layout

\begin_deeper
\begin_layout Chapter
Preliminaries
\end_layout

\begin_layout Standard
We will start off with some background information and some tips that make
 the rest of the chapter easier to read.
 ASCEND is an object-oriented (OO) language for hierarchical modeling that
 has been somewhat specialized for mathematical models.
 Most of the specialization is in the implementation and the user interface
 rather than the language definition.
 
\end_layout

\begin_layout Standard
We feel the single most distinguishing feature of mathematical models is
 that solving them efficiently requires that the solving algorithms be able
 to address the entire problem either simultaneously or in a decomposition
 of the natural problem structure that the algorithm determines is best
 for the machine(s) in use.
 In the ASCEND language object-orientation is used to organize natural structure
s and make them easier to understand.
 It is not used to hide the details of the objects.
 The user (or machine) is free to ignore uninteresting details, and the
 ASCEND environment provides tools for the runtime suppression of these.
\end_layout

\begin_layout Standard
ASCEND is well into its 4th generation.
 Some features we will describe are not yet implemented (some merely speculative
) and these are clearly marked (* 4+ *).
 Any feature not marked (* 4+ *)has been completely implemented, and thus
 any mismatch between the description given here and the software we distribute
 is a bug we want you to tell us about.
 
\end_layout

\begin_layout Standard
The syntax and semantics of ASCEND may seem at first a bit unusual.
 However, do not be afraid to just try what comes naturally if what we write
 here is unclear.
 The parser and compiler of ASCEND IV really will help you get things right.
 Of course if what we write here is unclear, please ask us about it because
 we aim to continuously improve both this document and the language system
 it describes.
\end_layout

\begin_layout Standard
We will describe, starting in Section 
\begin_inset LatexCommand \vref{sub:x.1.2Basic-Elements}

\end_inset

, the higher level concepts of ASCEND, but first some important punctuation
 rules.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
ASCEND\InsetSpace ~
is\InsetSpace ~
cAsE\InsetSpace ~
sensitive
\begin_inset LatexCommand \index{case sensitive}

\end_inset

! 
\end_layout

\begin_deeper
\begin_layout Standard
The keywords that are shown capitalized (or in lower case) in this chapter
 are that way because ASCEND is case sensitive.
 IS_A is an ASCEND keyword; isa, Is_a, and all the other permutations you
 can think of are NOT equivalent to IS_A.
 In declaring new types of models and variables the user is free to use
 any style of capitalization he or she may prefer; however, they must remain
 consistent or undefined types and instances will result.
\end_layout

\begin_layout Standard
This case restriction makes our code very readable, but hard to type without
 a smart editor.
 We have kept the case-sensitivity because, like all mathematicians, we
 find ourselves running out of good variable names if we are restricted
 to a 26 letter alphabet.
 We have developed smart add-ins for two UNIX editors, EMACS
\begin_inset LatexCommand \index{EMACS}

\end_inset

 and vi
\begin_inset LatexCommand \index{vi}

\end_inset

, for handling the upper case keywords and some other syntax elements.
 The use of these editors is described in another chapter.
 
\end_layout

\begin_layout Standard
The ASCEND IV parser is very picky and pedantic.
 It also tries to give helpful messages and occasionally even suggestions.
 New users should just dive in and make errors, letting the system help
 them learn how to avoid errors.
\end_layout

\begin_layout Section
Punctuation
\begin_inset LatexCommand \index{punctuation}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
This section covers both the punctuation that must be understood to read
 this document and the punctuation of ASCEND code.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
keywords
\begin_inset LatexCommand \index{keywords}

\end_inset

: ASCEND keywords and type names are given in the left column in bold format.
 It is generally clear from the main text which are keywords and which are
 type names.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Minor\InsetSpace ~
items:
\bar default
 Minor headings that are helpful in finding details are given in the left
 column in underline format.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
Tips: Special notes and hints are sometimes placed on the left.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
LHS
\begin_inset LatexCommand \index{LHS}

\end_inset

:
\bar default
 Left Hand Side.
 Abbreviation used frequently.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
RHS
\begin_inset LatexCommand \index{RHS}

\end_inset

:
\bar default
 Right Hand Side.
 Abbreviation used frequently.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Simple\InsetSpace ~
names
\begin_inset LatexCommand \index{simple names}

\end_inset

:
\bar default
 In ASCEND simple names are made of the characters a through z, A through
 Z, _, (*4+*: $).
 The underscore is used as a letter, but it cannot be the first letter in
 a name.
 The $
\begin_inset LatexCommand \index{\$}

\end_inset

 character is used exclusively as the first character in the name of system
 defined built-in parts.
 "$" is explained in more detail in Section 
\begin_inset LatexCommand \vref{sub:x.6.2Supported-attributes}

\end_inset

.
 Simple names should be no more than 80 characters long.
 
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Compound\InsetSpace ~
names
\begin_inset LatexCommand \index{compound names}

\end_inset

:
\bar default
 Compound names are simple names strung together with dots (.).
 See the description of "." below.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Groupings:
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
«\InsetSpace ~
»
\bar default
 In documentation 
\series bold
optional fields
\series default

\begin_inset LatexCommand \index{optional fields}

\end_inset

 are surrounded by these markers.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
(*\InsetSpace ~
*)
\family default

\begin_inset LatexCommand \index{(* *)}

\end_inset

 Comment.
 Anything inside these is a comment.
 Comments can nest
\begin_inset LatexCommand \index{nest}

\end_inset

 in ASCEND and span several lines.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
(\InsetSpace ~
)
\family default

\begin_inset LatexCommand \index{( )}

\end_inset

 Rounded parentheses
\begin_inset LatexCommand \index{parentheses}

\end_inset


\begin_inset LatexCommand \index{rounded parentheses}

\end_inset

.
 Used to enclose arguments for functions or models where the order of the
 arguments matters.
 Also used to group terms in complex arithmetic, logical, or set expressions
 where the order of operations needs to be specified.
 
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
Efficiency\InsetSpace ~
tip: The compiler can simplify relation definitions in a particularly
 efficient manner if constants are grouped together.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
{\InsetSpace ~
}
\family default

\begin_inset LatexCommand \index{{ }}

\end_inset

 Curly braces
\begin_inset LatexCommand \index{Curly braces}

\end_inset

.
 Used to enclose units.
 For example, 1 {kg_mole/s}.
 Also used to enclose the body of annotations.
 Note: Curly braces are also used in TCL, the language of the ASCEND user
 interface, about which we will say more in another chapter.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
[\InsetSpace ~
]
\family default

\begin_inset LatexCommand \index{[ ]}

\end_inset

 Square brackets
\begin_inset LatexCommand \index{square brackets}

\end_inset

.
 Used to enclose sets or elements of sets.
 Examples: my_integer_set :== [1,2,3], demonstrates the use of square brackets
 in the assignment of a set.
 My_array[1] demonstrates the use of square brackets in naming an array
 object indexed over an integer set which includes the element 1.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
.
\family default

\begin_inset LatexCommand \index{.}

\end_inset

 Dot
\begin_inset LatexCommand \index{dot}

\end_inset

.
 The dot is used, as in PASCAL and C, to construct the names of nested objects.
 Examples: if object a has a part b, then the way to refer to b is as a.b.
 Tray[1].vle shows a dot following a square bracket; here Tray[1] has a part
 named vle.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
..
\family default

\begin_inset LatexCommand \index{..}

\end_inset

 Dot-dot or double dot
\begin_inset LatexCommand \index{double dot}

\end_inset

.
 Integer range shorthand.
 For example, my_integer_set :== [1,2,3] and my_integer_set :== [1..3] are
 equivalent.
 If ..
 appears in a context requiring (), such as the ALIASES/IS_A statement,
 then the range is expanded and ordered as we would naturally expect.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
:
\family default

\begin_inset LatexCommand \index{:}

\end_inset

 Colon
\begin_inset LatexCommand \index{colon}

\end_inset

.
 A separator used in various ways, principally to set the name of an arithmetic
 relation apart from the definition.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
::
\family default

\begin_inset LatexCommand \index{::}

\end_inset

 Double colon
\begin_inset LatexCommand \index{double colon}

\end_inset

.
 A separator used in the methods section for accessing methods defined on
 types other than the type the method is part of.
 Explained in Section 
\begin_inset LatexCommand \vref{sec:x.4Procedural-statements}

\end_inset

.[
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
;
\family default

\begin_inset LatexCommand \index{;}

\end_inset

 Semicolon
\begin_inset LatexCommand \index{semicolon}

\end_inset

.
 The separator of statements.
\end_layout

\begin_deeper
\begin_layout Section
Basic Elements
\begin_inset LatexCommand \index{basic elements}

\end_inset


\begin_inset LatexCommand \label{sub:x.1.2Basic-Elements}

\end_inset


\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Boolean\InsetSpace ~
value
\bar default

\begin_inset LatexCommand \index{value, Boolean}

\end_inset


\begin_inset LatexCommand \index{Boolean value}

\end_inset

 
\family sans
TRUE
\family default

\begin_inset LatexCommand \index{TRUE}

\end_inset

 or 
\family sans
FALSE
\family default

\begin_inset LatexCommand \index{FALSE}

\end_inset

.
 Can't get much simpler, eh? In the language definition 
\family sans
TRUE
\family default
 and 
\family sans
FALSE
\family default
 do not map to 1 and 0 or any other type of numeric value.
 (In the implementation, of course, they do.)
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
User\InsetSpace ~
interface\InsetSpace ~
tip: The ASCEND user interface programmers have found it very
 convenient, however, to allow T/F, 1/0, Y/N, and other obvious boolean
 conventions as interactive input when assigning boolean values.
 We are lazy users.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Integer\InsetSpace ~
value
\bar default

\begin_inset LatexCommand \index{value, integer}

\end_inset


\begin_inset LatexCommand \index{integer value}

\end_inset

 A signed whole number up to the maximum that can be represented by the
 computer on which one is running ASCEND.
 
\family sans
MAX_INTEGER
\family default

\begin_inset LatexCommand \index{MAX\_INTEGER}

\end_inset

 is machine dependent.
 Examples are:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align block
123
\end_layout

\begin_layout LyX-Code
\align block
-5
\end_layout

\begin_layout LyX-Code
\align block
MAX_INTEGER, typically 2147483647.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Real\InsetSpace ~
value
\bar default

\begin_inset LatexCommand \index{value. real}

\end_inset


\begin_inset LatexCommand \index{real value}

\end_inset

 ASCEND represents reals almost exactly as any other mathematically oriented
 programming language does.
 The mantissa
\begin_inset LatexCommand \index{mantissa}

\end_inset

 has an optional negative sign followed by a string of digits and at most
 one decimal point.
 The exponent is the letter 
\family typewriter
e
\family default
 or 
\family typewriter
E
\family default
 followed by an integer.
 The number must not exceed the largest the computer is able to handle.
 There can be no blank characters in a real.
 
\family sans
MAX_REAL
\family default

\begin_inset LatexCommand \index{MAX\_REAL}

\end_inset

 is machine dependent.
 The following are legitimate reals in ASCEND: 
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align block
-1
\end_layout

\begin_layout LyX-Code
\align block
1.2
\end_layout

\begin_layout LyX-Code
\align block
1.3e-2 
\end_layout

\begin_layout LyX-Code
\align block
7.888888e+34
\end_layout

\begin_layout LyX-Code
\align block
.6E21
\end_layout

\begin_layout LyX-Code
\align block
MAX_REAL, typically about 1.79E+308.
\end_layout

\begin_layout Standard
while the following are not:
\end_layout

\begin_layout LyX-Code
\align block
1.
 2    (*contains a blank within it*)
\end_layout

\begin_layout LyX-Code
\align block
1.3e2.0 (*exponent has a decimal in it*)
\end_layout

\begin_layout LyX-Code

\family typewriter
+1.3    (* illegal unary + sign.
 x = +1.3 not allowed*)
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Reals\InsetSpace ~
stored\InsetSpace ~
in\InsetSpace ~
SI
\begin_inset LatexCommand \index{SI}

\end_inset

\InsetSpace ~
units
\bar default
 
\end_layout

\begin_deeper
\begin_layout Standard
We store all real values as double precision
\begin_inset LatexCommand \index{double precision}

\end_inset

 numbers in the metre-kilogram-second (MKS)
\begin_inset LatexCommand \index{MKS}

\end_inset

 system of units.
 This eliminates many common errors in the modeling of physical systems.
 Since we also place the burden of scaling equations on system routines
 and a simple modeling methodology, the internal units are not of concern
 to most users.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Dimensionality
\begin_inset LatexCommand \index{dimensionality}

\end_inset

:
\bar default
 Real values have dimensionality such as length/time for velocity.
 
\series bold
Dimensionality
\series default
 is to be distinguished from the 
\series bold
units
\series default
 such as ft/s.
 ASCEND takes care of mapping between units
\begin_inset LatexCommand \index{units}

\end_inset

 and dimensions.
 A value without units (this includes integer values) is taken to be dimensionle
ss
\begin_inset LatexCommand \index{dimensionless}

\end_inset

.
 Dimensionality is built up from the following base dimensions:
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
Name 
\bar under
definition; typical units
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
L
\begin_inset LatexCommand \index{L, length dimension}

\end_inset

 length
\begin_inset LatexCommand \index{length}

\end_inset

; metre, m
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
M
\begin_inset LatexCommand \index{M, mass dimension}

\end_inset

 mass
\begin_inset LatexCommand \index{mass}

\end_inset

; kilogram, kg
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
T
\begin_inset LatexCommand \index{T, time dimension}

\end_inset

 time
\begin_inset LatexCommand \index{time}

\end_inset

; second, s
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
E
\begin_inset LatexCommand \index{E, electric current dimension}

\end_inset

 electric current
\begin_inset LatexCommand \index{electric current}

\end_inset

; ampere, A
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
Q
\begin_inset LatexCommand \index{Q, quantity dimension}

\end_inset

 quantity
\begin_inset LatexCommand \index{quantity}

\end_inset

; mole, mole
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
TMP
\begin_inset LatexCommand \index{TMP, temperature dimension}

\end_inset

 temperature
\begin_inset LatexCommand \index{temperature}

\end_inset

; Kelvin, K
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
LUM
\begin_inset LatexCommand \index{LUM, luminous intensity dimension}

\end_inset

 luminous intensity
\begin_inset LatexCommand \index{luminous intensity}

\end_inset

; candela, cd
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
P
\begin_inset LatexCommand \index{P, phase angle dimension}

\end_inset

 plane angle
\begin_inset LatexCommand \index{plane angle}

\end_inset

; radian, rad
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
S
\begin_inset LatexCommand \index{S, solid angle dimension}

\end_inset

 solid angle
\begin_inset LatexCommand \index{solid angle}

\end_inset

; steradian, srad
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
C
\begin_inset LatexCommand \index{C, currency dimension}

\end_inset

 currency
\begin_inset LatexCommand \index{currency}

\end_inset

; currency, CR
\end_layout

\begin_deeper
\begin_layout Standard
The atom and constant definitions in the library illustrate the use of dimension
ality.
\end_layout

\begin_layout Standard
Dimensions may be any combination of these symbols along with rounded parenthese
s, (), and the operators *, 
\family typewriter
^
\family default
 and 
\family typewriter
/
\family default
.
 Examples include 
\family typewriter
M/T
\family default
 or 
\family typewriter
M*L^2/T^2/TMP
\family default
 {this latter means 
\family typewriter
(M*(L^2)/(T^2))/TMP
\family default
}.
 The second operand for the to-the-power-of operator, 
\family typewriter
^
\family default
, must be an integer value (e.g., -2 or 3) because fractional powers of dimensiona
l numbers are physically undefined 
\begin_inset Note Note
status open

\begin_layout Standard
although we do seem them occasionally...
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
If the dimensionality for a real value is undefined, then ASCEND gives it
 a wildcard dimensionality
\begin_inset LatexCommand \index{wild card dimensionality}

\end_inset

.
 If ASCEND can later deduce its dimensionality from its use in a model definitio
n it will do so.
 For example consider the real variable 
\family typewriter
a
\family default
, suppose 
\family typewriter
a
\family default
 has wildcard dimensionality, 
\family typewriter
b
\family default
 has dimensionality of 
\family typewriter
L/T
\family default
.
 Then the statement:
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Example\InsetSpace ~
of\InsetSpace ~
a\InsetSpace ~
dimensionally\InsetSpace ~
consistent
\begin_inset LatexCommand \index{dimensionally consistent}

\end_inset

\InsetSpace ~
equation.
 
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
\InsetSpace ~
 
\family typewriter
a + b = 3 {ft/s};
\end_layout

\begin_deeper
\begin_layout Standard
requires that 
\family typewriter
a
\family default
 have the same dimensionality as the other two terms, namely, 
\family typewriter
L/T
\family default
.
 ASCEND will assign this dimensionality to 
\family typewriter
a
\family default
.
 The user will be warned of dimensionally inconsistent equations.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Unit\InsetSpace ~
expression
\bar default
 A unit expression
\begin_inset LatexCommand \index{unit expression}

\end_inset

 may be composed of any combination of unit names defined by the system
 and any numerical constants combined with times (
\family typewriter
*
\family default
), divide(
\family typewriter
/
\family default
) and to the power (
\family typewriter
^
\family default
) operators.
 The RHS of 
\family typewriter
^
\family default
 must be an integer.
 Parentheses can be used to group subexpressions with the exception that
 a divide operator may 
\emph on
not
\emph default
 be followed by a grouped subexpression.
 
\end_layout

\begin_deeper
\begin_layout Standard
So, 
\family typewriter
{kg/m/s}
\family default
 is fine, but 
\family typewriter
{kg/(m*s)}
\family default
 is not.
 Although the two expressions are mathematically equivalent, it makes the
 system programming and output formatting easier to code and faster to execute
 if we disallow expressions of the latter sort.
\end_layout

\begin_layout Standard
The units understood by the system are defined in the first part of this
 manual.
 Note that several units defined are really values of interesting constants
 in SI, e.g.
 
\family typewriter
R :== 1{GAS_C}
\family default
 yields the correct value of the thermodynamic gas constant.
 Users can define additional units.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Units
\bar default

\begin_inset LatexCommand \index{units}

\end_inset

 A Unit expression unit expression must be enclosed in curly braces 
\family typewriter
{}
\family default
.
 When a real number is used in a mathematical expression in ASCEND, it must
 have a set of units expressed with it.
 If it does not, ASCEND assumes the number is dimensionless, which may not
 be the intent of the modeler.
 An example is shown in the dimensionally consistent equation above where
 the number 3 has the units 
\family typewriter
{ft/s}
\family default
 associated with it.
 
\end_layout

\begin_deeper
\begin_layout Standard
Examples:
\end_layout

\begin_layout LyX-Code
\align block
{kg_mole/s/m} same as {(kg_mole/s)/m}
\end_layout

\begin_layout LyX-Code
\align block
{m^3/yr}
\end_layout

\begin_layout LyX-Code
\align block
{3/100*ft} same as {0.03*ft}
\end_layout

\begin_layout LyX-Code
\align block
{s^-1} same as {1/s}
\end_layout

\begin_layout Standard
Illegal unit examples are
\end_layout

\begin_layout LyX-Code
\align block
{m/(K*kg_mole)}
\end_layout

\begin_deeper
\begin_layout Standard
grouped subexpression used in the denominator; should be written {m/K/kg_mole}.
\end_layout

\end_deeper
\begin_layout LyX-Code
\align block
{m^3.5}
\end_layout

\begin_deeper
\begin_layout Standard
power of units or dimensions must be integer.
\end_layout

\end_deeper
\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Symbol\InsetSpace ~
Value
\bar default

\begin_inset LatexCommand \index{value, symbol}

\end_inset


\begin_inset LatexCommand \index{symbol value}

\end_inset

 The format for a symbol is that of an arbitrary character string enclosed
 between two single quotes.
 There is no way to embed a single quote
\begin_inset LatexCommand \index{'}

\end_inset


\begin_inset LatexCommand \index{single quote}

\end_inset

 in a symbol: we are not in the escape sequence business at this time.
 The following are legal symbols in ASCEND:
\end_layout

\begin_deeper
\begin_layout LyX-Code
'H2O'
\end_layout

\begin_layout LyX-Code
'r1'
\end_layout

\begin_layout LyX-Code
'Bill said,foo to whom?'
\end_layout

\begin_layout Standard
while the following are not legal symbol values:
\end_layout

\begin_layout LyX-Code
"ethanol" (double quotes not allowed)
\end_layout

\begin_layout LyX-Code
water (no single quotes given)
\end_layout

\begin_layout LyX-Code
i cant do this (no embedded quotes)
\end_layout

\begin_layout Standard
There is an arbitrary upper limit to the number of characters in a symbol
 (something like 10,000) so that we may detect a missing close quote in
 a bad input file without crashing.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Sets\InsetSpace ~
values
\begin_inset LatexCommand \index{values, set}

\end_inset


\begin_inset LatexCommand \index{set values}

\end_inset

 Set values are lists of elements, all of type 
\family sans
integer_constant
\family default
 or all of type 
\family sans
symbol_constant
\family default
, enclosed between square brackets 
\family typewriter
[]
\family default
.
 The following are examples of sets:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align block
['methane', 'ethane', 'propane']
\end_layout

\begin_layout LyX-Code
\align block
[1..5, 7, 15]
\end_layout

\begin_layout LyX-Code
\align block
[2..n_stages]
\end_layout

\begin_layout LyX-Code
\align block
[1, 4, 2, 1, 16]
\end_layout

\begin_layout LyX-Code
\align block
[]
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
More\InsetSpace ~
about\InsetSpace ~
sets
\begin_inset LatexCommand \index{sets}

\end_inset

\InsetSpace ~
in\InsetSpace ~
Section\InsetSpace ~

\begin_inset LatexCommand \vref{sub:x.2.2Sets}

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
The value range 
\family typewriter
1..5
\family default
 is an allowable shorthand for the integers 1, 2, 3, 4 and 5 while the value
 range 
\family typewriter
2..n_stages
\family default
 (where 
\family typewriter
n_stages
\family default
 must be of type 
\family sans
integer_constant
\family default
) means all integers from 2 to 
\family typewriter
n_stages
\family default
.
 If 
\family typewriter
n_stages
\family default
 is less than 2, then the third set is empty.
 The repeated occurrence of 
\family typewriter
1
\family default
 in the fourth set is ignored.
 The fifth set is the empty set
\begin_inset LatexCommand \index{empty set}

\end_inset


\begin_inset LatexCommand \index{set, empty}

\end_inset

.
\end_layout

\begin_layout Standard
We use the term set in an almost pure mathematical sense.
 The elements have no order.
 One can only ask two things of a set: (1) if an element is a member of
 it and (2) its cardinality
\begin_inset LatexCommand \index{cardinality}

\end_inset

 (
\family sans
CARD
\family default

\begin_inset LatexCommand \index{CARD}

\end_inset


\family typewriter
(set)
\family default
).
 Repeated elements used in defining a set are ignored.
 The elements of sets cannot themselves be sets in ASCEND; i.e., there can
 be no sets of set.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Sets\InsetSpace ~
are\InsetSpace ~
unordered.
 A set of integers may appear to be ordered to the modeler as the natural
 numbers have an order.
 However, it is the user imposing and using the ordering, not ASCEND.
 ASCEND sees these integers as elements in the set with NO ordering.
 Therefore, there are no operators in ASCEND such as successor or precursor
 member of a set.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Arrays
\bar default

\begin_inset LatexCommand \index{arrays}

\end_inset

 An array is a list of instances indexed over a set, in computer-speak,
 an associative array of objects.
 The instances are all of the same base type (as that is the only way they
 can be defined).
 An individual member of a list may later be more refined than the other
 members (we shall illustrate that possibility).
 The following are arrays in ASCEND.
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align block
stage[1..n_stages]
\end_layout

\begin_layout LyX-Code
\align block
y[components]
\end_layout

\begin_layout LyX-Code
\align block
column[areas][processes]
\end_layout

\begin_layout Standard
where components, areas and processes are sets.
 For example components could be the set of symbols 
\family typewriter
['ethylene', 'propylene']
\family default
, areas the set of symbols 
\family typewriter
['feed_prep', 'prod_purification']
\family default
 while processes could be the set 
\family typewriter
['alcohol_manuf', 'poly_propropylene_manuf']
\family default
.
 Note that the third example (
\family typewriter
column
\family default
) is a list of lists (the way that ASCEND permits a multiply subscripted
 array).
 
\end_layout

\begin_layout Standard
The following are elements in the above arrays:
\end_layout

\begin_layout LyX-Code
stage[1] 
\end_layout

\begin_layout LyX-Code
y['ethylene']
\end_layout

\begin_layout LyX-Code
column['feed_prep'][alcohol_manuf']
\end_layout

\begin_layout Standard
provided that 
\family typewriter
n_stages
\family default
 is 1 or larger.
 
\end_layout

\begin_layout Standard
There can be any number of subscripts
\begin_inset LatexCommand \index{subscripts}

\end_inset

 for an array.
 We point out, however, that in virtually every application of arrays requiring
 more than two subscripts, there is usually a some underlying concept that
 is much better modeled as an object than as part of a deeply subscripted
\begin_inset LatexCommand \index{subscripted, deeply}

\end_inset


\begin_inset LatexCommand \index{deeply subscripted}

\end_inset

 array.
 In the following jagged array example, there are really the concepts of
 unit operation and stream that would be better understood if made explicit.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Arrays\InsetSpace ~
can\InsetSpace ~
be\InsetSpace ~
jagged
\bar default

\begin_inset LatexCommand \label{lyx:Arrays-can-be}

\end_inset

 Arrays can be sparse
\begin_inset LatexCommand \index{sparse}

\end_inset

 or jagged
\begin_inset LatexCommand \index{jagged}

\end_inset

.
 For example:
\end_layout

\begin_deeper
\begin_layout LyX-Code
process[1..3] IS_A set OF integer;
\end_layout

\begin_layout LyX-Code
process[1] :== [2];
\end_layout

\begin_layout LyX-Code
process[2] :== [7,5,3];
\end_layout

\begin_layout LyX-Code
process[3] :== [4,6];
\end_layout

\begin_layout LyX-Code
FOR i in [1..3] CREATE
\end_layout

\begin_layout LyX-Code
   FOR j IN process[i] CREATE
\end_layout

\begin_layout LyX-Code
      flow[i][j] IS_A mass;
\end_layout

\begin_layout LyX-Code
   END FOR;
\end_layout

\begin_layout LyX-Code
END FOR;
\end_layout

\begin_layout Standard
process is an array of sets (not to be confused with a set of sets which
 ASCEND does not have) and flow is an array with six elements spread over
 three rows:
\end_layout

\begin_layout LyX-Code
flow[1][2]
\end_layout

\begin_layout LyX-Code
flow[2][7], flow[2][3], flow[2][5]
\end_layout

\begin_layout LyX-Code
flow[3][4], flow[3][6]
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Arrays\InsetSpace ~
are\InsetSpace ~
also\InsetSpace ~
instances 
\end_layout

\begin_deeper
\begin_layout Standard
Each array is itself an object.
 That is, when you write 
\family typewriter
a[1..2] IS_A real
\family default
, three objects get created: 
\family typewriter
a[1]
\family default
, 
\family typewriter
a[2]
\family default
, and 
\family typewriter
a
\family default
.
 The object 
\family typewriter
a
\family default
 is an array instance which has parts named 
\family typewriter
[1]
\family default
 and 
\family typewriter
[2]
\family default
 that are real instances.
 When a parameterized model requires an array, you pass it the single item
 
\family typewriter
a
\family default
, not the elements 
\family typewriter
a[1..2]
\family default
.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
No\InsetSpace ~
contiguous\InsetSpace ~
storage
\begin_inset LatexCommand \index{contiguous storage, no}

\end_inset

 
\end_layout

\begin_deeper
\begin_layout Standard
Just in case you still have not caught on, ASCEND arrays are not blocks
 of memory such as are seen in low-level languages like C
\begin_inset LatexCommand \index{C, computer language}

\end_inset

, FORTRAN
\begin_inset LatexCommand \index{FORTRAN}

\end_inset

, and Matlab
\begin_inset LatexCommand \index{Matlab}

\end_inset

.
 The modeling language does not provide things like MatMult
\begin_inset LatexCommand \index{MatMult}

\end_inset

, Transpose
\begin_inset LatexCommand \index{Transpose}

\end_inset

, and Inverse
\begin_inset LatexCommand \index{Inverse}

\end_inset

 because these are procedural solving tools.
 If you are dedicated, you could write METHODs that implement matrix algebra,
 but this is a really dumb idea.
 We aim to structure our software so that it can interact openly with separate,
 dedicated tools (such as Matlab) when those tools are needed.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Index\InsetSpace ~
variable
\begin_inset LatexCommand \index{index variable}

\end_inset

 One can introduce a variable as an index ranging over a set.
 Index variables are local to the statements in which they occur.
 An example of using an index variable is the following FOR statement:
\end_layout

\begin_deeper
\begin_layout LyX-Code
FOR i IN components CREATE
\end_layout

\begin_layout LyX-Code
   VLE_equil[i]: y[i] = K[i]*x[i];
\end_layout

\begin_layout LyX-Code
END FOR;
\end_layout

\begin_layout Standard
In this example i implicitly is of the same type as the values in the set
 components.
 If another object i exists in the model containing the FOR loop, it is
 ignored while executing the statements in that loop.
 This may cause unexpected results and the compiler will generate warnings
 about loop index shadowed variables.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Label
\begin_inset LatexCommand \index{label}

\end_inset

: One can label statements which define arithmetic relationships (objective
 functions, equalities, and inequalities) in ASCEND.
 Labeling is highly recommended because it makes models much more readable
 and more easily debugged.
 Labels are also necessary for relations which are going to be used in condition
al modeling or differentiation functions.
 A label is a sequence of alphanumeric characters ending in a colon.
 An example of a labeled equation is:
\end_layout

\begin_deeper
\begin_layout LyX-Code
mass_balance: m_in = m_out;
\end_layout

\begin_layout Standard
An example of a labeled objective function is:
\end_layout

\begin_layout LyX-Code
obj1: MAXIMIZE revenue - cost;
\end_layout

\begin_layout Standard
If a relation is defined within a FOR statement, it must have an array indexed
 label so that each instance created using the statement is distinguishable
 from the others.
 An example is:
\end_layout

\begin_layout LyX-Code
FOR i IN components CREATE
\end_layout

\begin_layout LyX-Code
   equil[i]: y[i] = K[i]*x[i];
\end_layout

\begin_layout LyX-Code
END FOR;
\end_layout

\begin_layout Standard
The ASCEND interactive user interface identifies relationships by their
 labels.
 If one has not provided such a label, the system generates the label:
\end_layout

\begin_layout LyX-Code

\emph on
modelname_equationnumber
\end_layout

\begin_layout Standard
where modelname and equationnumber are the name of the model and the equation
 number in the model.
 An example is
\end_layout

\begin_layout LyX-Code
mixture_14
\end_layout

\begin_layout Standard
for the unlabeled 14th relation in the mixture definition.
 If there is a conflict caused with an existing name, the generated name
 has enough letters added after equationnumber to make it a unique name.
 Remember that each model in a refinement hierarchy inherits the equations
 of its less refined ancestors, so the first equation appearing in the source
 code of a refining model may actually be the nth relation in that model.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Lists
\bar default

\begin_inset LatexCommand \index{lists}

\end_inset

 Often in a statement one can include a list of names or expression.
 A name list is one or more names where multiple list entries are separated
 from each other by commas.
 Examples of a list of names are:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align block
T1, inlet_T, outlet_T
\end_layout

\begin_layout LyX-Code
\align block
y[components], y_in
\end_layout

\begin_layout LyX-Code
\align block
stage[1..n_stages]
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Ordered\InsetSpace ~
lists
\begin_inset LatexCommand \index{lists, ordered}

\end_inset


\begin_inset LatexCommand \index{ordered lists}

\end_inset

:
\bar default
 If the ordering of names in a list matters, that list is enclosed in ().
 Order matters in: calling externally defined methods or models, calling
 most real-valued functions, passing parameters to ASCEND models or methods,
 and declaring the controlling parameters that SELECT, SWITCH, and WHEN
 statements make decisions on.
\end_layout

\begin_deeper
\begin_layout Section
Basic Concepts
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Instances
\begin_inset LatexCommand \index{instances}

\end_inset

\InsetSpace ~
and\InsetSpace ~
types
\bar default

\begin_inset LatexCommand \index{types}

\end_inset

 This is an opportune time to emphasize the distinction between the terms
 instance and type.
 A type in ASCEND is what we define when we declare an ASCEND model or atom.
 It is the formal definition of the attributes (parts) and attribute default
 values that an object will have if it is created using the type definition.
 Methods are associated with types.
\end_layout

\begin_deeper
\begin_layout Standard
In ASCEND there are two meanings (closely related) of an instance.
 
\end_layout

\begin_layout Itemize
An instance is a named part that exists within a type definition.
 
\end_layout

\begin_layout Itemize
An instance is a compiled object.
 
\end_layout

\begin_layout Standard
If one is in the context of the ASCEND interface, the system compiles an
 instance of a model type to create an object with which one carries out
 computations.
 The system requires the user to give a simple name for this simulation
 instance.
 This name given is then the first part of the qualified name for all the
 parts of the compiled object.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Implicit\InsetSpace ~
types
\bar default

\begin_inset LatexCommand \index{types, implicit}

\end_inset


\begin_inset LatexCommand \index{types, implicit}

\end_inset

 It is possible to create an instance that does not have a corresponding
 type definition in the library.
 The type of such an instance is said to be 
\series bold
implicit
\series default

\begin_inset Foot
status collapsed

\begin_layout Standard
 (Some people use the word 
\emph on
anonymous
\emph default

\begin_inset LatexCommand \index{type, anonymous}

\end_inset


\begin_inset LatexCommand \index{anonymous type}

\end_inset

.
 However, no computable type is anonymous and the implicit type of an instance
 is theoretically computable)
\end_layout

\end_inset

.
 The simplest example of an implicit type is the type of an instance compiled
 from the built-in definition 
\family sans
integer_constant
\family default
.
 For example:
\end_layout

\begin_deeper
\begin_layout LyX-Code
i, j IS_A integer_constant;
\end_layout

\begin_layout LyX-Code
i:== 2;
\end_layout

\begin_layout LyX-Code
j:== 3;
\end_layout

\begin_layout Standard
Instances 
\family typewriter
i
\family default
 and 
\family typewriter
j
\family default
, though of the same formal type, are implicit type incompatible because
 they have been assigned distinct values.
\end_layout

\begin_layout Standard
Instances which are either formally or implicitly type incompatible cannot
 be merged.
 This will be discussed further in Section 
\begin_inset LatexCommand \vref{sec:x.3Declarative-statements}

\end_inset

.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Parsing
\begin_inset LatexCommand \index{parsing}

\end_inset

 Most errors in the declaration of an ASCEND model can be caught at parse
 time because the object type of any well-formed name in an ASCEND definition
 can be resolved or proved ambiguous.
 We cannot prove at parse time whether a specific array element will exist,
 but we can know that should such an element exist, it must be of the type
 with which the array is defined.
 
\end_layout

\begin_deeper
\begin_layout Standard
Ambiguity is warned about loudly because it is caused by either misspelling
 or poor modeling style.
 The simplest example of ambiguity follows.
\end_layout

\begin_layout Standard
Assume a type, stream, and a refinement of stream, heat_stream, which adds
 the new variable 
\family typewriter
H
\family default
.
 Now, if we write:
\end_layout

\begin_layout LyX-Code
MODEL mixer;
\end_layout

\begin_layout LyX-Code
input[1..2] IS_A stream;
\end_layout

\begin_layout LyX-Code
output IS_A heat_stream;
\end_layout

\begin_layout LyX-Code
input[1].H + input[2].H = output.H;
\end_layout

\begin_layout LyX-Code
END mixer;
\end_layout

\begin_layout Standard
We see the parser can find the definition of H in the type heat_stream,
 so 
\family typewriter
output.H
\family default
 is well defined.
 The author of the mixer model may intend to refine 
\family typewriter
input[1]
\family default
 and 
\family typewriter
input[2]
\family default
 to be objects of different types, say steam_stream and electric_stream,
 where each defines an 
\family typewriter
H
\family default
 suitable for use in the equation.
 The parser cannot read the authors mind, so it warns that 
\family typewriter
input[1].H
\family default
 and 
\family typewriter
input[2].H
\family default
 are ambiguous in the mixer definition.
 The mixer model is not highly reusable except by the author, but sometimes
 reusability is not a high priority objective.
 The mixer definition is allowed, but it may cause problems in instantiation
 if the author has forgotten the assumption that is not explicitly stated
 in the model and neglects to refine the input streams appropriately.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Instantiation
\bar default

\begin_inset LatexCommand \index{instantiation}

\end_inset

 Creating an simulation based on a type definition is a multi-phase
\begin_inset LatexCommand \index{multi-phase}

\end_inset

 process called compiling
\begin_inset LatexCommand \index{compiling}

\end_inset

 (or instantiation).
 When an instantiation cannot be completed because some structural parameter
 (a symbol_constant, real_constant, boolean_constant, integer_constant,
 or set) does not have a value there will be PENDING
\begin_inset LatexCommand \index{PENDING}

\end_inset

 statements.
 The user interface will warn that something is incomplete.
\end_layout

\begin_deeper
\begin_layout Standard
In phase
\begin_inset LatexCommand \index{phases, compiler}

\end_inset

 1 all statements that create instance structures or assign constant values
 are executed.
 This phase theoretically requires an infinite number of passes through
 the structural statements of a definition.
 We allow a maximum of 5 and have never needed more than 3.
 There may be pending statements at the end of phase 1.
 The compiler or interface will issue warnings about pending statements,
 starting with warnings about unassigned constants.
\end_layout

\begin_layout Standard
Phase 2 compiles as many real arithmetic relation definitions as possible.
 Some relations may be impossible to compile because the constants or sets
 they depend on do not have values assigned.
 Other relations may be impossible because they reference variables that
 do not exist.
 This is determined in a single pass.
\end_layout

\begin_layout Standard
Phase 3 compiles as many logical arithmetic relation definitions as possible.
 Some relations may be impossible to compile because the constants or sets
 they depend on do not have values assigned.
 Other relations may be impossible because they reference real arithmetic
 relations that do not exist.
 This is determined in a single pass.
\end_layout

\begin_layout Standard
Phase 4 compiles as many conditional programming statements (
\family sans
WHEN
\family default
s) as possible.
 Some 
\family sans
WHEN
\family default
 relations may be impossible to compile because the discrete variables,
 models, or relations they depend on do not exist.
 This is determined in a single pass.
\end_layout

\begin_layout Standard
Phase 5 executes the variable defaulting statements made in the declarative
 section of each model 
\emph on
if and only if
\emph default
 there are no pending statements from phases 1-4 anywhere in the simulation.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
default_self
\begin_inset LatexCommand \index{default\_self}

\end_inset

 After all phases are done, the method default_self is called in the top-most
 model of the simulation, if this method exists.
\end_layout

\begin_deeper
\begin_layout Standard
The first occurrence of each impossible statement will be explained during
 a failed compilation.
 Impossible statements include:
\end_layout

\begin_layout Itemize
Relations containing undefinable variables (often misspellings).
\end_layout

\begin_layout Itemize
Assignments that are dimensionally inconsistent or containing mismatched
 types.
\end_layout

\begin_layout Itemize
Structure building or modifying statements that refer to model parts which
 cannot exist or that require a type-incompatible argument, refinement,
 or merge.
\end_layout

\begin_layout Chapter
Data Type Declarations
\begin_inset LatexCommand \index{data type declarations}

\end_inset


\end_layout

\begin_layout Standard
In the spectrum of OO languages, ASCEND is best considered as being class-based
\begin_inset LatexCommand \index{class-based}

\end_inset

, though it is rather more a hybrid.
 We have atom and model definitions, called 
\series bold
types
\series default
, and the compiled objects themselves, called 
\series bold
instances
\series default
.
 ASCEND instances have a record of what type they were constructed from.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Type\InsetSpace ~
qualifiers
\begin_inset LatexCommand \index{type qualifiers}

\end_inset

:
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
UNIVERSAL
\family default

\begin_inset LatexCommand \index{UNIVERSAL}

\end_inset

 Universal is an optional modifier of all 
\family sans
ATOM
\family default
, 
\family sans
CONSTANT
\family default
 and 
\family sans
MODEL
\family default
 definitions.
 If 
\family sans
UNIVERSAL
\family default
 precedes the definition, then 
\emph on
all
\emph default
 instances of that type will actually refer to the first instance of the
 type that is created.
 This saves memory and ensures global consistency of data.
 
\end_layout

\begin_deeper
\begin_layout Standard
Examples of universal type definitions are
\end_layout

\begin_layout LyX-Code
UNIVERSAL MODEL methane
\end_layout

\begin_layout LyX-Code
   REFINES generic_component_model;
\end_layout

\begin_layout LyX-Code
UNIVERSAL CONSTANT circle_constant
\end_layout

\begin_layout LyX-Code
   REFINES real_constant :== 1{PI};
\end_layout

\begin_layout LyX-Code
UNIVERSAL ATOM counter_1
\end_layout

\begin_layout LyX-Code
   REFINES integer;
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Tip:\InsetSpace ~
Do\InsetSpace ~
not\InsetSpace ~
use\InsetSpace ~

\family sans
UNIVERSAL
\family default
\InsetSpace ~
variables\InsetSpace ~
in\InsetSpace ~
relations.
\end_layout

\begin_deeper
\begin_layout Standard
It is important to note that, because 
\emph on
variables
\emph default
 must store information about which relations they occur in, it is a very
 bad idea to use 
\family sans
UNIVERSAL
\family default
 typed variables in relations.
 The construction and maintenance of the relation list becomes very expensive
 for universal variables.
 
\family sans
UNIVERSAL
\family default
 
\emph on
constants
\emph default
 are fine to use, though, because there are no relation links for constants.
\end_layout

\begin_layout Section
Models
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
MODEL
\family default

\begin_inset LatexCommand \index{MODEL}

\end_inset

 An ASCEND model has a declarative part and an optional procedural part
 headed by the METHODS word.
 Models are essentially containers for variables and relations.
 We will explain the various statements that can be made within models in
 Section 
\begin_inset LatexCommand \vref{sec:x.3Declarative-statements}

\end_inset

 and Section 
\begin_inset LatexCommand \vref{sec:x.4Procedural-statements}

\end_inset

.
\end_layout

\begin_layout Standard
Simple\InsetSpace ~
models
\begin_inset LatexCommand \index{models, simple}

\end_inset

:
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
foo 
\family typewriter
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
MODEL foo;
\end_layout

\begin_deeper
\begin_layout LyX-Code
(* statements about foo go here*)
\end_layout

\begin_layout LyX-Code
METHODS
\end_layout

\begin_layout LyX-Code
(* METHODs for foo go here*)
\end_layout

\begin_layout LyX-Code
END foo;
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
bar 
\family typewriter
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
MODEL bar REFINES foo;
\end_layout

\begin_deeper
\begin_layout LyX-Code
(*additional statements about foo *)
\end_layout

\begin_layout LyX-Code
METHODS
\end_layout

\begin_layout LyX-Code
(* additional METHODs for bar *)
\end_layout

\begin_layout LyX-Code
END bar;
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Parameterized\InsetSpace ~
Models
\bar default

\begin_inset LatexCommand \index{models, parameterized}

\end_inset

 Parameterizing models makes them easier to understand and faster for the
 system to compile.
 The syntax for a parameterized model vaguely resembles a function call
 in imperative languages, but it is NOT.
 When constructing a reusable model, all the constants that determine the
 sizes of arrays and other structures should be declared in the parameter
 list so that 
\end_layout

\begin_deeper
\begin_layout Itemize
the user knows what is required to reuse the model.
\end_layout

\begin_layout Itemize
the compiler knows what values must be set before it should bother attempting
 to compile the model.
\end_layout

\begin_layout Standard
There is no reason that other items could not also go in the parameter list,
 such as key variables which might be considered inputs or outputs or control
 parameters in the mathematical application of the model.
 A simple example of parameterization would be:
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
column(n,s) 
\end_layout

\begin_deeper
\begin_layout LyX-Code
MODEL column(
\end_layout

\begin_layout LyX-Code
   ntrays WILL_BE integer_constant; 
\end_layout

\begin_layout LyX-Code
   components IS_A set of symbol_constant;
\end_layout

\begin_layout LyX-Code
);
\end_layout

\begin_layout LyX-Code
stage[1..ntrays] IS_A simple_tray;
\end_layout

\begin_layout LyX-Code
END column;
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
flowsheet
\end_layout

\begin_deeper
\begin_layout LyX-Code
MODEL flowsheet;
\end_layout

\begin_layout LyX-Code
   tower4size IS_A integer_constant;
\end_layout

\begin_layout LyX-Code
   tower4size :== 22;
\end_layout

\begin_layout LyX-Code
   ct IS_A column(tower4size,[c5,c6]);
\end_layout

\begin_layout LyX-Code
   (* additional flowsheet statements *)
\end_layout

\begin_layout LyX-Code
END flowsheet;
\end_layout

\begin_layout Standard
In this example, the column model takes the first argument, ntrays, by reference.
 That is,
\family typewriter
 ct.ntrays
\family default
 is an alias for the flowsheet instance 
\family typewriter
tower4size
\family default
.
 
\family typewriter
tower4size
\family default
 must be compiled and assigned a value before we will attempt to compile
 the column model instance 
\family typewriter
ct
\family default
.
 The second argument is taken by value, 
\family typewriter
[c5,c6]
\family default
, and assigned to components, a column part that was declared with 
\family sans
IS_A
\family default
 in the parameter list.
 There is only one name for this set, 
\family typewriter
ct.components
\family default
.
 Note that in the 
\family typewriter
flowsheet
\family default
 model there is no part that is a set of 
\family sans
symbol_constant
\family default
.
 
\end_layout

\begin_layout Standard
The use of parameters in ASCEND modeling requires some thought, and we will
 present that set of thoughts in Section 
\begin_inset LatexCommand \vref{sec:x.5Parameterized-models}

\end_inset

.
 Beginners may wish to create new models without parameters until they are
 comfortable using the existing parameterized library definitions.
 Parameters are intended to support model reuse and efficient compilation
 which are not issues in the very earliest phase of developing novel models.
\end_layout

\begin_layout Section
Sets
\begin_inset LatexCommand \index{sets}

\end_inset


\begin_inset LatexCommand \label{sub:x.2.2Sets}

\end_inset


\end_layout

\begin_layout Standard
Arrays in ASCEND, as already discussed in Section 
\begin_inset LatexCommand \vref{sub:x.1.2Basic-Elements}

\end_inset

, are defined over sets.
 A set is simply an instance with a set value.
 The elements of sets are 
\emph on
not
\emph default
 instances or sets.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Set\InsetSpace ~
Declaration:
\bar default
 A set is made of either symbol_constants or integer_constants, so a set
 object is declared in one of two ways:
\end_layout

\begin_deeper
\begin_layout LyX-Code
my_integer_set IS_A set OF integer_constant;
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code
my_symbol_set IS_A set OF symbol_constant;
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
:==
\family default

\begin_inset LatexCommand \index{:==}

\end_inset

 A set is assigned a value like so:
\end_layout

\begin_deeper
\begin_layout LyX-Code
my_integer_set :== [1,4];
\end_layout

\begin_layout Standard
The RHS of such an assignment must be either the name of another set instance
 or an expression enclosed in square brackets and made up of only set operators,
 other sets, and the names of integer_constants or symbol_constants.
 Sets can only be assigned once.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Set\InsetSpace ~
Operations
\bar default
 
\family sans
UNION
\family default

\begin_inset LatexCommand \index{UNION}

\end_inset


\family typewriter
[setlist]
\end_layout

\begin_deeper
\begin_layout Standard
A function taken over a list of sets.
 The result is the set that includes all the members of all the sets in
 the list.
 Note that the result of the 
\family sans
UNION
\family default
 operation is an unordered set and the argument order to the union function
 does not matter.
 The syntax is:
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
+
\begin_inset LatexCommand \index{+, sets}

\end_inset

 
\family typewriter
UNION[list_of_sets]
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
A+B
\family default
\InsetSpace ~
is\InsetSpace ~
shorthand\InsetSpace ~
for 
\family typewriter
UNION[A,B]
\end_layout

\begin_deeper
\begin_layout Standard
Consider the following sets for the examples to follow.
\end_layout

\begin_layout LyX-Code
A := [1, 2, 3, 5, 9];
\end_layout

\begin_layout LyX-Code
B := [2, 4, 6, 8];
\end_layout

\begin_layout Standard
Then 
\family typewriter
UNION[A, B]
\family default
 is equal to the set 
\family typewriter
[1, 2, 3, 4, 5, 6, 8, 9]
\family default
 which equals 
\family typewriter
[1..6, 8, 9]
\family default
 which equals 
\family typewriter
[[1..9] - [7]]
\family default
.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
INTERSECTION
\family default

\begin_inset LatexCommand \index{INTERSECTION}

\end_inset

[] INTERSECTION[list of set expressions].
 Finds the intersection (and) of the sets listed.
 
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
*
\begin_inset LatexCommand \index{*, sets}

\end_inset

 Equivalent to 
\family sans
INTERSECTION
\family typewriter
[list_of_sets]
\family default
.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
A*B
\family default
\InsetSpace ~
is\InsetSpace ~
shorthand\InsetSpace ~
for\InsetSpace ~
I
\family typewriter
NTERSECTION[A,B]
\end_layout

\begin_deeper
\begin_layout Standard
For the sets A and B defined just above, 
\family typewriter
INTERSECTION[A, B]
\family default
 is the set 
\family typewriter
[2]
\family default
.
 The 
\family typewriter
*
\family default
 shorthand for intersection is 
\emph on
not
\emph default
 recommended for use except in libraries no one will look at.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Set\InsetSpace ~
difference
\begin_inset LatexCommand \index{set difference}

\end_inset

: One can subtract one set from another.
 The result is the first set less any members in the set union of the first
 and second set.
 The syntax is
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
first_set 
\family default
-
\begin_inset LatexCommand \index{-, sets}

\end_inset


\family typewriter
 second_set
\end_layout

\begin_layout Standard
For the sets 
\family typewriter
A
\family default
 and 
\family typewriter
B
\family default
 defined above, the set difference 
\family typewriter
A - B
\family default
 is the set 
\family typewriter
[1, 3, 5, 9]
\family default
 while the set difference 
\family typewriter
B - A
\family default
 is the set 
\family typewriter
[4, 6, 8]
\family default
.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
CARD
\family default

\begin_inset LatexCommand \index{CARD}

\end_inset

[set] Cardinality
\begin_inset LatexCommand \index{cardinality}

\end_inset

.
 Returns an integer constant value that is the number of items in the set.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
CHOICE
\family default

\begin_inset LatexCommand \index{CHOICE}

\end_inset

[set] Choose one.
 The result of running the 
\family sans
CHOICE
\family default
 function over a set is an arbitrary (but consistent: for any set instance
 you always get the same result) single element of that set.
 
\end_layout

\begin_deeper
\begin_layout Standard
Running 
\family typewriter
CHOICE[A]
\family default
 gives any member from the set A.
 The result is a member, not a set.
 To make the result into a set, it must be enclosed in square brackets.
 Thus 
\family typewriter
[CHOICE[A]]
\family default
 is a set with a single element arbitrarily chosen from the set A.
 Good modelers do not leave modeling decisions to the compiler; they do
 not use 
\family sans
CHOICE
\family default
.
 We are stuck with it for historical reasons.
\end_layout

\begin_layout Standard
To reduce a set by one element, one can use the following
\end_layout

\begin_layout LyX-Code
A_less_one IS_A set OF integer;
\end_layout

\begin_layout LyX-Code
A_less_one :== A - [CHOICE[A]];
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
IN
\family default

\begin_inset LatexCommand \index{IN}

\end_inset

 
\family typewriter
lhs IN rhs
\family default
 can only be well explained by examples.
 
\family sans
IN
\family default
 is used in index expressions.
 If 
\family typewriter
lhs
\family default
 is a simple and not previously defined name, it is created as a temporary
 loop index which will take on the values of the rhs set definition.
 If lhs is something that already exists, the result of 
\family typewriter
lhs IN rhs
\family default
 is a boolean value; stare at the model 
\family typewriter
set_example
\family default
 below which demonstrates both 
\family sans
IN
\family default
 and 
\family sans
SUCH_THAT
\family default
.
 If you still are not satisfied, you might examine [[westerbergksets]]
\begin_inset Note Note
status open

\begin_layout Standard
fix this reference
\end_layout

\end_inset

.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
SUCH_THAT
\family default

\begin_inset LatexCommand \index{SUCH\_THAT}

\end_inset

 Set expressions can be rather clever.
 We will give a detailed example from chemistry because unordered sets are
 unfamiliar to most people and set arithmetic is quite powerful.
 In this example we see arrays of sets and sparse arrays.
 
\end_layout

\begin_layout LyX-Code
MODEL set_example;
\end_layout

\begin_layout LyX-Code
  (* we define a sparse matrix of reaction
\end_layout

\begin_layout LyX-Code
     coefficient information and the species
\end_layout

\begin_layout LyX-Code
     balance equations.
 *) 
\end_layout

\begin_layout LyX-Code
  rxns IS_A set OF integer_constant;
\end_layout

\begin_layout LyX-Code
  rxns :== [1..3];
\end_layout

\begin_layout LyX-Code
  species IS_A set OF symbol_constant;
\end_layout

\begin_layout LyX-Code
  species :== ['A','B','C','D'];
\end_layout

\begin_layout LyX-Code
  reactants[rxns] IS_A set OF symbol_constant; (* species
\end_layout

\begin_layout LyX-Code
     in each rxn_j *)
\end_layout

\begin_layout LyX-Code
  reactants[1] :== ['A','B','C'];
\end_layout

\begin_layout LyX-Code
  reactants[2] :== ['A','C'];
\end_layout

\begin_layout LyX-Code
  reactants[3] :== ['A','B','D'];
\end_layout

\begin_layout LyX-Code
  reactions[species] IS_A set OF integer_constant; 
\end_layout

\begin_layout LyX-Code
  FOR i IN species CREATE (* rxns for each species i *)
\end_layout

\begin_layout LyX-Code
    reactions[i] :== [j IN rxns SUCH_THAT i IN reactants[j]];
\end_layout

\begin_layout LyX-Code
  END FOR;
\end_layout

\begin_layout LyX-Code
  (* Define sparse stoichiometric matrix.
 Values of eta_ij
\end_layout

\begin_layout LyX-Code
     set later.*)
\end_layout

\begin_layout LyX-Code
  FOR j IN rxns CREATE
\end_layout

\begin_layout LyX-Code
    FOR i IN reactants[j] CREATE
\end_layout

\begin_layout LyX-Code
      (* eta_ij --> mole i/mole rxn j*)
\end_layout

\begin_layout LyX-Code
      eta[i][j] IS_A real_constant; 
\end_layout

\begin_layout LyX-Code
    END FOR;
\end_layout

\begin_layout LyX-Code
  END FOR;
\end_layout

\begin_layout LyX-Code
  production[species] IS_A molar_rate;
\end_layout

\begin_layout LyX-Code
  rate[rxns] IS_A molar_rate; (* mole rxn j/time *)
\end_layout

\begin_layout LyX-Code
  FOR i IN species CREATE
\end_layout

\begin_layout LyX-Code
    gen_eqn[i]: production[i] = 
\end_layout

\begin_layout LyX-Code
    SUM[eta[i][j]*rate[j] | j IN reactions[i]];
\end_layout

\begin_layout LyX-Code
  END FOR;
\end_layout

\begin_layout LyX-Code
END set_example;
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
"
\family typewriter
|
\family default

\begin_inset LatexCommand \index{|}

\end_inset

" is shorthand for 
\family sans
SUCH_THAT
\family default
.
\end_layout

\begin_deeper
\begin_layout Standard
The array 
\family typewriter
eta
\family default
 has only 8 elements, and we defined those elements in a set for each reaction.
 The equation needs to know about the set of reactions for a species 
\family typewriter
i
\family default
, and that set is calculated automatically in the models first 
\family sans
FOR/CREATE
\family default
 statement.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
|
\family default
 symbol is the ASCEND III notation for 
\family sans
SUCH_THAT
\family default
.
 We noted that "
\family typewriter
|
\family default
" is often read as "for all", which is different in that "for all" makes
 one think of a 
\family sans
FOR
\family default
 loop where the loop index is on the left of an 
\family sans
IN
\family default
 operator.
 For example, the 
\family typewriter
j
\family default
 loop in the 
\family sans
SUM
\family default
 of 
\family typewriter
gen_eqn[i]
\family default
 above.
 
\end_layout

\begin_layout Section
Constants
\begin_inset LatexCommand \index{constants}

\end_inset


\end_layout

\begin_layout Standard
ASCEND supports real, integer, boolean and character string constants.
 Constants in ASCEND do not have any attributes other than their value.
 Constants are scalar quantities that can be assigned exactly once.
 Constants may only be assigned using the 
\family typewriter
:==
\family default
 operator and the RHS expression they are assigned from must itself be constant.
 Constants do not have subparts.
 Integer and symbol constants may be used in determining the definitions
 of sets.
 
\end_layout

\begin_layout Standard
Explicit refinements of the built-in constant types may be defined as exemplifie
d in the description of real_constant.
 Implicit type refinements may be done by instantiating an incompletely
 defined constant and assigning its final value.
 
\end_layout

\begin_layout Standard
Sets could be considered constant because they are assigned only once, however
 sets are described separately because they are not quite scalar quantities.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
real_constant
\family default

\begin_inset LatexCommand \index{real\_constant}

\end_inset

 Real number with dimensionality.
 Note that the dimensionality of a real constant can be specified via the
 type definition without immediately defining the value, as in the following
 pair of definitions.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
CONSTANT\InsetSpace ~
declaration\InsetSpace ~
example:
\end_layout

\begin_deeper
\begin_layout LyX-Code
CONSTANT molar_weight
\end_layout

\begin_layout LyX-Code
   REFINES real_constant DIMENSION M/Q;
\end_layout

\begin_layout LyX-Code
CONSTANT hydrogen_weight
\end_layout

\begin_layout LyX-Code
   REFINES molar_weight :== 1.004{g/mole};
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
integer_constant
\family default

\begin_inset LatexCommand \index{integer\_constant}

\end_inset

 Integer number.
 Principally used in determining model structure.
 If appearing in equations, integers are evaluated as dimensionless reals.
 Typical use is inside a 
\family sans
MODEL
\family default
 definition and looks like:
\end_layout

\begin_deeper
\begin_layout LyX-Code
n_trays IS_A integer_constant;
\end_layout

\begin_layout LyX-Code
n_trays :== 50;
\end_layout

\begin_layout LyX-Code
tray[1..n_trays] IS_A vl_equilibrium_tray;
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
symbol_constant
\family default

\begin_inset LatexCommand \index{symbol\_constant}

\end_inset

 Object with a symbol value.
 May be used in determining model structure.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
boolean_constant
\family default

\begin_inset LatexCommand \index{boolean\_constant}

\end_inset

 Logical value.
 May be used in determining model structure.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Setting\InsetSpace ~
constants
\bar default

\begin_inset LatexCommand \index{constants, setting}

\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
:==
\begin_inset LatexCommand \index{:==}

\end_inset

 Constant and set assignment operator.
 
\end_layout

\begin_deeper
\begin_layout Standard
It is suggested, but not required, that names of all types that refine the
 built-in constant types have names that end in _constant.
\end_layout

\begin_layout LyX-Code
LHS_list :== RHS; 
\end_layout

\begin_layout Standard
Here it is required that the one or more items in the LHS be of the same
 constant type and that RHS is a single-valued expression made up of values,
 operators, and other constants.
 The 
\family typewriter
:==
\family default
 is used to make clear to both the user and the system what scalar objects
 are constants.
 
\end_layout

\begin_layout Section
Variables
\begin_inset LatexCommand \index{variables}

\end_inset


\end_layout

\begin_layout Standard
There are four built-in types which may be used to construct variables:
 symbol, boolean, integer, and real.
 At this time symbol types have special restrictions.
 Refinements of these variable base types are defined with the 
\family sans
ATOM
\family default
 statement.
 Atom types may declare attribute fields with types real, integer, boolean,
 symbol, and set.
 These attributes are 
\emph on
not
\emph default
 independent objects and therefore cannot be refined, merged, or put in
 a refinement clique (
\family sans
ARE_ALIKE
\family default
d).
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
ATOM
\family default

\begin_inset LatexCommand \index{ATOM}

\end_inset

 The syntax for declaring a new atom type is
\end_layout

\begin_deeper
\begin_layout LyX-Code
ATOM 
\emph on
atom_type_name
\emph default
 REFINES 
\emph on
variable_type
\end_layout

\begin_layout LyX-Code
   «DIMENSION 
\emph on
dimension_expression
\emph default
»
\end_layout

\begin_layout LyX-Code
   «DEFAULT 
\emph on
value
\emph default
»; (* note the ; *)
\end_layout

\begin_layout LyX-Code
   «
\emph on
initial attribute assignment
\emph default
;»
\end_layout

\begin_layout LyX-Code
END 
\emph on
atom_type_name
\emph default
;
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
DEFAULT
\family default

\begin_inset LatexCommand \index{DEFAULT}

\end_inset

,
\family sans
\InsetSpace ~
DIMENSION
\family default

\begin_inset LatexCommand \index{DIMENSION}

\end_inset

,\InsetSpace ~
and\InsetSpace ~

\family sans
DIMENSIONLESS
\family default

\begin_inset LatexCommand \index{DIMENSIONLESS}

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The 
\family sans
DIMENSION
\family default
 attribute is for variables whose base type is real.
 It is an optional field.
 If not defined for any atom with base type real, the dimensions will be
 left as undefined.
 Any variable which is later declared to be one of these types will be given
 wild card dimensionality (represented in the interactive display by an
 asterisk (*)).
 The system will deduce the dimensionality from its use in the relationships
 in which it appears or in the declaring of default values for it, if possible.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
solver_var
\family default

\begin_inset LatexCommand \index{solver\_var}

\end_inset

 is a special case of 
\family sans
ATOM
\family default
 and we will say much more about it in Section 
\begin_inset LatexCommand \vref{sub:x.6.1Variables-for-solvers}

\end_inset

.
\end_layout

\begin_deeper
\begin_layout LyX-Code
ATOM solver_var REFINES real DEFAULT 0.5 {?
\begin_inset LatexCommand \index{?}

\end_inset

};
\end_layout

\begin_layout LyX-Code
   lower_bound IS_A real;
\end_layout

\begin_layout LyX-Code
   upper_bound IS_A real;
\end_layout

\begin_layout LyX-Code
   nominal IS_A real;
\end_layout

\begin_layout LyX-Code
   fixed IS_A boolean;
\end_layout

\begin_layout LyX-Code
   fixed := FALSE;
\end_layout

\begin_layout LyX-Code
   lower_bound := -1e20 {?};
\end_layout

\begin_layout LyX-Code
   upper_bound := 1e20 {?};
\end_layout

\begin_layout LyX-Code
   nominal := 0.5 {?};
\end_layout

\begin_layout LyX-Code
END solver_var;
\end_layout

\begin_layout Standard
The default field is also optional.
 If the atom has a declared dimensionality, then this value must be expressed
 with units which are compatible with this dimensionality.
 In the solver_var example, we see a DEFAULT value of 0.5 with the unspecified
 unit
\begin_inset LatexCommand \index{unit, unspecified}

\end_inset


\begin_inset LatexCommand \index{unspecified unit}

\end_inset

 {?
\begin_inset LatexCommand \index{}

\end_inset

} which leaves the dimensionality wild
\begin_inset LatexCommand \index{wild dimensionality}

\end_inset

.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
real
\begin_inset LatexCommand \index{real}

\end_inset

 Real valued variable quantity.
 At present, all variables that you want to be attended to by solver tools
 must be refinements of the type solver_var.
 This is so that modifiable parametric values can be included in equations
 without treating them as variables.
 Strictly speaking, this is a characteristic of the solver interface and
 not the ASCEND language.
 Each tool in the total ASCEND system may have its own semantics that go
 beyond the ASCEND object definition language.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
integer
\begin_inset LatexCommand \index{integer}

\end_inset

 Integer valued variable quantity.
 We find these mighty convenient for use in certain procedural computations
 and as attributes of solver_var atoms.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
boolean
\begin_inset LatexCommand \index{boolean}

\end_inset

 Truth valued variable quantity.
 These are principally used as flags on solver_vars and relations.
 They can also be used procedurally and as variables in logical programming
 models, subject to the logical solver tools semantics.
 (Compare solver_boolean and boolean_var in Section 
\begin_inset LatexCommand \vref{sec:x.6Miscellany}

\end_inset

.)
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
symbol
\begin_inset LatexCommand \index{symbol}

\end_inset

 Symbol valued variable quantity.
 We do not yet have operators for building symbols out of other symbols.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Setting\InsetSpace ~
variables
\bar default

\begin_inset LatexCommand \index{variables, setting}

\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
:=
\begin_inset LatexCommand \index{:=}

\end_inset

 Procedural equals
\begin_inset LatexCommand \index{equals, procedural}

\end_inset

 differs from the ordinary equals (=) in that it means the left-hand-side
 (LHS) variables are to be assigned the value of the right-hand-side (RHS)
 expression when this statement is processed.
 Processing happens in the last phase of compiling (instantiation) or when
 executing a method interactively through the ASCEND user interface.
 The order the system encounters these statements matters, therefore, with
 a later result overwriting an earlier one if both statements have the same
 the same LHS variable.
 
\end_layout

\begin_deeper
\begin_layout Standard
Note that variable assignments (also known as defaulting statements) written
 in the declarative section are executed only after an instance has been
 fully created.
 This is a frequent source of confusion and errors, therefore we recommend
 that you DO NOT ASSIGN VARIABLES IN THE DECLARATIVE SECTION.
 
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Note\InsetSpace ~
that\InsetSpace ~
:=\InsetSpace ~
IS\InsetSpace ~
NOT\InsetSpace ~
=.
\end_layout

\begin_deeper
\begin_layout Standard
We use an ordinary equals (=) when defining a real valued equation to state
 that the LHS expression is to equal the RHS expression at the solution
 for the model.
 We use == for logical equations.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
\begin_inset Note Note
status open

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Tabular\InsetSpace ~
assignments
\bar default

\begin_inset LatexCommand \index{assignments, tabular}

\end_inset

 (* 4+ *) Assigning values en masse to arrays of variables that are defined
 associatively on sets without order presents a minor challenge.
 The solution proposed in ASCEND IV (but not yet implemented as weve not
 had time or significant user demand) is to allow a tabular data statement
 to be used to assign the elements of arrays of variables or constants.
 The DATA statement may be used to assign variables in the declarative or
 methods section of a model (though we discourage its use declaratively
 for variable initialization) or to assign constant arrays of any type,
 including sets, in the declarative section.
 Here are some examples:
\end_layout

\begin_layout LyX-Code
DATA ~(* ~4+ ~*)
\end_layout

\begin_deeper
\begin_layout LyX-Code
MODEL tabular_ex;
\end_layout

\begin_layout LyX-Code
   lset,rset,cset IS_A set OF integer_constant;
\end_layout

\begin_layout LyX-Code
   rset :== [1..3];
\end_layout

\begin_layout LyX-Code
   cset :== rset - [2];
\end_layout

\begin_layout LyX-Code
   lset :== [5,7];
\end_layout

\begin_layout LyX-Code
   a[rset][cset] IS_A real;
\end_layout

\begin_layout LyX-Code
   b[lset][cset][rset] IS_A real_constant; 
\end_layout

\begin_layout LyX-Code
   (* rectangle table *)
\end_layout

\begin_layout LyX-Code
   DATA FOR a:
\end_layout

\begin_layout LyX-Code
   COLUMNS 1,3; (*order last subscript cset*)
\end_layout

\begin_layout LyX-Code
   UNITS {kg/s}, {s}; (* columnar units *)
\end_layout

\begin_layout LyX-Code
   (* give leading subscripts *)
\end_layout

\begin_layout LyX-Code
   [1] 2.8, 0.3;
\end_layout

\begin_layout LyX-Code
   [2] 2.7, 1.3;
\end_layout

\begin_layout LyX-Code
   [3] 3.3, 0.6;
\end_layout

\begin_layout LyX-Code
END DATA;
\end_layout

\begin_layout LyX-Code
(* 2 layer rectangle table *)
\end_layout

\begin_layout LyX-Code
CONSTANT DATA FOR b:
\end_layout

\begin_layout LyX-Code
   COLUMNS 1..3; (* order last subscript
\end_layout

\begin_layout LyX-Code
      rset *)
\end_layout

\begin_layout LyX-Code
   (* UNITS omitted, so either the user gives
\end_layout

\begin_layout LyX-Code
      value in the table or values given are
\end_layout

\begin_layout LyX-Code
      DIMENSIONLESS.
 *)
\end_layout

\begin_layout LyX-Code
   (* ordering over [lset][cset] required *)
\end_layout

\begin_layout LyX-Code
   [5][1] 3 {m}, 2{m}, 1{m};
\end_layout

\begin_layout LyX-Code
   [5][3] 0.1, 0.2, 0.3;
\end_layout

\begin_layout LyX-Code
   [7][1] -3 {m/s}, -2{m/s}, -1{m/s};
\end_layout

\begin_layout LyX-Code
   [7][3] 4.1 {1/s}, 4.2 {1/s}, 4.3 {1/s};
\end_layout

\begin_layout LyX-Code
END DATA;
\end_layout

\begin_layout LyX-Code
END tabular_ex;
\end_layout

\begin_layout Standard
For sparse arrays of variables or constants, the COLUMNS and (possibly)
 UNITS keywords are omitted and the array subscripts are simply enumerated
 along with the values to be assigned.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\end_layout

\begin_layout Section
Relations
\begin_inset LatexCommand \index{relations}

\end_inset


\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Mathematical\InsetSpace ~
expression
\begin_inset LatexCommand \index{mathematical expression}

\end_inset


\begin_inset LatexCommand \index{expression, math}

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
The syntax for a mathematical expression is any legal combination of variable
 names and arithmetic operators in the normal notation.
 An expression may contain any number of matched rounded parentheses, (),
 to clarify meaning.
 The following is a legal arithmetic expression:
\end_layout

\begin_layout LyX-Code
y^2+(sin(x)-tan(z))*q
\end_layout

\begin_layout Standard
Each additive term in a mathematical expression (terms are separated by
 + or - operators) must have the same dimensionality.
\end_layout

\begin_layout Standard
An expression may contain an index variable as a part of the calculation
 if that index variable is over a set whose elements are of type integer.
 (See the 
\family sans
FOR/CREATE
\family default
 and 
\family sans
FOR/DO 
\family default
statements below.) An example is:
\end_layout

\begin_layout LyX-Code
term[i] = a[i]*x^(i-1);
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Numerical\InsetSpace ~
relations
\bar default

\begin_inset LatexCommand \index{relations, numerical}

\end_inset


\begin_inset LatexCommand \index{numerical relations}

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The syntax for a numeric relation is either
\end_layout

\begin_layout LyX-Code

\emph on
optional_label
\emph default
: 
\emph on
LHS relational_operator RHS
\emph default
;
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code

\emph on
optional_label
\emph default
: 
\emph on
objective_type LHS
\emph default
;
\end_layout

\begin_layout Standard
Objective_type is either 
\family sans
MAXIMIZE
\family default
 or 
\family sans
MINIMIZE
\family default
.
 RHS and LHS must be one or more variables, constants, and operators in
 a normal algebraic expression.
 The operators allowed are defined below and in Section 
\begin_inset LatexCommand \vref{sub:x.6.3Single-operand-real}

\end_inset

.
 Variable integers, booleans, and symbols are not allowed as operands in
 numerical relations, nor are boolean constants.
 Integer indices declared in 
\family sans
FOR/CREATE
\family default
 loops are allowed in relations, and they are treated as integer constants.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Relational\InsetSpace ~
operators
\begin_inset LatexCommand \index{operators, relational}

\end_inset


\begin_inset LatexCommand \index{relational operators}

\end_inset

:
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
=
\begin_inset LatexCommand \index{=}

\end_inset

,\InsetSpace ~
>=
\begin_inset LatexCommand \index{ >=}

\end_inset

,\InsetSpace ~
<=
\begin_inset LatexCommand \index{<=}

\end_inset

,\InsetSpace ~
<
\begin_inset LatexCommand \index{<}

\end_inset

,\InsetSpace ~
>
\begin_inset LatexCommand \index{>}

\end_inset

,\InsetSpace ~
<>
\begin_inset LatexCommand \index{<>}

\end_inset

 These are the numerical relational operators for declarative use.
\end_layout

\begin_deeper
\begin_layout LyX-Code
Ftot*y['methane'] = m['methane'];
\end_layout

\begin_layout LyX-Code
y['ethanol'] >= 0;
\end_layout

\begin_layout Standard
Equations must be dimensionally correct.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
MAXIMIZE
\family default

\begin_inset LatexCommand \index{MAXIMIZE}

\end_inset

,\InsetSpace ~

\family sans
MINIMIZE
\family default

\begin_inset LatexCommand \index{MINIMIZE}

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Objective function indicators.
 
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Binary\InsetSpace ~
Operators
\begin_inset LatexCommand \index{operators, binary}

\end_inset


\begin_inset LatexCommand \index{binary operators}

\end_inset

:
\bar default
 +, -, *, /, ^.
 We follow the usual algebraic order of operations for binary operators.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
+
\begin_inset LatexCommand \index{+, binary math}

\end_inset

 Plus.
 Numerical addition or set union.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
-
\begin_inset LatexCommand \index{-, binary math}

\end_inset

 Minus.
 Numerical subtraction or set difference.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
*
\begin_inset LatexCommand \index{*, binary math}

\end_inset

 Times.
 Numerical multiplication or set intersection.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
/
\begin_inset LatexCommand \index{/}

\end_inset

 Divide.
 Numeric division.
 In most cases it implies real division and not integer division.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
^ Power
\begin_inset LatexCommand \index{power}

\end_inset

.
 Numeric exponentiation.
 If the value of y in x^y is not integer, then x must be greater than 0.0
 and dimensionless.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Unary\InsetSpace ~
Operators
\begin_inset LatexCommand \index{operators, unary}

\end_inset


\begin_inset LatexCommand \index{unary operators}

\end_inset

:
\bar default
 -
\begin_inset LatexCommand \index{-, unary}

\end_inset

, ordered_function()
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
- Unary minus.
 Numeric negation.
 There is no unary +
\begin_inset LatexCommand \index{+, math unary}

\end_inset

 operator.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family typewriter
ordered_function
\begin_inset LatexCommand \index{ordered\_function}

\end_inset

()
\family default
 unary real valued functions.
 The unary real functions we support are given in section Section 
\begin_inset LatexCommand \vref{sub:x.6.3Single-operand-real}

\end_inset

.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
Real\InsetSpace ~
functions\InsetSpace ~
of\InsetSpace ~
sets\InsetSpace ~
of\InsetSpace ~
real\InsetSpace ~
terms:
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
SUM
\family default

\begin_inset LatexCommand \index{SUM}

\end_inset


\family typewriter
[term\InsetSpace ~
set]
\family default
 Add all expressions in the functions list.
\end_layout

\begin_deeper
\begin_layout Standard
For the 
\family sans
SUM
\family default
, the base type real items can be arbitrary arithmetic expressions.
 The resulting items must all be dimensionally compatible.
\end_layout

\begin_layout Standard
An examples of the use is:
\end_layout

\begin_layout LyX-Code
SUM[y[components]] = 1;
\end_layout

\begin_layout Standard
or, equivalently, one could write:
\end_layout

\begin_layout LyX-Code
SUM[y[i] | i IN components] = 1;
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Empty\InsetSpace ~

\family sans
SUM
\family default
\InsetSpace ~
yields\InsetSpace ~
wildcard\InsetSpace ~

\family typewriter
0
\family default
.
\end_layout

\begin_deeper
\begin_layout Standard
When a 
\family sans
SUM
\family default
 is compiled over a list which is empty it generates a wildcard-dimensioned
 
\family typewriter
0
\family default
.
 This will sometimes cause our dimension checking routines to fail.
 The best way to prevent this is to make sure the SUM never actually encounters
 an empty list.
 For example:
\end_layout

\begin_layout LyX-Code
SUM[Q[possibly_empty_set], 0{watt}];
\end_layout

\begin_layout Standard
In the above, the variables 
\family typewriter
Q[i]
\family default
 (if they exist) have the dimensionality associated with an energy rate.
 When the set is empty, the 
\family typewriter
0
\family default
 is the only term in the 
\family sans
SUM
\family default
 and establishes the dimensionality of the result.
 When the set is 
\emph on
not
\emph default
 empty the compiler will simplify away the trailing 
\family typewriter
0
\family default
 in the sum.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
PROD
\begin_inset LatexCommand \index{PROD}

\end_inset

[term\InsetSpace ~
set] Multiply all the expressions in the products list.
 The product of an empty list is a dimensionless value, 1.0.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Possible\InsetSpace ~
future\InsetSpace ~
functions:
\end_layout

\begin_deeper
\begin_layout Standard
(Not implemented - only under confused consideration at this time.) The following
 functions only work in methods as they are not smooth function and would
 destroy a Newton-based solution algorithm if used in defining a model equation:
\begin_inset Note Note
status open

\begin_layout Standard
Clarification required
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
MAX
\begin_inset LatexCommand \index{MAX}

\end_inset

[term\InsetSpace ~
set] (* 4+ *) maximum value on list of arguments
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
MIN
\begin_inset LatexCommand \index{MIN}

\end_inset

[term\InsetSpace ~
set] (* 4+ *) minimum value on list of arguments
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Section
Derivatives
\begin_inset LatexCommand \index{derivatives}

\end_inset

 in relations
\end_layout

\begin_layout Standard
Simply put, we would like to have general partial and full derivatives usable
 in writing equations, as there are many mathematically interesting things
 that can be said about both.
 We have not implemented such things yet for lack of time and because with
 several implementations (see gPROMS and OMOLA, among others) already out
 there we cant see too many research points to be gained by more derivative
 work.
\end_layout

\end_inset


\end_layout

\begin_layout Section
External relations
\begin_inset LatexCommand \index{relations, external}

\end_inset


\begin_inset LatexCommand \index{external relations}

\end_inset

 
\end_layout

\begin_layout Standard
We cannot document these at the present time.
 Some details are available in Kirk Abbott's thesis 
\begin_inset LatexCommand \cite{Abbott1996a}

\end_inset

, or check the wiki at 
\family sans
http://ascendwiki.cheme.cmu.edu/
\end_layout

\begin_layout Section
Conditional modelling
\begin_inset LatexCommand \index{relations, conditional}

\end_inset


\begin_inset LatexCommand \index{conditional relations}

\end_inset


\end_layout

\begin_layout Subsection
Conditional relations
\end_layout

\begin_layout Standard
The syntax is 
\end_layout

\begin_layout LyX-Code
CONDITIONAL 
\end_layout

\begin_layout LyX-Code

\emph on
   list_of_relation_statements
\end_layout

\begin_layout LyX-Code
END CONDITIONAL;
\end_layout

\begin_layout Standard
A 
\family sans
CONDITIONAL
\family default
 statement can appear anywhere in the declarative portion of the model and
 it contains only relations to be used as boundaries.
 That is, these real arithmetic equations are used in expressing logical
 condition equations via the 
\family sans
SATISFIED
\family default
 operator.
\end_layout

\begin_layout Subsection
Logical relations
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Logical\InsetSpace ~
expression
\bar default

\begin_inset LatexCommand \index{expression, logical}

\end_inset


\begin_inset LatexCommand \index{logical expression}

\end_inset

 An expression whose value is 
\family sans
TRUE
\family default
 or 
\family sans
FALSE
\family default
 is a logical expression.
 Such expressions may contain boolean variables.
 If A,B, and laminar are boolean, then the following is a logical expression:
\end_layout

\begin_deeper
\begin_layout LyX-Code
A + (B * laminar)
\end_layout

\begin_layout Standard
as is (and probably more clearly)
\end_layout

\begin_layout LyX-Code
A OR (B AND laminar)
\end_layout

\begin_layout Standard
The plus operator acts like an OR among the terms while the times operator
 acts like an 
\family sans
AND
\family default
.
 Think of 
\family sans
TRUE
\family default
 being equal to 1 and 
\family sans
FALSE
\family default
 being equal to 0 with the 1+1=0+1=1+0=1, 0+0=0, 1*1=1 and 0*1=1*0=0*0=0.
 If A = 
\family sans
FALSE
\family default
, B=
\family sans
TRUE
\family default
 and laminar is 
\family sans
TRUE
\family default
, this expression has the value
\end_layout

\begin_layout LyX-Code
FALSE OR (TRUE AND TRUE) -->TRUE
\end_layout

\begin_layout Standard
or in terms of ones and zeros
\end_layout

\begin_layout LyX-Code
0 + (1 * 1) --> 1.
\end_layout

\begin_layout Standard
Logical relations are then made by putting together logical expressions
 with the boolean relational operators 
\family typewriter
==
\family default
 and 
\family typewriter
!=
\family default
.
 Since we have no logical solving engine we have not pushed the implementation
 of logical relations very hard yet.
\end_layout

\begin_layout Section

\family sans
NOTES
\family default

\begin_inset LatexCommand \index{NOTES}

\end_inset


\end_layout

\begin_layout Standard
Within a 
\family sans
MODEL
\family default
 (or 
\family sans
METHOD
\family default
) definition annotations (hereafter called notes) may be made on a part
 declared in the 
\family sans
MODEL
\family default
, or on the 
\family sans
MODEL
\family default
 (or 
\family sans
METHOD
\family default
) itself.
 Short notes may be made when defining or refining an object by enclosing
 the note in double quotes (
\family typewriter
"
\family default
).
 Longer notes may be made in a block statement.
\end_layout

\begin_layout Standard
Each note is entered in a database with the name of the file, name of 
\family sans
MODEL
\family default
, name of 
\family sans
METHOD
\family default
 if applicable, and the language (a kind of keyword) in which the note is
 written.
 Users, user interfaces, and other programs may query this database for
 information on models and simulations.
 The block notes may include code fragments in other languages that you
 wish to embed in your 
\family sans
MODEL
\family default
 or any other kind of text.
\end_layout

\begin_layout Standard
Short notes should be included as you write any model to clarify the roles
 of parts and variables.
 All short notes have the language 'inline.' Here are some examples of short
 notes:
\end_layout

\begin_layout LyX-Code
L[1..10] "L[i] is the length of the ith rod" 
\end_layout

\begin_layout LyX-Code
         IS_A distance;
\end_layout

\begin_layout LyX-Code
thetaM "angle between horizon and moon",
\end_layout

\begin_layout LyX-Code
thetaJ "angle between horizon and jupiter"
\end_layout

\begin_layout LyX-Code
         IS_A angle;
\end_layout

\begin_layout LyX-Code
car.tires "using car in Minnesota, you betcha"
\end_layout

\begin_layout LyX-Code
         IS_REFINED_TO snow_tire;
\end_layout

\begin_layout Standard
In the second 
\family sans
IS_A
\family default
 statement concerning two angles, we see that a short note in double quotes
 goes with the name immediately to its left.
 We also see that the note comes before the comma if the name is part of
 a list of names.
 In the third statement, we see that not only simple names but also qualified
 names may be annotated.
 
\end_layout

\begin_layout Standard
Longer notes are made in block statements of the form below.
 These blocks can appear in a 
\family sans
METHOD
\family default
 or 
\family sans
MODEL
\family default
.
 These blocks can also be written separately before or after a model as
 we shall see.
\end_layout

\begin_layout LyX-Code
NOTES
\end_layout

\begin_layout LyX-Code
  'language or keyword' list.of, names {
\end_layout

\begin_layout LyX-Code
    free-form block of text to store in the
\end_layout

\begin_layout LyX-Code
    database exactly as written.
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  some.other.name {
\end_layout

\begin_layout LyX-Code
    this note has the same language or keyword as
\end_layout

\begin_layout LyX-Code
    the first since we didn't define a new keyword
\end_layout

\begin_layout LyX-Code
    in single quotes before the name list.
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  'another language' some.other.name {
\end_layout

\begin_layout LyX-Code
    en espanol
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  'fortran' SELF {
\end_layout

\begin_layout LyX-Code
    This model should be solved with subroutine
\end_layout

\begin_layout LyX-Code
    LSODE.
\end_layout

\begin_layout LyX-Code
    This note demonstrates that "SELF" can be used
\end_layout

\begin_layout LyX-Code
    to annotate the entire model instead of a
\end_layout

\begin_layout LyX-Code
    named part.
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
END NOTES;
\end_layout

\begin_layout Standard
Notes made outside the scope of a model definition look like one of the
 following:
\end_layout

\begin_layout LyX-Code
ADD NOTES IN name_of_model;
\end_layout

\begin_layout LyX-Code
  'language or keyword' list.of, names {
\end_layout

\begin_layout LyX-Code
    more text
\end_layout

\begin_layout LyX-Code
  } (* more than one note may be made in this
\end_layout

\begin_layout LyX-Code
    block if desired.
 *)
\end_layout

\begin_layout LyX-Code
END NOTES;
\end_layout

\begin_layout LyX-Code
ADD NOTES IN name_of_model METHOD name_of_method;
\end_layout

\begin_layout LyX-Code
  'language or keyword' SELF {
\end_layout

\begin_layout LyX-Code
    This method proves Fermat's last theorem and
\end_layout

\begin_layout LyX-Code
    makes toast.
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  'humor' SELF {
\end_layout

\begin_layout LyX-Code
    ASCEND is not expected to make either proving
\end_layout

\begin_layout LyX-Code
    FLT or toasting possible.
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
END NOTES;
\end_layout

\begin_layout Standard
We can add notes to the database before or after defining the annotated
 model.
 This is handy for several reasons including:
\end_layout

\begin_layout Itemize
Lengthy notes mixed with model and method code can make that code very hard
 to read.
 
\end_layout

\begin_layout Itemize
Separate notes describing a family of models can be loaded and browsed before
 loading that library family.
\end_layout

\begin_layout Itemize
Users other than the author of a model can annotate that model without fear
 of introducing typographical errors into the model.
\end_layout

\begin_layout Standard
These advantages come with a disadvantage that all documentation has.
 If you change the model, you ought to change the documentation at the same
 time.
 To make finding these documentation locations in need of change easier,
 the name of the file containing each note is included in the loaded database.
\end_layout

\begin_layout Standard
Experience has shown that even documentation embedded directly in models
 or in other computer programs gets out-dated if the person changing the
 program is in a hurry and is not required to document properly as part
 of the task at hand.
 Neither ASCEND nor any other software system can eliminate the garbage
 code and documentation that results from undisciplined modeling.
\end_layout

\begin_layout Chapter
Declarative statements
\begin_inset LatexCommand \index{statements, declarative}

\end_inset


\begin_inset LatexCommand \index{declarative statements}

\end_inset


\begin_inset LatexCommand \label{sec:x.3Declarative-statements}

\end_inset


\end_layout

\begin_layout Standard
We have already seen several examples that included declarative statements.
 Here we will be more systematic in defining things.
 The statements we describe are legal within the declarative portion of
 an 
\family sans
ATOM
\family default
 or 
\family sans
MODEL
\family default
 definition.
 The declarative portion stops at the keyword 
\family sans
METHODS
\family default
 if it is present in the definition or at the end of the definition.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Statements
\bar default

\begin_inset LatexCommand \index{statements}

\end_inset

 Statements in ASCEND terminate with a semicolon (
\family typewriter
;
\family default
).
 Statements may extend over any number of lines.
 They may have blank lines in the middle of them.
 There may be several statements on a single line.
 
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Compound\InsetSpace ~
statements
\bar default

\begin_inset LatexCommand \index{statements, compound}

\end_inset


\begin_inset LatexCommand \index{compound statements}

\end_inset

 Some statements in ASCEND can contain other statements as a part of them.
 The declarative compound statements are the 
\family sans
ALIASES
\family default
/
\family sans
IS_A
\family default
, 
\family sans
CONDITIONAL
\family default
, 
\family sans
FOR/CREATE
\family default
, 
\family sans
SELECT/CASE
\family default
, and 
\family sans
WHEN/CASE
\family default
 statements.
 The procedural compound statements allowed only in methods are the 
\family sans
FOR/DO
\family default
, 
\family sans
FOR/CHECK
\family default
, 
\family sans
SWITCH
\family default
 and the 
\family sans
IF
\family default
 statements.
 Compound statements end with "
\family sans
END
\family default
 
\family typewriter
word
\family default
;", where word matches the beginning of the syntax block, e.g.
 
\family sans
END FOR
\family default
.and they can be nested, with some exceptions which are noted later.
 
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
\bar under
CASE
\family default
\InsetSpace ~
statements
\bar default

\begin_inset LatexCommand \index{statements, CASE}

\end_inset


\begin_inset LatexCommand \index{CASE statements}

\end_inset

 
\family sans
WHEN/CASE
\family default
, 
\family sans
CONDITIONAL
\family default
, and 
\family sans
SELECT/CASE
\family default
 handle modeling alternatives within a single definition.
 The easy way to remember the difference is that the first picks which equations
 to solve 
\family sans
WHEN
\family default
 discrete variables have certain values, while the second 
\family sans
SELECT
\family default
s which statements to compile based on discrete constants.
 SWITCH statements handle flow of control in methods, in a slightly more
 generalized form than the C language switch statement.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
Type\InsetSpace ~
declarations
\begin_inset LatexCommand \index{declarations, type}

\end_inset


\begin_inset LatexCommand \index{yype declarations}

\end_inset

 are not compound statements.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
MODEL
\family default
 and 
\family sans
ATOM
\family default
 type definitions and 
\family sans
METHOD
\family default
 definitions are not really compound statements because they require a name
 following their 
\family sans
END
\family default
 word that matches the name given at the beginning of the definition.
 These definitions cannot be nested.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
ASCEND\InsetSpace ~
operator\InsetSpace ~
synopses:
\end_layout

\begin_deeper
\begin_layout Standard
Well start with an extremely brief synopsis of what each does and then give
 detailed descriptions.
 It is helpful to remember that an instance may have many names, even in
 the same scope, but each name may only be defined once.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
IS_A
\family default

\begin_inset LatexCommand \index{IS\_A}

\end_inset

 Constructor.
 Calls for one or more named instances to be compiled using the type specified.
 If the type is one that requires parameters, the parameters must be supplied
 in 
\family typewriter
()
\family default
 following the type name.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
IS_REFINED_TO
\family default

\begin_inset LatexCommand \index{IS\_REFINED\_TO}

\end_inset

 Reconstructor.
 Causes the already compiled instance(s) named to have their type changed
 to a more refined type.
 This causes an incremental recompilation of the instance(s).
 
\family sans
IS_REFINED_TO
\family default
 is not a redefinition of the named instances because refinement can only
 add compatible information.
 The instances retain all the structure that originally defined them.
 If the type being refined to requires arguments, these must be supplied,
 even if the same arguments were required in the 
\family sans
IS_A
\family default
 of the originally less refined declaration of the instance.
 
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
ALIASES
\family default

\begin_inset LatexCommand \index{ALIASES}

\end_inset

 Part alternate naming statement.
 Establishes another name for an instance at the same scope or in a child
 instance.
\begin_inset Foot
status collapsed

\begin_layout Standard
The equivalent of an 
\family sans
ALIASES
\family default
 in ASCEND III was to create another part with the desired name and merge
 it immediately via 
\family sans
ARE_THE_SAME
\family default
 with the part being renamed, a rather expensive and unintuitive process.
\end_layout

\end_inset

 
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
ALIASES/IS_A
\family default

\begin_inset LatexCommand \index{ALIASES/IS\_A}

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Creates an array of alternate names for a list of existing instances with
 some common base type and creates the set over which the elements of the
 array are indexed.
 Useful for making collections of related objects in ways the original author
 of the model didnt anticipate.
 Also useful for assembling array arguments to parameterized type definitions.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
WILL_BE
\family default

\begin_inset LatexCommand \index{WILL\_BE}

\end_inset

 Forward declaration statement.
 Promises that a part with the given type will be constructed by an as yet
 unknown IS_A statement above the current scope.
 At present 
\family sans
WILL_BE
\family default
 is legal only in defining parameters.
 Were it legal in the body of a model, compiling models would be very expensive.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
ARE_THE_SAME
\family default

\begin_inset LatexCommand \index{ARE\_THE\_SAME}

\end_inset

 Merge.
 Calls for two or more instances already compiled to be merged recursively.
 This essentially means combining all the values in the instances into the
 most refined of the instances and then destroying all the extra, possibly
 less refined, instances.
 The remaining instance has its original name and also all the names of
 the instances destroyed during the merge.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
WILL_BE_THE_SAME
\family default

\begin_inset LatexCommand \index{WILL\_BE\_THE\_SAME}

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Structural condition statement restricting objects in a forward declaration.
 The objects passed to a parameterized type definition can be constrained
 to have arbitrary parts in common before the parameterized object is constructe
d.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
WILL_NOT_BE_THE_SAME
\family default

\begin_inset LatexCommand \index{WILL\_NOT\_BE\_THE\_SAME}

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Structural condition statement restricting objects in a forward declaration.
 We apologize for the length of this key word, but we bet it is easy to
 remember.
 The objects passed to a parameterized type definition can be constrained
 to have arbitrary parts be distinct instances before the parameterized
 object is constructed.
 At present the constraint is only enforced when the objects are being passed.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
\begin_inset Note Note
status open

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
ARE_NOT_THE_SAME
\family default

\begin_inset LatexCommand \index{ARE\_NOT\_THE\_SAME}

\end_inset


\end_layout

\begin_layout Standard
Cannot be merged.
 We believe it is useful to say that two objects cannot be merged and still
 represent a valid model.
 This is not yet implemented, however, mainly for lack of time.
 The implementation is simple.
\end_layout

\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
ARE_ALIKE
\family default

\begin_inset LatexCommand \index{ARE\_ALIKE}

\end_inset

 Refinement clique
\begin_inset LatexCommand \index{clique}

\end_inset

 constructor.
 Causes a group of instances to always be of the same formal type.
 Refining one of them causes a refinement of all the others.
 Does not propagate implicit type information, such as assignments to constants
 or part refinements made from a scope other than the scope of the formal
 definition.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
FOR/CREATE
\family default

\begin_inset LatexCommand \index{FOR/CREATE}

\end_inset

 Indexed execution of other declarative statements.
 Required for creating arrays of relations and sparse arrays of other types.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
FOR/CHECK
\family default

\begin_inset LatexCommand \index{FOR/CHECK}

\end_inset

 Indexed checking of the conditions (WHERE
\begin_inset LatexCommand \index{WHERE}

\end_inset

 statements) of a parameterized model.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
SELECT/CASE
\family default

\begin_inset LatexCommand \index{SELECT/CASE}

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Select a subset of statements to compile.
 Given the values of the specified constants, 
\family sans
SELECT
\family default
 compiles all cases that match those values.
 A name cannot be defined two different ways inside the 
\family sans
SELECT
\family default
 statement, but it may be defined outside the case statement and then refined
 in different ways in separate cases.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
CONDITIONAL
\family default

\begin_inset LatexCommand \index{CONDITIONAL}

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Describe bounding relations.
 The relations written inside a 
\family sans
CONDITIONAL
\family default
 statement must all be labelled.
 These relations can be used to define regions in which alternate sets of
 equations apply using the 
\family sans
WHEN
\family default
 statement.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
WHEN/CASE
\family default

\begin_inset LatexCommand \index{WHEN/CASE}

\end_inset

 When logical variables have certain values, use certain relations or model
 parts in defining a mathematical problem.
 The relations are not defined inside the WHEN statement because all the
 relations must be compiled regardless of which values the logical variables
 have at any given moment.
 
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
Reminder: In the following detailed statement descriptions, we show keywords
 in capital letters.
 These words must appear in capital letters as shown in ASCEND statements.
 We show optional parts to a statement enclosed in double angle brackets
 (« ») and user supplied names in lower-case italic letters.
 (Remember that ASCEND treats the underscore (_) as a letter).
 The user may substitute any name desired for these names.
 We use names that describe the kind of name the user should use.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Operators\InsetSpace ~
in\InsetSpace ~
detail:
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
IS_A
\begin_inset LatexCommand \index{IS\_A}

\end_inset

 This statement has the syntax
\end_layout

\begin_deeper
\begin_layout LyX-Code

\emph on
list_of_instance_names
\emph default
 IS_A 
\emph on
model_name
\end_layout

\begin_layout LyX-Code
   «(arguments_if_needed)»;
\end_layout

\begin_layout Standard
The IS_A statement allows us to declare instances of a given type to exist
 within a model definition.
 If type has not been defined (loaded in the ASCEND environment) then this
 statement is an error and the MODEL it appears in is irreparably damaged
 (at least until you delete the type definitions and reload a corrected
 file).
 Similarly, if the arguments needed are not supplied or if provably incorrect
 arguments are supplied, the statement is in error.
 The construction of the instances does not occur until all the arguments
 satisfy the definition of type.
\end_layout

\begin_layout Standard
If a name is used twice in WILL_BE/IS_A/ALIASES statements of the same model,
 ASCEND will complain bitterly when the definition is parsed.
 Duplicate naming is a serious error.
 Labels on relations share the same name space as other objects.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
IS_REFINED_TO
\begin_inset LatexCommand \index{IS\_REFINED\_TO}

\end_inset

 This statement has the syntax
\end_layout

\begin_deeper
\begin_layout LyX-Code
list_of_instances IS_REFINED_TO 
\emph on
type_name
\end_layout

\begin_layout LyX-Code
   «(arguments_if_needed)»;
\end_layout

\begin_layout Standard
We use this statement to change the type of each of the instances listed
 to the type type_name.
 The modeler has to have defined each member on the list of instances.
 The type_name has to be a type which refines the types of all the instances
 on the list.
\end_layout

\begin_layout Standard
An example of its use is as follows.
 First we define the parts called fl1, fl2 and fl3 which are of type flash.
\end_layout

\begin_layout LyX-Code
fl1, fl2, fl3 IS_A flash;
\end_layout

\begin_layout Standard
Assume that there exists in the previously defined model definitions the
 type adiabatic_flash that is a refinement of flash.
 Then we can make fl1 and fl3 into more refined types by stating:
\end_layout

\begin_layout LyX-Code
fl1, fl3 IS_REFINED_TO adiabatic_flash;
\end_layout

\begin_layout Standard
This reconstruction does not occur until the arguments to the type satisfy
 the definition type_name.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
ALIASES
\begin_inset LatexCommand \index{ALIASES}

\end_inset

\InsetSpace ~
(*\InsetSpace ~
4\InsetSpace ~
*) This statement has the syntax
\end_layout

\begin_deeper
\begin_layout LyX-Code

\emph on
list_of_instances
\emph default
 ALIASES 
\emph on
instance_name
\emph default
;
\end_layout

\begin_layout Standard
We use this statement to point at an already existing instance of any type
 other than relation, logical_relation, or when.
 For example, say we want a flash tank model to have a variable T, the temperatu
re of the vapor-liquid equilibrium mixture in the tank.
\end_layout

\begin_layout LyX-Code
MODEL tank;
\end_layout

\begin_layout LyX-Code
   feed, liquid, vapor IS_A stream;
\end_layout

\begin_layout LyX-Code
   state IS_A VLE_mixture;
\end_layout

\begin_layout LyX-Code
   T ALIASES state.T;
\end_layout

\begin_layout LyX-Code
   liquor_temperature ALIASES T;
\end_layout

\begin_layout LyX-Code
END tank;
\end_layout

\begin_layout Standard
We might also want a more descriptive name than T, so ALIASES can also be
 used to establish a second name at the same scope, e.g.
 liquor_temperature.
\end_layout

\begin_layout Standard
An ALIASES statement will not be executed until the RHS instance has been
 created with an IS_A.
 The compiler schedules ALIASES instructions appropriately and issues warnings
 if recursion is detected.
 An array of aliases, e.g.
 
\end_layout

\begin_layout LyX-Code
b[1..n], c ALIASES a; 
\end_layout

\begin_layout Standard
is permitted (though we cant think why anyone would want such an array),
 and the sets over which the array is defined must be completed before the
 statement is executed.
 So, in the example of b and c, the array b will not be created until a
 exists and n is assigned a value.
 b and c will be created at the same time since they are defined in the
 same statement.
 This suggests the following rule: if you must use an array of aliases,
 do not declare it in the same statement with a scalar alias.
\end_layout

\begin_layout Standard
The ALIASES RHS can be an element or portion of a larger array with the
 following exception.
 The existing RHS instance cannot be a relation or array of relations (including
 logical relations and whens) because of the rule in the language that a
 relation instance is associated with exactly one model.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
ALIASES/IS_A
\begin_inset LatexCommand \index{ALIASES/IS\_A}

\end_inset

\InsetSpace ~
(*\InsetSpace ~
4\InsetSpace ~
*)
\end_layout

\begin_deeper
\begin_layout Standard
The ALIASES/IS_A statement syntax is subject to change, though some equivalent
 will always exist.
 We take a set of symbol_constant or integer_constant and pair it with a
 list of instances to create an array.
 For the moment, the syntax and semantics is as follows.
\end_layout

\begin_layout LyX-Code

\emph on
alias_array_instance[aset]
\emph default
 
\end_layout

\begin_layout LyX-Code
ALIASES (
\emph on
list_of_instances)
\emph default
 
\end_layout

\begin_layout LyX-Code
WHERE 
\emph on
aset
\emph default
 IS_A set OF 
\emph on
settype
\emph default
;
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code

\emph on
alias_array_instance[aset]
\emph default
 
\end_layout

\begin_layout LyX-Code
ALIASES (
\emph on
list_of_instances
\emph default
) 
\end_layout

\begin_layout LyX-Code
WHERE 
\emph on
aset
\emph default
 IS_A set OF 
\emph on
settype
\emph default
 
\end_layout

\begin_layout LyX-Code
WITH_VALUE (
\emph on
value_list_matching_settype
\emph default
);
\end_layout

\begin_layout Standard
aset is the name of the set that will be created by the IS_A to index the
 array of aliases.
 If value_list_matching_set_type is not given, the compiler will make one
 up out of the integers (1..number of names in list_of_instances) or symbols
 derived from the individual names given.
 If the value list is given, it must have the same number of elements as
 the list of instances does.
 The value list elements must be unique because they form a set.
 The list of instances can contain duplicates.
 If any of these conditions are not met properly, the statement is in error.
\end_layout

\begin_layout Standard
ALIASES/IS_A can be used inside a FOR statement.
 When this occurs, the definition of aset must be indexed and it must be
 the last subscript of alias_array_instance.
 The statement must look like:
\end_layout

\begin_layout LyX-Code

\emph on
array_instance[FOR_index][aset[FORindex]]
\end_layout

\begin_layout LyX-Code
ALIASES (
\emph on
list_of_instances
\emph default
) 
\end_layout

\begin_layout LyX-Code
WHERE 
\emph on
aset[FORindex]
\emph default
 IS_A set OF 
\emph on
settype
\emph default
 
\end_layout

\begin_layout LyX-Code
WITH_VALUE (
\emph on
value_list_matching_settype
\emph default
);
\end_layout

\begin_layout Standard
Here, as with the unindexed version, the WITH_VALUE portion is optional.
\end_layout

\begin_layout Standard
If this explanation is unclear, just try it out.
 The compiler error messages for ALIASES/IS_A are particularly good because
 we know it is a bit tricky to explain.
 
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
WILL_BE
\begin_inset LatexCommand \index{WILL\_BE}

\end_inset

\InsetSpace ~
(*\InsetSpace ~
4\InsetSpace ~
*) instance WILL_BE type_name;
\end_layout

\begin_deeper
\begin_layout Standard
The most common use of this forward declaration is as a statement within
 the parameter list of a model definition.
 In parameter lists, list_of_instances must contain exactly one instance.
 When a model definition includes a parameter defined by WILL_BE, that model
 cannot be compiled until a compiled instance at least as refined as the
 type specified by type_name is passed to it.
\end_layout

\begin_layout Standard
(* 4+ *) The second potential use of WILL_BE is to establish that an array
 of a common base type exists and its elements will be filled in individually
 by IS_A or ARE_THE_SAME or ALIASES statements.
 WILL_BE allows us to avoid costly reconstruction or merge operations by
 establishing a placeholder instance which contains just enough type information
 to let us check the validity of other statements that require type compatibilit
y while delaying construction until it is called for by the filling in statement
s.
 Instances declared with WILL_BE are never compiled if they are not ultimately
 resolved to another instance created with IS_A.
 Unresolved WILL_BE instances will appear in the user interface as objects
 of type PENDING_INSTANCE_model_name.
 Because of the many implementation and explanation difficulties this usage
 of WILL_BE creates, it is not allowed.
 The ALIASES/IS_A construct does the same job in a much simpler way.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
ARE_THE_SAME
\begin_inset LatexCommand \index{ARE\_THE\_SAME}

\end_inset

 The format for this instruction is
\end_layout

\begin_deeper
\begin_layout LyX-Code

\emph on
list_of_instances
\emph default
 ARE_THE_SAME;
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename syntaxFig1.eps

\end_inset


\end_layout

\begin_layout Caption
Diagram of the Model Type Hierarchy for A, B, C, D, and E Example
\begin_inset LatexCommand \label{fig:HierarchyDiagram}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
All items on the list must have compatible types.
 For the example in Figure 
\begin_inset LatexCommand \ref{fig:HierarchyDiagram}

\end_inset

, consider a model where we define the following parts:
\end_layout

\begin_layout LyX-Code
a1 IS_A A;
\end_layout

\begin_layout LyX-Code
b1 IS_A B;
\end_layout

\begin_layout LyX-Code
c1 IS_A C;
\end_layout

\begin_layout LyX-Code
d1 IS_A D;
\end_layout

\begin_layout LyX-Code
e1 IS_A E;
\end_layout

\begin_layout Standard
Then the following ARE_THE_SAME statement is legal
\end_layout

\begin_layout LyX-Code
a1, b1, c1 ARE_THE_SAME;
\end_layout

\begin_layout Standard
while the following are not
\end_layout

\begin_layout LyX-Code
b1, d1 ARE_THE_SAME;
\end_layout

\begin_layout LyX-Code
a1, c1, d1 ARE_THE_SAME;
\end_layout

\begin_layout LyX-Code
b1, e1 ARE_THE_SAME;
\end_layout

\begin_layout Standard
When compiling a model, ASCEND will put all of the instances mentioned as
 being the same into an ARE_THE_SAME clique.
 ASCEND lists members of this clique when one asks via the interface for
 the aliases of any object in a compiled model.
\end_layout

\begin_layout Standard
Merging any other item with a member of the clique makes it the same as
 all the other items in the clique, i.e., it adds the newly mentioned items
 to the existing clique.
\end_layout

\begin_layout Standard
ASCEND merges all members of a clique by first checking that all members
 of the clique are type compatible.
 It then changes the type designation of all clique members to that of the
 most refined member.
\end_layout

\begin_layout Standard
It next looks inside each of the instances, all of which are now of the
 same type, and puts all of the parts with the same name into their respective
 ARE_THE_SAME cliques.
 The process repeats by processing these cliques until all parts of all
 parts of all parts, etc., are their respective most refined type or discovered
 to be type incompatible.
\end_layout

\begin_layout Standard
There are now lots of cliques associated with the instances being merged.
 The type associated with each such clique is now either a model, an array,
 or an atom (i.e., a variable, constant, or set).
 If a model, only one member of the clique generates its equations.
 If a variable, it assigns all members to the same storage location.
\end_layout

\begin_layout Standard
Note that the values of constants and sets are essentially type information,
 so merging two already assigned constants is only possible if merging them
 does not force one of them to be assigned a new value.
 Merging arrays with mismatching ranges of elements is an error.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
WILL_BE_THE_SAME\InsetSpace ~
(*\InsetSpace ~
4\InsetSpace ~
*)
\end_layout

\begin_deeper
\begin_layout Standard
There is no further explanation of this operator.
 
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
WILL_NOT_BE_THE_SAME\InsetSpace ~
(*\InsetSpace ~
4\InsetSpace ~
*)
\end_layout

\begin_deeper
\begin_layout Standard
There is no further explanation of this operator.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
ARE_NOT_THE_SAME\InsetSpace ~
(*\InsetSpace ~
4+\InsetSpace ~
*)
\end_layout

\begin_deeper
\begin_layout Standard
ARE_NOT_THE_SAME will be documented further when it is implemented.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
ARE_ALIKE
\begin_inset LatexCommand \index{ARE\_ALIKE}

\end_inset

 The format for this statement is
\end_layout

\begin_deeper
\begin_layout LyX-Code

\emph on
list_of_instance_names
\emph default
 ARE_ALIKE;
\end_layout

\begin_layout Standard
The compiler places all instances in the list into an ARE_ALIKE clique.
 It checks that the members are formally type compatible and then it converts
 each into the most refined type of any instance in the clique.
 At that point the compiler stops.
 It does not continue by placing the parts into cliques nor does it merge
 anything.
\end_layout

\begin_layout Standard
There are important consequences of modeling with such a partial merge.
 The consequences we are about to describe can be much more reliably achieved
 by use of parameterized types, when the types are well understood.
 When we are exploring new ways of modeling, ARE_ALIKE still has its uses.
 When a model and its initial uses are understood well enough to be put
 into a reusable library, then parameterization and the explicit statement
 of structural constraints by operators such as WILL_NOT_BE_THE_SAME should
 be the preferred method of ensuring correct use.
\end_layout

\begin_layout Standard
One consequence of ARE_ALIKE is to prevent extreme model misuse when configuring
 models.
 For example, suppose a modeler creates a new pressure changing model.
 The modeler is not yet concerned about the type of the streams into and
 out of the device but does care that these streams are of the same final
 type.
 For example, the modeler wants both to be liquid streams if either is or
 both to be vapor streams if either is.
 By declaring both to be streams only but declaring the two streams to be
 alike, the modeler accomplishes this intent.
 Suppose the modeler merges the inlet stream with a liquid outlet stream
 from a reactor.
 The merge operation makes the inlet stream into a liquid stream.
 The outlet stream, being in an ARE_ALIKE clique with the inlet stream,
 also becomes a liquid stream.
 Any subsequent merge of the outlet stream with a vapor stream will lead
 to an error due to type incompatibility when ASCEND attempts to compile
 that merge.
 Without the ARE_ALIKE statement, the compiler can detect no such incompatibilit
y unless parameterized models are used.
\end_layout

\begin_layout Standard
Another purpose is the propagation of types through a model.
 Altering the type of the inlet stream through merging it with a liquid
 stream automatically made the outlet stream into a liquid stream.
\end_layout

\begin_layout Standard
If all the liquid streams within a distillation column are alike, then the
 modeler can make them all into streams with a particular set of components
 in them and with the same method used for physical property evaluation
 by merging only one of them with a liquid stream of this type.
 This is the primary example which has been used to justify the existence
 of ARE_ALIKE.
 We have observed that its use makes a column library very difficult to
 compile efficiently.
 But since we now have parameterized types to help us keep the column library
 semantically consistent, ARE_ALIKE can be left to its proper role: the
 rapid prototyping of partially understood models.
 We have yet to see anyone use ARE_ALIKE in a prototyping context, however.
\end_layout

\begin_layout Standard
Finally, because ARE_ALIKE does not recursively put the parts of ARE_ALIKEd
 instances into ARE_ALIKE cliques, it is possible to ARE_ALIKE model instances
 which have compatible formal types but incompatible implicit types.
 This can lead to unexpected problems later and makes the ARE_ALIKE instruction
 a source of non-reusability.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
FOR/CREATE
\begin_inset LatexCommand \index{FOR/CREATE}

\end_inset

 The FOR/CREATE statement is a compound statement that looks like a loop.
 It isnt, however, necessarily compiled as a loop.
 What FOR really does is specify an index set value.
 Its format is:
\end_layout

\begin_deeper
\begin_layout LyX-Code
FOR 
\emph on
index_variable
\emph default
 IN 
\emph on
set
\emph default
 CREATE
\end_layout

\begin_layout LyX-Code

\emph on
   list_of_statements;
\end_layout

\begin_layout LyX-Code
END FOR;
\end_layout

\begin_layout Standard
This statement can be in the declarative part of the model definition only.
 Every statement in the list should have at least one occurrence of the
 index variable, or the statement should be moved outside the FOR to avoid
 redundant execution.
 A correct example is
\end_layout

\begin_layout LyX-Code
FOR i IN components CREATE
\end_layout

\begin_layout LyX-Code
a.y[i], b[i] ARE_THE_SAME;
\end_layout

\begin_layout LyX-Code
y[i] = K[i]*x[i];
\end_layout

\begin_layout LyX-Code
END FOR;
\end_layout

\begin_layout Standard

\family sans
FOR
\family default
 loops can be nested to produce sparse arrays as illustrated in Arrays can
 be jagged(
\begin_inset LatexCommand \vpageref{lyx:Arrays-can-be}

\end_inset

.
 IS_A and ALIASES statements are allowed in FOR loops, provided the statements
 are properly indexed, a new feature in ASCEND IV.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
SELECT/CASE
\family default

\begin_inset LatexCommand \index{SELECT/CASE}

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Declarative.
 Order does not matter.
 All matching cases are executed.
 The 
\family sans
OTHERWISE
\family default

\begin_inset LatexCommand \index{OTHERWISE}

\end_inset

 is executed if present and no other 
\family sans
CASE
\family default
s match.
 
\family sans
SELECT
\family default
 is not allowed inside 
\family sans
FOR
\family default
.
 Writing 
\family sans
FOR
\family default
 statements inside 
\family sans
SELECT
\family default
 is allowed.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
CONDITIONAL
\family default

\begin_inset LatexCommand \index{CONDITIONAL}

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Both real and logical relations are allowed in 
\family sans
CONDITIONAL
\family default
 statements.
\begin_inset Foot
status open

\begin_layout Standard

\family sans
CONDITIONAL
\family default
 is really just a shorthand for setting the 
\family typewriter
$boundary
\family default
 flag on a whole batch of relations, since 
\family typewriter
$boundary
\family default
 is a write-once attribute invisible through the user interface and methods
 at this time.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
WHEN/CASE
\family default

\begin_inset LatexCommand \index{WHEN/CASE}

\end_inset

 Inside each 
\family sans
CASE
\family default
, relations or model parts to be used are specified by writing, for example,
 
\family typewriter
USE mass_balance_1;
\family default
.
 The method of dealing with the combined logical/nonlinear model is left
 to the solver.
 All matching 
\family sans
CASE
\family default
s are included in the problem to be solved.
 
\end_layout

\begin_deeper
\begin_layout Chapter
Procedural statements
\begin_inset LatexCommand \index{statements, procedural}

\end_inset


\begin_inset LatexCommand \index{procedural statements}

\end_inset


\begin_inset LatexCommand \label{sec:x.4Procedural-statements}

\end_inset


\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
METHODS
\family default

\begin_inset LatexCommand \index{METHODS}

\end_inset

 This statement separates the method definitions in ASCEND from the declarative
 statements.
 All statements following this statement are to define methods in ASCEND
 while all before it are for the declarative part of ASCEND.
 The syntax for this statement is simply
\end_layout

\begin_deeper
\begin_layout LyX-Code
METHODS
\end_layout

\begin_layout Standard
with no punctuation.
 The next code must be a 
\family sans
METHOD
\family default
 or the 
\family sans
END
\family default
 of the type being defined.
 If there are no method definitions, this statement may be omitted.
\end_layout

\begin_layout Standard

\family sans
METHOD
\family default
 definitions for a type can also be added or replaced after the type has
 been defined.
 This is to make creating and debugging of methods as interactive as possible.
 In ASCEND an instance must be destroyed and recreated each time a new or
 revised method is added to the type definition.
 This is a very expensive process when working with models of significant
 size.
\end_layout

\begin_layout Standard
The detailed semantics of method inheritance, addition, and replacement
 of methods are given at the end of this section.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
ADD\InsetSpace ~
METHODS\InsetSpace ~
IN
\family default

\begin_inset LatexCommand \index{ADD METHODS IN}

\end_inset


\family typewriter
\InsetSpace ~
type_name;
\end_layout

\begin_deeper
\begin_layout Standard
This statement allows new methods to be added to an already loaded type
 definition.
 The next code must be a METHOD or the END METHODS; statement.
 If a method of the same name already exists in type_name, the statement
 is in error.
 If other types refine type_name then the addition follows the method inheritanc
e rules.
 Any type which inherited methods from type_name now inherits the methods
 added to type_name.
 If a refinement of type_name already defines a method ADDed to type_name,
 then the existing method in the more refined type is not disturbed.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
REPLACE\InsetSpace ~
METHODS\InsetSpace ~
IN
\family default

\begin_inset LatexCommand \index{REPLACE METHODS IN}

\end_inset


\family typewriter
\InsetSpace ~
type_name;
\end_layout

\begin_deeper
\begin_layout Standard
This statement allows existing methods to be replaced in an already loaded
 type definition.
 The next code must be a 
\family sans
METHOD
\family default
 or the 
\family sans
END METHODS
\family default
 statement.
 If a method of the same name does not exist in 
\family typewriter
type_name
\family default
, the statement is in error.
 If other types refine 
\family typewriter
type_name
\family default
 then the replacement follows the method inheritance rules.
 Any type which inherited the old method now inherits the replacment method
 instead.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
ADD\InsetSpace ~
METHODS\InsetSpace ~
IN\InsetSpace ~
DEFINITION\InsetSpace ~
MODEL
\family typewriter
;
\end_layout

\begin_deeper
\begin_layout Standard
This statement allows methods to be added globally.
 It should be used very sparingly.
 Library 
\family typewriter
basemodel.a4l
\family default
 contains the example of this statement.
 Methods in the global model definition are inherited by all models.
 There is no actual global model definition, but it has a method list for
 practical purposes.
 
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Initialization\InsetSpace ~
routines
\begin_inset LatexCommand \index{routines, initialization}

\end_inset


\begin_inset LatexCommand \index{initialization routines}

\end_inset

:
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
METHOD
\begin_inset LatexCommand \index{METHOD}

\end_inset

 A method in ASCEND must appear following the METHODS statement within a
 model.
 The system executes procedural statements of the method in the order they
 are written.
 
\end_layout

\begin_deeper
\begin_layout Standard
At present, there are no local variables or other structures in methods
 except loop indices.
 A method may be written recursively, but there is an arbitrary stack depth
 limit
\begin_inset Foot
status open

\begin_layout Standard
currently set to 20 in 
\family typewriter
compiler/initialize.h
\end_layout

\end_inset

 to prevent the system from crashing on infinite recursions.
 
\end_layout

\begin_layout Standard
Specifically disallowed in ASCEND methods are 
\family sans
IS_A
\family default
, 
\family sans
ALIASES
\family default
, 
\family sans
WILL_BE
\family default
, 
\family sans
IS
\family default
, 
\family sans
IS_REFINED_TO
\family default
, 
\family sans
ARE_THE_SAME
\family default
 and 
\family sans
ARE_ALIKE
\family default
 statements as these declare the structure of the model and belong only
 in the declarative section.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
(* 4+ *) In the near future, declarations of local instances (which are
 automatically destroyed when the method exits) will be allowed.
 Since methods are imperative, these local structure definitions are processed
 in the order they are written.
 Local structures are not allowed to shadow structures in the model context
 with which the method is called.
 When local structures are allowed, it will also be possible to define methods
 which take parameters and return values, thereby making the imperative
 ASCEND methods a rapid prototyping tool every bit as powerful and easy
 to use as the declarative ASCEND language.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax for a method declaration is
\end_layout

\begin_layout LyX-Code
METHOD 
\emph on
method_name
\emph default
;
\end_layout

\begin_layout LyX-Code
«procedural statement;» (*one or more*)
\end_layout

\begin_layout LyX-Code
END 
\emph on
method_name
\emph default
;
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Procedural\InsetSpace ~
assignment
\bar default

\begin_inset LatexCommand \index{assignment, procedural}

\end_inset


\begin_inset LatexCommand \index{procedural assignment}

\end_inset

 
\end_layout

\begin_deeper
\begin_layout Standard
The syntax is 
\end_layout

\begin_layout LyX-Code

\emph on
instance_name
\emph default
 := 
\emph on
mathematical_expression
\emph default
;
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code

\emph on
array_name[set_name]
\emph default
 := 
\emph on
expression
\emph default
;
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code

\emph on
list_of_instance_names
\emph default
 := expression.
\end_layout

\begin_layout Standard
Its meaning is that the value for the variable(s) on the LHS is set to the
 value of the expression on the RHS.
 
\end_layout

\begin_layout Standard

\family sans
DATA
\family default
 statements can (should, rather) also appear in methods.
 
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
FOR/DO
\begin_inset LatexCommand \index{FOR/DO}

\end_inset

 statement
\end_layout

\begin_deeper
\begin_layout Standard
This statement is similar to the 
\family sans
FOR/CREATE
\family default
 statement except it can only appear in a method definition.
 An example would be
\end_layout

\begin_layout LyX-Code
FOR i IN [1..n_stages] DO
\end_layout

\begin_layout LyX-Code
T[i] := T[1] + (i-1)*DT;
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
END FOR;
\end_layout

\begin_layout Standard
Here we actually execute using the values of 
\family typewriter
i
\family default
 in the sequence given.
 So, 
\end_layout

\begin_layout LyX-Code
FOR i IN [n_stages..1] DO ...
 
\end_layout

\begin_layout LyX-Code
END FOR;
\end_layout

\begin_layout Standard
is an empty loop, while
\end_layout

\begin_layout LyX-Code
FOR i IN [n_stages..1] DECREASING DO ...
 
\end_layout

\begin_layout LyX-Code
END FOR;
\end_layout

\begin_layout Standard
is a backward loop.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
IF
\family default

\begin_inset LatexCommand \index{IF}

\end_inset

 
\end_layout

\begin_deeper
\begin_layout Standard
The 
\family sans
IF 
\family default
statement can only appear in a method definition.
 Its syntax is
\end_layout

\begin_layout LyX-Code
IF 
\emph on
logical_expression
\emph default
 THEN
\end_layout

\begin_layout LyX-Code

\emph on
list_of_statements
\end_layout

\begin_layout LyX-Code
ELSE
\end_layout

\begin_layout LyX-Code

\emph on
list_of_statements
\end_layout

\begin_layout LyX-Code
END IF;
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code
IF 
\emph on
logical_expression
\emph default
 THEN
\end_layout

\begin_layout LyX-Code

\emph on
list_of_statements
\end_layout

\begin_layout LyX-Code
END IF;
\end_layout

\begin_layout Standard
If the logical expression has a value of 
\family sans
TRUE
\family default
, ASCEND will execute the statements in the 
\family sans
THEN
\family default
 part.
 If the value is 
\family sans
FALSE
\family default
, ASCEND executes the statements in the optional 
\family sans
ELSE
\family default
 part.
 Please use 
\family typewriter
()
\family default
 to make the precedence of 
\family sans
AND
\family default
, 
\family sans
OR
\family default
, 
\family sans
NOT
\family default
, 
\family typewriter
==
\family default
, and 
\family typewriter
!=
\family default
 clear to both the user and the system.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
SWITCH
\family default

\begin_inset LatexCommand \index{SWITCH}

\end_inset

 Essentially roughly equivalent to the C 
\family typewriter
switch
\family default
 statement, except that ASCEND allows wildcard matches, allows any number
 of controlling variables to be given in a list, and assumes 
\family sans
BREAK
\family default
 at the end of each 
\family sans
CASE
\family default
.
 
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
\begin_inset Note Note
status open

\begin_layout Standard
EXAMPLE of SWITCH required here
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
CALL
\family default

\begin_inset LatexCommand \index{CALL}

\end_inset

 External calls are not presently well defined, pending debugging of the
 
\family sans
EXTERNAL
\family default

\begin_inset LatexCommand \index{EXTERNAL}

\end_inset

 connection prototype originally created by Kirk Abbott.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
RUN
\family default

\begin_inset LatexCommand \index{RUN}

\end_inset

 This statement can appear only in a method.
 Its format is: 
\end_layout

\begin_deeper
\begin_layout LyX-Code
RUN 
\emph on
name_of_method
\emph default
;
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code
RUN 
\emph on
part_name.name_of_method
\emph default
;
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code
RUN 
\emph on
model_type::name_of_method
\emph default
;
\end_layout

\begin_layout Standard
The named method can be defined in the current model (the first syntax),
 or in any of its parts (the second syntax).
 Methods defined in a part will be run in the scope of that part, not at
 the scope of the 
\family sans
RUN
\family default
 statement.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Type\InsetSpace ~
access\InsetSpace ~
to\InsetSpace ~
methods:
\end_layout

\begin_deeper
\begin_layout Standard
When 
\family typewriter
model_type::
\family default

\begin_inset LatexCommand \index{::}

\end_inset

 appears, the type named must be a type that the current model is refined
 from.
 In this way, methods may be defined incrementally.
 For example:
\end_layout

\begin_layout LyX-Code
MODEL foo;
\end_layout

\begin_layout LyX-Code
   x IS_A generic_real;
\end_layout

\begin_layout LyX-Code
METHODS
\end_layout

\begin_layout LyX-Code
METHOD specify;
\end_layout

\begin_layout LyX-Code
   x.fixed:= TRUE;
\end_layout

\begin_layout LyX-Code
END specify;
\end_layout

\begin_layout LyX-Code
END foo;
\end_layout

\begin_layout LyX-Code
MODEL bar REFINES foo;
\end_layout

\begin_layout LyX-Code
   y IS_A generic_real;
\end_layout

\begin_layout LyX-Code
METHODS
\end_layout

\begin_layout LyX-Code
METHOD specify;
\end_layout

\begin_layout LyX-Code
   RUN foo::specify;
\end_layout

\begin_layout LyX-Code
   y.fixed := TRUE;
\end_layout

\begin_layout LyX-Code
END specify;
\end_layout

\begin_layout LyX-Code
END bar;
\end_layout

\begin_layout Chapter
Parameterized models
\begin_inset LatexCommand \index{models, parameterized}

\end_inset


\begin_inset LatexCommand \index{parameterized models}

\end_inset


\begin_inset LatexCommand \label{sec:x.5Parameterized-models}

\end_inset


\end_layout

\begin_layout Standard
Parameterized model definitions have the following general form
\begin_inset Foot
status collapsed

\begin_layout Standard
«» signify optional parts
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
MODEL 
\emph on
new_type
\emph default
(
\emph on
parameter_list
\emph default
;)
\end_layout

\begin_layout LyX-Code
«WHERE (
\emph on
where_list
\emph default
;)»
\end_layout

\begin_layout LyX-Code
«REFINES 
\emph on
existing_type
\emph default
«(
\emph on
assignment_list
\emph default
;)»»;
\end_layout

\begin_layout Section
The parameter list
\begin_inset LatexCommand \label{sub:x.5.1The-parameter-list}

\end_inset


\end_layout

\begin_layout Standard
A parameter list is a list of statements about the objects that will be
 passed into the model being defined when an instance of that model is created
 by 
\family sans
IS_A
\family default
 or 
\family sans
IS_REFINED_TO
\family default
.
 The parameter list is designed to allow a complete statement of the necessary
 and sufficient conditions to construct the parameterized model.
 The mechanism implemented is general, however, so it is possible to put
 less than the necessary information in the parameter list if one seeks
 to confuse the models reusers.
 To make parameters easy to understand for users with experience in other
 computer languages (and to make the implementation much simpler), we define
 the parameter list as ordered.
 All the statements in a parameter list, including the last one, must end
 with a `
\family typewriter
;
\family default
'.
 A parameter list looks like:
\end_layout

\begin_layout LyX-Code
MODEL test (
\end_layout

\begin_layout LyX-Code
   x WILL_BE real;
\end_layout

\begin_layout LyX-Code
   n IS_A integer_constant;
\end_layout

\begin_layout LyX-Code
   p[1..n] IS_A integer_constant;
\end_layout

\begin_layout LyX-Code
   q[0..2*n-1] WILL_BE widget;
\end_layout

\begin_layout LyX-Code
);
\end_layout

\begin_layout Standard
Each 
\family sans
WILL_BE
\family default
 statement corresponds to a single object that the user must create and
 pass into the definition of test.
 We will establish the local name 
\family typewriter
x
\family default
 for the first object passed to the definition of test.
 
\family typewriter
n
\family default
 is handled similarly, and it must preceed the definition of 
\family typewriter
p[1..n]
\family default
, because it defines the set for the array 
\family typewriter
p
\family default
.
 Constant types can also be defined with 
\family sans
WILL_BE
\family default
, though we have used 
\family sans
IS_A
\family default
 for the example test.
\end_layout

\begin_layout Standard
Each 
\family sans
IS_A
\family default
 statement corresponds to a single constant-valued instance or an array
 of constant-valued instances that we will create as part of the model we
 are defining.
 Thus, the user of test must supply an array of constants as the third argument.
 We will check that the instance supplied is subscripted on the set [1..n]
 and copy the corresponding values to the array p we create local to the
 instance of test.
 
\end_layout

\begin_layout Standard

\family sans
WILL_BE
\family default
 statements can be used to pass complex objects (models) or arrays of objects.
 Both 
\family sans
WILL_BE
\family default
 and 
\family sans
IS_A
\family default
 statements can be passed arguments that are more refined than the type
 listed.
 If an object that is less refined than the type listed, the instance of
 parameterized model test will not be compiled.
 When a parameterized model type is specified with a 
\family sans
WILL_BE
\family default
 statement, NO arguments should be given.
 We are only interested in the formal type of the argument, not how it was
 constructed.
\end_layout

\begin_layout Section
The 
\family sans
WHERE
\family default
 list
\begin_inset LatexCommand \index{list, WHERE}

\end_inset


\begin_inset LatexCommand \index{WHERE list}

\end_inset


\end_layout

\begin_layout Standard
We can write structural and equation constraints on the arguments in the
 
\family sans
WHERE
\family default
 list.
 Each statement is a 
\family sans
WILL_BE_THE_SAME
\family default
, a 
\family sans
WILL_NOT_BE_THE_SAME
\family default
, an equation written in terms of sets or discrete constants, or a 
\family sans
FOR/CHECK
\family default
 statement surrounding a group of such statements.
 Until all the conditions in the 
\family sans
WHERE
\family default
 list are satisfied, an object cannot be constructed using the parameterized
 definition.
 If the arguments given to a parameterized type in an 
\family sans
IS_A
\family default
 or 
\family sans
IS_REFINED_TO
\family default
 statement cannot possibly satisfy the conditions, the 
\family sans
IS_A
\family default
 or 
\family sans
IS_REFINED_TO
\family default
 statement is abandoned by the compiler.
\end_layout

\begin_layout Standard
We have not created a 
\family sans
WILL_BE_ALIKE
\family default
 statement because formal type compatibility in ASCEND is not really a meaningfu
l guarantee of object compatibility.
 Object compatibility is much more reliably guaranteed by checking conditions
 on the structure determining constants of a model instance.
\end_layout

\begin_layout Section
The assignment list
\begin_inset LatexCommand \index{list, assignment}

\end_inset


\begin_inset LatexCommand \index{assignment list}

\end_inset


\end_layout

\begin_layout Standard
When we declare constant parameters with 
\family sans
IS_A
\family default
, we can in a later refinement of the parameterized model assign their values
 in the assignment list, thus removing them from the parameter list.
 If an array of constants is declared with 
\family sans
IS_A
\family default
, then we must assign values to ALL the array elements at the same time
 if we are going to remove them from the parameter list.
 If an array element is left out, the type which assigns some of the elements
 and any subsequent refinements of that type will not be compilable.
\end_layout

\begin_layout Section
Refining
\begin_inset LatexCommand \index{refining, parameterized types}

\end_inset

 parameterized types
\end_layout

\begin_layout Standard
Because we wish to make the parameterized model lists represent all the
 parameters and conditions necessary to use a model of any type, we must
 repeat the parameters declared in the ancestral type when we make a refinement.
 If we did not repeat the parameters, the user would be forced to hunt up
 the (possibly long) chain of types that yield an interesting definition
 in order to know the list of parameters and conditions that must be satisfied
 in order to use a model.
 We repeat all the parameters of the type being refined before we add new
 ones.
 The only exception to this is that parameters defined with I
\family sans
S_A
\family default
 and then assigned in the assignment list are not repeated because the user
 no longer needs to supply these values.
 A refinement of the model test given in Section 
\begin_inset LatexCommand \vref{sub:x.5.1The-parameter-list}

\end_inset

 follows.
\end_layout

\begin_layout LyX-Code
MODEL expanded_test (
\end_layout

\begin_layout LyX-Code
   x WILL_BE real;
\end_layout

\begin_layout LyX-Code
   p[1..n] IS_A integer_constant;
\end_layout

\begin_layout LyX-Code
   q[0..2*n-1] WILL_BE better_widget;
\end_layout

\begin_layout LyX-Code
   r[0..q[0].k] WILL_BE gizmo;
\end_layout

\begin_layout LyX-Code
   ms WILL_BE set OF symbol_constant;
\end_layout

\begin_layout LyX-Code
) WHERE (
\end_layout

\begin_layout LyX-Code
   q[0].k >= 2;
\end_layout

\begin_layout LyX-Code
   r[0..q[0].k].giz_part WILL_BE_THE_SAME;
\end_layout

\begin_layout LyX-Code
) REFINES test(
\end_layout

\begin_layout LyX-Code
   n :== 4;
\end_layout

\begin_layout LyX-Code
);
\end_layout

\begin_layout Standard
In expanded_test, we see that the type of the array q is more refined than
 it was in test.
 We see that constants and sets from inside passed objects, such as q[0].k,
 can be used to set the sizes of subseqent array arguments.
 We see a structural constraint that all the gizmos in the array r must
 have been constructed with the same giz_part.
 This condition probably indicates that the gizmo definition takes giz_part
 as a WILL_BE defined parameter.
\end_layout

\begin_layout Chapter
Miscellany
\begin_inset LatexCommand \label{sec:x.6Miscellany}

\end_inset


\end_layout

\begin_layout Section
Variables for solvers
\begin_inset LatexCommand \label{sub:x.6.1Variables-for-solvers}

\end_inset


\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
solver_var
\family default

\begin_inset LatexCommand \index{solver\_var}

\end_inset

 
\family sans
solver_var
\family default
 is the base-type for all computable variables in the current ASCEND system.
 Any instances of an atom definition that refines 
\family sans
solver_var
\family default
 are considered potential variables when constructing a problem for one
 of the solvers.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
solver_var
\family default
 has wildcard dimensionality.
 (Wildcard in this context means that until ASCEND can decide what its dimension
ality is, it has none assigned.
 ASCEND can decide on dimensionality while compiling or executing.) In 
\family typewriter
system.a4l
\family default
 we define the following parts with associated initial values for each:
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Attributes:
\bar default
 
\bar under
type, default
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
lower_bound
\family default

\begin_inset LatexCommand \index{lower\_bound}

\end_inset

 real, 0.0
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
upper_bound
\family default

\begin_inset LatexCommand \index{upper\_bound}

\end_inset

 real, 0.0
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
nominal
\family default

\begin_inset LatexCommand \index{nominal}

\end_inset

 real, 0.0
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
fixed
\family default

\begin_inset LatexCommand \index{fixed}

\end_inset

 boolean, FALSE
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
lower_bound
\family default
 and 
\family sans
upper_bound
\family default
 are bounds for a variable which are monitored and maintained during solving.
 The 
\family sans
nominal
\family default
 value is the value used to scale a variable when solving.
 The flag 
\family sans
fixed
\family default
 indicates if the variable is to be held fixed during solving.
 All atoms which are refinements of 
\family sans
solver_var
\family default
 will have these parts.
 The refining definitions may reassign the default values of the attributes.
\end_layout

\begin_layout Standard
The latest full definition of 
\family sans
solver_var
\family default
 is always in the file 
\family typewriter
system.a4l
\family default
.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
generic_real
\family default

\begin_inset LatexCommand \index{generic\_real}

\end_inset

 One should not declare a variable to be of type 
\family sans
solver_var
\family default
.
 The nominal value and bound values will get you into trouble when solving.
 If you are programming and do not wish to declare variable types, then
 declare them to be of type 
\family sans
generic_real
\family default
.
 This type has nominal value of 0.5 and lower and upper bounds of 
\family typewriter
-1.0e50
\family default
 and 
\family typewriter
1.0e50
\family default
 respectively.
 It is dimensionless.
 The type 
\family sans
generic_real
\family default
 is the first refinement of 
\family sans
solver_var
\family default
 and is also defined in 
\family typewriter
system.a4l
\family default
.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Kluges\InsetSpace ~
for\InsetSpace ~
MILPs
\bar default

\begin_inset LatexCommand \index{MILPs}

\end_inset

 Also defined in 
\family typewriter
system.a4l
\family default
 are the types for integer, binary, and semi-continuous variables
\begin_inset LatexCommand \index{variables, semi-continuous}

\end_inset

.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
solver_semi
\family default

\begin_inset LatexCommand \index{solver\_semi}

\end_inset

,\InsetSpace ~

\family sans
solver_integer
\family default

\begin_inset LatexCommand \index{solver\_integer}

\end_inset

,\InsetSpace ~

\family sans
solver_binary
\family default

\begin_inset LatexCommand \index{solver\_binary}

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
We define basic refinements of 
\family sans
solver_var
\family default
 to support solvers which are more than simply algebraic.
 Various mixed integer-linear program solvers can be fed 
\family sans
solver_semi
\family default
 based atoms defining semi-continuous variables, 
\family sans
solver_integer
\family default
 based atoms defining integer variables, and 
\family sans
solver_binary
\family default
 based atoms defining binary variables.
 
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Integers\InsetSpace ~
are\InsetSpace ~
relaxable
\begin_inset LatexCommand \index{relaxable integers}

\end_inset


\begin_inset LatexCommand \index{integers, relaxable}

\end_inset

 All these types have associated boolean flags which indicate that either
 the variable is to be treated according to its restricted meaning or it
 is to be relaxed and treated as a normal continuous algebraic variable.
 
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Kluges\InsetSpace ~
for\InsetSpace ~
ODEs
\begin_inset LatexCommand \index{ODEs}

\end_inset


\bar default
 We have an alternate version of 
\family typewriter
system.a4l
\family default
 called 
\family typewriter
ivpsystem.a4l
\family default
 which adds extra flags to the definition of 
\family sans
solver_var
\family default
 in order to support initial value problem (IVP
\begin_inset LatexCommand \index{IVP}

\end_inset

) solvers (integrators
\begin_inset LatexCommand \index{integrators}

\end_inset

).
 Integration in the ASCEND environment is explained in another chapter.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000
ivpsystem.a4l
\begin_inset LatexCommand \index{ivpsystem.a4l}

\end_inset

 Having 
\family typewriter
ivpsystem.a4l
\family default
 is a temporary, but highly effective, way to keep people who want to use
 ASCEND only for algebraic purposes from having to pay for the IVP overhead.
 Algebraic users load 
\family typewriter
system.a4l
\family default
.
 Users who want both algebraic and IVP capability load 
\family typewriter
ivpsystem.a4l
\family default
 instead of 
\family typewriter
system.a4l
\family default
.
 This method is temporary because part of the extended definition of ASCEND
 is that differential calculus constructs will be explicitly supported by
 the compiler.
 The calculus is not yet implemented, however.
\begin_inset Note Note
status open

\begin_layout Standard
the first step towards this is the proposed LINK syntax currently in the
 pipeline.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Section
Supported attributes
\begin_inset LatexCommand \label{sub:x.6.2Supported-attributes}

\end_inset


\end_layout

\begin_layout Standard
The 
\family sans
solver_var
\family default
, and in fact most objects in ASCEND, should have built-in support for (and
 thereby efficient storage of) quite a few more attributes than are defined
 above.
 These built-in attributes are not instances of any sort, merely values.
 The syntax for naming one of these supported attributes is: 
\family sans
object_name.$supported_attribute_name
\family default
.
 
\end_layout

\begin_layout Standard
Supported attributes may have symbol, real, integer, or boolean values.
 Note that the 
\family sans
$
\family default
 syntax is essentially the same as the derivative syntax for relations
\begin_inset Note Note
status open

\begin_layout Standard
what's he talking about here? 'derivative syntax'???
\end_layout

\end_inset

; derivatives are a supported attribute of relations.
 The supported attributes must be defined at the time the ASCEND compiler
 is built.
 The storage requirement for a supported boolean attribute is 1 bit rather
 than the 24 bytes required to store a run-time defined boolean flag.
 Similarly, the requirement for a supported real attribute is 4 or 8 bytes
 instead of 24 bytes.
\end_layout

\end_deeper
\begin_layout Section
Single operand real functions
\begin_inset LatexCommand \index{functions, real}

\end_inset


\begin_inset LatexCommand \label{sub:x.6.3Single-operand-real}

\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
exp
\family default

\begin_inset LatexCommand \index{exp}

\end_inset

() exponential (i.e., 
\family sans
exp
\family default
(
\begin_inset Formula $x$
\end_inset

) 
\begin_inset Formula $=e^{x}$
\end_inset

)
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
ln
\family default

\begin_inset LatexCommand \index{ln}

\end_inset

() log to the base 
\begin_inset Formula $e$
\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
sin
\family default

\begin_inset LatexCommand \index{sin}

\end_inset

() sine.
 argument must be an angle (ASCEND will deal with the unit conversions automatic
ally)
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
cos
\family default

\begin_inset LatexCommand \index{cos}

\end_inset

() cosine.
 argument must be an angle.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
tan
\family default

\begin_inset LatexCommand \index{tan}

\end_inset

() tangent.
 argument must be an angle.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
arcsin
\family default

\begin_inset LatexCommand \index{arcsin}

\end_inset

() inverse sine.
 return value is an angle between -
\begin_inset Formula $\pi/2$
\end_inset

 and 
\begin_inset Formula $\pi/2$
\end_inset

 radians.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
arccos
\family default

\begin_inset LatexCommand \index{arccos}

\end_inset

() inverse cosine.
 return value is an angle between 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $\pi$
\end_inset

 radians.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
arctan
\family default

\begin_inset LatexCommand \index{arctan}

\end_inset

() inverse tangent.
 return value is an angle between -
\begin_inset Formula $\pi/2$
\end_inset

 and 
\begin_inset Formula $\pi/2$
\end_inset

 radians.
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
erf
\family default

\begin_inset LatexCommand \index{erf}

\end_inset

() error function (not available under Windows)
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
sinh
\family default

\begin_inset LatexCommand \index{sinh}

\end_inset

() hyperbolic sine
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
cosh
\family default

\begin_inset LatexCommand \index{cosh}

\end_inset

() hyperbolic cosine
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
tanh
\family default

\begin_inset LatexCommand \index{tanh}

\end_inset

() hyperbolic tangent
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
arcsinh
\family default

\begin_inset LatexCommand \index{arcsinh}

\end_inset

() inverse hyperbolic sine
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
arccosh
\family default

\begin_inset LatexCommand \index{arccosh}

\end_inset

() inverse hyperbolic cosine
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
arctanh
\family default

\begin_inset LatexCommand \index{arctanh}

\end_inset

() inverse hyperbolic tangent
\end_layout

\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
lnm
\family default

\begin_inset LatexCommand \index{lnm}

\end_inset

() modified natural logarithm
\begin_inset LatexCommand \index{ln, modified}

\end_inset

 function.
 This 
\family sans
lnm
\family default
 function is parameterized by a constant 
\family sans
a
\family default
, which is typically set to about 
\family typewriter

\begin_inset Formula $1\times10^{-8}$
\end_inset


\family default
.
 
\family sans
lnm
\family default
(x) is defined as follows:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula \[
\mathrm{lnm}(x)=\left\{ \begin{array}{cc}
\ln(x) & \mathrm{for}\, x>a\\
\frac{x-a}{a}+\ln(a) & \mathrm{for}\, x\le a\end{array}\right.\]

\end_inset


\end_layout

\begin_layout Standard
Below the value a (default setting is 
\family typewriter

\begin_inset Formula $1\times10^{-8}$
\end_inset


\family default
), 
\family sans
lnm
\family default
 takes on the value given by the straight line passing through 
\begin_inset Formula $\ln(a)$
\end_inset

 and having the same slope as 
\begin_inset Formula $\ln(a)$
\end_inset

 has at 
\begin_inset Formula $a$
\end_inset

.
 This function and its first derivative are continuous.
 The second derivative contains a jump at 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\family sans
lnm
\family default
 function can tolerate a negative argument while the 
\family sans
ln
\family default
 function cannot.
 At present the value of 
\begin_inset Formula $a$
\end_inset

 is controllable via the user interface of the ASCEND solvers.
 
\begin_inset Note Note
status open

\begin_layout Standard
need to check that.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
Operand\InsetSpace ~
dimensionality\InsetSpace ~
must\InsetSpace ~
be\InsetSpace ~
correct.
\end_layout

\begin_deeper
\begin_layout Standard
The operands for an ASCEND function must be dimensionally consistent with
 the function in question.
 Most transcendental functions require dimensionless arguments.
 The trigonometric functions require arguments with dimensionality of plane
 angles, 
\begin_inset Formula $P$
\end_inset

.
 ASCEND functions return dimensionally correct results.
\end_layout

\begin_layout Standard
The operands for ASCEND functions are enclosed within rounded parentheses,
 
\family typewriter
()
\family default
.
 An example of use is: 
\end_layout

\begin_layout LyX-Code
y = A*exp(-B/T);
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\bar under
Discontinuous\InsetSpace ~
functions
\begin_inset LatexCommand \index{functions, discontinuous}

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
Discontinuous functions may destroy a Newton
\begin_inset LatexCommand \index{Newton}

\end_inset

-based solution algorithm if used in defining a model equation.
 We strongly suggest considering alternative formulations of your equations.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000

\family sans
abs
\family default

\begin_inset LatexCommand \index{abs}

\end_inset

() absolute value of argument.
 Any dimensionality is allowed in an a
\family sans
bs
\family default
() function.
\end_layout

\begin_deeper
\begin_layout Section
Logical functions
\begin_inset LatexCommand \index{functions, logical}

\end_inset


\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00000.00000.00000.000
SATISFIED
\begin_inset LatexCommand \index{SATISFIED}

\end_inset

() SATISFIED(relation_name,tolerance) returns TRUE if the relation named
 has a residual value less than the real value, tolerance, given.
 If the relation named is a logical relation, the tolerance should not be
 specified, since logical relations evaluate directly to TRUE or FALSE.
\end_layout

\begin_deeper
\begin_layout Section

\family sans
UNITS
\family default

\begin_inset LatexCommand \index{UNITS}

\end_inset

 definitions
\end_layout

\begin_layout Standard
As noted in Section 
\begin_inset LatexCommand \vref{sub:x.1.2Basic-Elements}

\end_inset

, ASCEND will recognize conversion factors
\begin_inset LatexCommand \index{conversion factors}

\end_inset

 when it sees them as 
\family typewriter
{units}
\family default
.
 These units are built up from the basic units, and new units can be defined
 by the user.
 Note that the assignment 
\family typewriter
x:= 0.5 {100};
\family default
 yields 
\family typewriter
x == 50
\family default
, and that there are no `offset conversions
\begin_inset LatexCommand \index{conversion, offset}

\end_inset


\begin_inset LatexCommand \index{offset conversions}

\end_inset

,' e.g.
 F=9/5C+32.
 Please keep unit names to 20 characters or less, as this makes life pretty
 for other users.
\end_layout

\begin_layout Standard
One or more unit conversion factors can be defined with the 
\family sans
UNITS
\family default
 keyword.
 A unit of measure, once defined, stays in the system until the system is
 shut down.
 A measuring unit cannot be defined differently without first shutting down
 the system, but duplicate or equivalent definitions are quietly ignored.
 
\end_layout

\begin_layout Standard
A 
\family sans
UNITS
\family default
 declaration can occur in a file by itself, inside a model or inside an
 atom.
 
\family sans
UNITS
\family default
 definitions are parsed immediately, they will be processed even if a surroundin
g 
\family sans
MODEL
\family default
 or 
\family sans
ATOM
\family default
 definition is rejected.
 Because units and dimensionality are designed into the deepest levels of
 the system, a unit definition must be parsed before any atoms or relations
 use that definition.
 It is good design practice to keep customized unit definitions in separate
 files and 
\family sans
REQUIRE
\family default
 those files at the beginning of any file that uses them.
 Unit definitions are made in the form, for example:
\end_layout

\begin_layout LyX-Code
UNITS (* several unit definitions could be
\end_layout

\begin_layout LyX-Code
here.
 *)
\end_layout

\begin_layout LyX-Code
   ohm = 
\end_layout

\begin_layout LyX-Code
      {kilogram*meter^2/second^3/ampere^2};
\end_layout

\begin_layout LyX-Code
END UNITS;
\end_layout

\begin_layout Standard
The standard units library, 
\family typewriter
measures.a4l
\family default
, is documented in the ASCEND manual, Section 
\begin_inset LatexCommand \ref{cha:physprops}

\end_inset

 
\begin_inset LatexCommand \cite{ASCEND2006}

\end_inset

.
\end_layout

\end_body
\end_document
